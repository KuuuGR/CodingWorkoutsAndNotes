

Mojo video collection
1. r
2.  r
3.  [# Choosing Your Language: Python or Mojo?](https://www.youtube.com/watch?v=OJUorka-XLU)
4. e

-----
--99--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--98--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--97--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--96--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--95--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--94--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--93--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--92--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--91--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--90--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--89--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--88--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--87--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--86--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--85--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--84--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--83--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--82--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--81--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--80--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--79--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--78--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--77--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--76--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--75--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--74--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--73--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--72--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--71--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--70--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--69--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--68--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--67--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--66--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--65--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--64--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--63--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--62--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--61--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--60--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--59--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--58--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--57--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--56--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--55--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--54--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--53--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--52--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--51--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--50--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--49--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--48--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--47--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--46--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--45--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--44--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--43--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--42--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--41--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--40--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--39--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--38--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--37--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--36--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--35--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--34--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--33--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--32--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--31--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--30--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--29--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--28--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--27--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--26--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--25--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--24--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--23--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--22--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--21--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--20--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--19--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--18--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--17--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--16--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--15--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--14--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--13--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--12--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--11--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--10--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--09--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--08--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--07--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--06--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--05--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--04--

-----
Date: 2024.02.02
Link: [# Choosing Your Language: Python or Mojo?](https://www.youtube.com/watch?v=OJUorka-XLU)

Notes:
### Summary of the Content

The video introduces Mojo, a new programming language that combines Python's syntax with Rust-like features, aimed at improving performance while maintaining Python's ease of use. Mojo is a compiled language with static typing, memory safety, and garbage collection, making it an attractive option for Python developers seeking better performance without switching to a completely different language like C or Rust. However, the presenter shares mixed feelings about Mojo, noting its early development stage, compatibility issues, and the current lack of a clear advantage over using Python or Rust directly.

### Advantages

- Mojo offers a syntax similar to Python, making it accessible to Python developers.
- It provides higher performance through compilation and static typing.
- The language incorporates Rust-like memory safety and ownership models, enhancing code reliability.

### Drawbacks

- Mojo is still in early development, lacking stability and full feature support.
- Setting up and installing Mojo can be challenging, especially on systems using pyenv.
- The video suggests that Mojo does not yet solve a significant problem for the presenter, given the effectiveness of Python for most of his needs and Rust as an alternative for high-performance requirements.

### Tips and Advice

- For developers interested in exploring Mojo, start with experimentation and non-critical projects due to its early development stage.
- Consider the transition from Python to Mojo as a way to gradually adopt Rust-like safety and performance features without a steep learning curve.
- Keep an eye on Mojo's development progress to assess when it might become a viable option for production use.

### Main Challenges

- Navigating the early development stage of Mojo and dealing with potential syntax and feature changes over time.
- Deciding whether the performance benefits of Mojo justify the effort of adopting a new language amidst established alternatives like Python and Rust.

### The Importance and Usefulness of the Topic

Exploring Mojo is valuable for Python developers seeking performance improvements and those curious about combining Python's simplicity with Rust's safety and efficiency. The video provides insights into the potential of Mojo and considerations for adopting it as the language matures.

### Accomplishments

- The video effectively introduces Mojo, highlighting its key features and differences from Python.
- It provides practical examples and code comparisons to illustrate Mojo's syntax and capabilities.
- The presenter offers a balanced perspective, acknowledging Mojo's potential while recognizing its current limitations and development status.

### Interesting Quotes or Insightful Sentences

- "Mojo is sort of a marriage of Python and Rust."
- "Mojo doesn't really solve a problem for me...but that might change in the future."

### Lecture Content: Technical Insights

- Detailed overview of Mojo's syntax, type safety, and memory management features.
- Comparison of Mojo with Python and Rust, highlighting the unique aspects of each language.
- Discussion on the practical use of Mojo for Python developers and considerations for its adoption.

### Conclusion

While Mojo presents an intriguing option for Python developers seeking improved performance, its early development status and current challenges limit its immediate applicability. The video encourages keeping an eye on Mojo's progress and considering it for future projects as the language evolves and matures.

Transcription:

If you love using Python, but you need more performance,
there are a few options.
You can buy a really fast, really expensive computer,
which is not ideal.
You can also use C or Rust bindings
and code the part that needs more performance in C or Rust.
But that does mean you need to learn a new language,
switch context, et cetera.
Today, I want to talk about another option,
which is using another programming language altogether,
but one that looks a lot like Python.
I'm talking about Mojo.
I'm going to show you how to use Mojo
and how different from using plain old Python.
And I'm also going to share some of my thoughts about using it
and, well, some mixed feelings I have about it.
Before we start, if you want to learn more
about how to design a piece of software from scratch,
I have a free guide for you.
You can get it at arjan.codes/designguide.
This contains seven steps that I take
whenever I design a new piece of software.
And hopefully it helps you avoid
some of the mistakes that I made in the past.
arjan.codes/designguide.
The link is also in the description of this video.
Now, let's dive into Mojo.
Mojo is a relatively new programming language
that builds on the syntax of Python
and adds quite a few different features.
On top of that, it works internally
in a different way than Python.
There are quite a few differences there, actually,
and that actually helps it achieve
that much higher performance.
The main difference is that Mojo
is actually a compiled language versus Python,
which is interpreted.
In a sense, you can look at Mojo
as sort of a marriage of Python and Rust.
Instead of being interpreted like Python is,
Mojo is compiled.
It has much stronger type safety.
It supports static typing,
which makes a lot of sense in a compiled language.
There is memory safety.
There's garbage collection.
It uses a sort of Rust-style ownership model,
and I'm going to show you some examples
of that later in the video.
A caveat is that Mojo is still in early development,
so it's not ready for production.
It's still missing some essential features.
In fact, at the moment,
it mostly works well on Unix and Mac machines
and on Windows.
You can still use it,
but you have to use the Windows subsystem for Linux.
Also, that means that probably features that we have now
are going to be removed, replaced, improved over time.
So if you're looking for a really stable language,
Mojo is not what you should use.
But still, it can be fun to take a closer look at Mojo
as a form of experimentation and exploration.
Here's an example of a basic Hello World Mojo script.
And to run this, you can simply type Mojo
and then the name of the script.
Assuming, of course, that you have installed the tool.
Now, I did run into a few issues
with installing the tool, by the way.
That was related with using pyenv
and picking the right Python version,
and there were some issues with it
not being able to find some libraries.
Again, it's not production-ready,
so that's kind of how it is.
But anyway, I got it working,
and this is the result.
Let's take a closer look at some of the differences
with Python and some of the features
that Mojo has on top of what Python offers.
If you look at the Hello World file,
you see that there's a couple of minor differences,
like instead of having a def,
we write fn in front of the function name,
similar to what we have in Rust.
Also, main is the actual entry point of the script.
So that's the function that's going to be run
when you execute the script with Python.
That's not the case.
You simply write your commands
at the root indentation level,
and then that's gonna run.
Of course, my best practice that I recommend
is that you actually always define a main function
in your script and then call it explicitly
so it's clear what the entry point of the script is.
But in Mojo, this is by default the main function,
just like in Rust.
Just like Python, there are types.
In this case, we have strings, ambs strings,
and this also returns a string.
So that's the same syntax as with Python's type annotation,
but these are actually static types.
So that's an important difference.
These are checked at compile time.
Another couple of differences.
In Python, we can simply define a variable like this.
In Mojo, that doesn't work.
You see, we get some sort of error.
It doesn't know what x is.
So we need to actually declare it.
You can do that by writing the var keyword
in front of the variable name.
That makes it a mutable variable.
So you can change the value later.
For example, I can write x equals six after that.
But alternatively, you can also use the let keyword.
And then it's constant value.
And you also see that when we try to assign a value to x,
then this actually gives us an error
that this is not allowed.
Also, if you declare functions like this
and you have parameters like a or b in this case,
you need to supply a type.
So if I remove this,
you see that we actually also get an error here
because we need to indicate to Mojo
what the type is of a.
Otherwise, it can't compile the code.
So let's put that back.
In the function body itself,
you don't have to supply a type annotation.
So if I write, let's say,
let my name equals Arjan.
I don't need to indicate that my name
is actually of type string.
But of course, if you want to,
you can add a type annotation here.
It's just not necessary.
And typically, when I define variables like this,
I don't include the type annotation
unless it's completely unclear what the type is.
Normally, you can easily infer it from the right-hand side.
So there's no need to do it.
By the way, if you like talking about
different programming languages,
their pros and their cons,
how they affect software design,
you should definitely check out my free Discord server.
You can get access by going to discord.arjan.codes.
The link is also below.
A few other things that I want to show you.
So this is another version of that same
hello world example.
So we still have our main function.
And I've added a couple of other functions here as well.
There's a hello function,
but there's also a Python-style world function.
Mojo is, in principle, compatible with Python.
But of course, it's a compiled language.
So there needs to be some kind of boundary
between the unsafe, messy Python world
and the memory-safe, very strict Mojo world.
And the way Mojo does that is with the exception mechanism.
Here you see an example of that.
So I have a Python-style function here
called world that's simply going to print world.
And then when I want to call it,
I need to put that in a try-except block.
So if I turn this into a comment, like so,
then you see that now we actually get an error
that we cannot call a function that may raise
in a context that cannot raise.
So Mojo does these types of checks.
And that means that if you want to call a Python function
from a Mojo function,
you need to put it in a try-except block, like so.
If you write a Python-style function like this,
well, that comes at the cost of type safety
because Python doesn't enforce types.
And because of that, Mojo also uses
a different just-in-time compilation mechanism
in order to compile Python code.
And that's a bit slower than running Mojo code directly.
So that's something to be aware of.
Here's another example that shows a couple
of different things that Mojo offers.
So again, there's a main function at the bottom.
That's the entry point of the program.
And then there's a couple of other things here.
There's a struct and there's a trait.
So these things look very similar
to what we have seen in Rust before.
So let's go over how this actually works.
So we have a struct called user,
similar to what a struct is in Rust.
There's one difference, though.
You can define these sorts of functions
to be part of the struct.
In Rust, you need to use an input for that.
A struct can have variables.
So a user, in this case, has a username and an email.
You need to declare these
with the var keywords inside the struct.
And then we have an initializer with a couple of arguments,
and we can set the values inside the struct
in the initializer.
And there's a couple of other functions
that are added here as well, such as this type,
which means that we can have a string representation
of that struct.
So the struct user implements this stringable trait,
which simply says that the type
can be converted to a string.
Another thing that you can see here is a value decorator.
And this simply means that the user struct
can be copied and moved around,
similar to the copy trait in Rust.
So you may think, okay, so a struct is basically a class.
Well, it is slightly different
in that there is no inheritance mechanisms.
For example, classes are not yet supported in Mojo,
but that is a planned feature.
Another thing that I'm using here
is something called a dynamic vector.
And this is similar to Python's list.
You also see we supply a type of dynamic vector.
So this is a vector, a list of users.
And then we can append users to that dynamic vector.
Now, in order to be able to do that,
we need to implement the collection element trait.
That means this user struct
is allowed to be part of collections.
If I remove this, then you see we're going to get an error here
that this is not allowed
because it needs to have the collection element type.
And finally, similar to Python,
we can use a for loop to go through the list of users.
Now, unfortunately, if you try this,
then that doesn't work
because dynamic vectors currently
doesn't implement the iter method.
I don't know if they want to add that in the future,
but that would actually be helpful
to have something like that.
So things like stringable collection elements,
they're traits just like in Rust.
And you can also define your own traits.
I have here another trait called emailable
that I've defined here at the top.
So this trait defines two functions,
getEmail and sendEmail.
And then of course, if you add a trait,
then you also need to implement the methods here.
So if I change these two comments,
then again, we're going to get an error
because it doesn't implement
all the requirements for the trait.
So let me put that back.
So traits are also in the Rust programming language.
It's sort of comparable to what we have in Python with protocols.
But of course, protocol classes in Python are not enforced at all.
They're simply hints.
And with languages like Rust and Mojo,
these are actually enforced and checked when you compile the code.
The final thing that I want to mention about Python compatibility
and how you would transition from Python to Mojo
is that typically, like I've shown you here in this Hello World example,
you would have your Python code in a def function,
similar to how we would do it in Python.
And then you put it in a try-except block
when you call it from a Mojo-style function.
So if you want to transition from Python to Mojo
to benefit from the higher performance,
then one way that you can do it in steps
is simply call that Python code using a try-except block
and then slowly migrate the functions to Mojo functions
at type safety where necessary.
The final thing that I want to talk about is ownership.
So this is similar to how Rust also manages memory.
And we have a couple of different keywords in Mojo to handle ownership.
So there's in-out, there is owned, and there is borrowed.
And this indicates who owns the value at any given time.
And that in turn determines whether the value is actually still needed
or can be cleaned up by looking at who owns the value.
The first option is in-out.
This borrows ownership during the function call.
And it's also mutable.
But after that, it returns the ownership.
So that means that when we run this function,
we get a self object, and we can actually set values in it.
We can change it. That's what in-out does.
If we remove that, we get an error
because we're trying to set values in it.
So this needs to be mutable.
Next to the in-out keyword, we have the borrowed keyword,
which is exactly the same as in-out, except that it's immutable.
So you can't change the object.
And before there was a tiny mistake here, this actually returns ownership.
The final keyword that you can use to manage ownership is owned.
So this actually transfers the ownership of the value
from the caller of the function to the function itself.
So now username, if it's no longer being used afterwards,
then the value will be destroyed by the runtime after that.
By default, the parameter of mojo function is borrowed.
So if you look at the hello world example that I've shown you before,
so we have the add function.
So actually A and B, they're both borrowed.
So you don't need to write the borrowed keyword in front of it,
even though you can.
If you have a Python-style function, like the function here,
and you add a parameter to that,
then by default that parameter is going to be owned.
So ownership is transferred.
And that choice, that design choice,
also has to do with the more dynamic nature of Python.
So it makes more sense that because Python is more dynamic
and we have less control over what happens,
that we actually transfer the ownership of values
when we call Python code.
So I hope these examples gave you an idea of what Mojo is
and how it's different from Python.
Now, currently, like I said, mojo is not ready for production,
so don't use it for mission-critical applications,
even though it's a nice tool to experiment with
and see what is possible.
It can also help you if you are thinking about moving to Rust,
for example, to get a bit of an idea of how things work
in an ownership model of memory.
And then, you know, maybe later on transition to Rust
if you find that interesting.
So there's still several features that need to be implemented
that still need to be done.
And it also means that the syntax may change over time
and that if you write a program in Mojo now,
that in six months or a year,
it may no longer work correctly
because things have changed in the meantime.
Also, it was kind of finicky to set up, at least on my Mac.
I needed to set paths explicitly, run some commands explicitly,
so it wasn't as easy as just installing Python
and then off you go.
Granted, I think most of those issues were related to me using pyenv,
but still, that's a pretty standard setup for people using Python.
So I think if you introduce a new language like Mojo,
you should take that into account
and make sure that it actually also works in those cases.
But I did get it working as it should in the end,
so I'm sure the Mojo team is working on improving those things as well.
So final thoughts about this.
I think Mojo is an intriguing language.
It's an interesting marriage between Python and Rust.
And I find that intriguing because it gives us an idea of what it could look like
if we have a language that sort of marries the best things of both worlds,
both Python with its flexibility and simplicity
and Rust with its type safety and performance.
So am I going to use it personally?
No, it's not yet ready for production yet.
And when I look at how I use Python,
actually in most cases, by far most cases,
Python is actually perfectly suitable to me.
And if I really need high performance,
which is actually kind of rare for me,
then I think I would first investigate whether I could start using Rust more
and integrate that into Python.
Rust is a completely open programming language.
You don't need to sign up for anything,
and it's also quickly gaining popularity.
So I would put my chips on Rust at the moment.
So the bottom line for me is that Mojo doesn't really solve a problem for me.
It's a bit too early, but that might change in the future.
Who knows?
Now I'd like to hear from you.
Are you using Mojo?
Why are you using it instead of Python or Rust or something else?
What are your thoughts about mojo?
Let me know in the comments.
Talking about Rust, if you want to learn more about that,
I did an introduction video a while back
helping Pythonistas get started with Rust more quickly.
And you can watch that right here.
Thanks for watching and see you next time.

----------

-----
--03--

-----
Date: 2024.02.02
Link: [# Choosing Your Language: Python or Mojo?](https://www.youtube.com/watch?v=OJUorka-XLU)

Notes:
Based on the video transcription, here are the notes categorized as per your request:

#### Advantages:

1. **Performance Improvement**: Mojo offers a significant performance boost compared to Python due to being a compiled language.
2. **Strong Type Safety**: Static typing and compile-time checks contribute to fewer runtime errors and more reliable code.
3. **Memory Safety**: Mojo incorporates features like garbage collection and a Rust-style ownership model to manage memory more efficiently.
4. **Python Compatibility**: Mojo provides some level of compatibility with Python, allowing gradual transition and the use of existing Python libraries within certain constraints.

#### Drawbacks:

1. **Early Development Stage**: Mojo is not yet ready for production use and lacks stability and essential features.
2. **Setup and Installation Issues**: Setting up Mojo can be tricky and may require specific configurations, especially when integrating with environments like `pyenv`.
3. **Limited Platform Support**: Currently, Mojo works well mostly on Unix and Mac machines. Windows users need to rely on the Windows subsystem for Linux.
4. **Potential Syntax Changes**: As Mojo is still in development, its syntax and features might change over time, leading to compatibility issues with older codebases.

#### Tips and Advice:

1. **Use for Experimentation**: Mojo is suitable for exploring and experimenting with the performance benefits and features it offers.
2. **Learn Rust Principles**: Understanding Rust's ownership model and memory management can be beneficial, as Mojo incorporates similar concepts.
3. **Handle Python Compatibility Carefully**: When calling Python code from Mojo, ensure proper handling of exceptions and understand the performance trade-offs.

#### Lecture Content:

- The video introduces Mojo, a new programming language that combines Python's syntax with Rust's performance and safety features.
- The speaker explains the fundamental differences between Mojo and Python, such as compiled vs. interpreted execution, strong type safety, and memory management.
- Key features of Mojo, like structs, traits, and memory ownership keywords (in-out, owned, borrowed), are demonstrated through examples.
- The challenges of transitioning from Python to Mojo, including handling Python compatibility and understanding the ownership model, are discussed.

#### Main Challenges:

- Adapting to Mojo's strict type and memory management requirements coming from a dynamic language like Python.
- Dealing with the early stage of Mojo's development, which includes potential instability and frequent changes.

#### The Importance and Usefulness of the Topic:

- The topic is important for developers seeking to improve the performance of Python code without completely shifting to a new language paradigm.
- Understanding Mojo's capabilities and limitations can help developers make informed decisions about adopting new technologies in their projects.

#### Accomplishments:

- The video provides a comprehensive introduction to Mojo, explaining its core concepts and differences from Python.
- Practical examples and demonstrations illustrate how to write and structure code in Mojo.

#### Summary of the Content:

- Mojo is a new programming language that aims to offer Python-like syntax with the performance and safety features of Rust.
- While promising, Mojo is still in early development and not ready for production use.
- The video showcases Mojo's capabilities, limitations, and potential use cases, along with practical coding examples.

#### Interesting Quotes or Insightful Sentences:

- "Mojo is sort of a marriage of Python and Rust."
- "Mojo doesn't really solve a problem for me. It's a bit too early, but that might change in the future."
- "Mojo is an intriguing language... it gives us an idea of what it could look like if we have a language that marries the best things of both worlds, both Python with its flexibility and simplicity and Rust with its type safety and performance."

The video serves as a foundational guide to understanding Mojo, its relationship with Python and Rust, and its current stage in the development lifecycle. It emphasizes the potential of Mojo while also acknowledging its current limitations and the challenges of adopting it in its early stages.


Transcription:

If you love using Python, but you need more performance,
there are a few options.
You can buy a really fast, really expensive computer,
which is not ideal.
You can also use C or Rust bindings
and code the part that needs more performance in C or Rust.
But that does mean you need to learn a new language,
switch context, et cetera.
Today, I want to talk about another option,
which is using another programming language altogether,
but one that looks a lot like Python.
I'm talking about Mojo.
I'm going to show you how to use Mojo
and how different from using plain old Python.
And I'm also going to share some of my thoughts about using it
and, well, some mixed feelings I have about it.
Before we start, if you want to learn more
about how to design a piece of software from scratch,
I have a free guide for you.
You can get it at arjan.codes/designguide.
This contains seven steps that I take
whenever I design a new piece of software.
And hopefully it helps you avoid
some of the mistakes that I made in the past.
arjan.codes/designguide.
The link is also in the description of this video.
Now, let's dive into Mojo.
Mojo is a relatively new programming language
that builds on the syntax of Python
and adds quite a few different features.
On top of that, it works internally
in a different way than Python.
There are quite a few differences there, actually,
and that actually helps it achieve
that much higher performance.
The main difference is that Mojo
is actually a compiled language versus Python,
which is interpreted.
In a sense, you can look at Mojo
as sort of a marriage of Python and Rust.
Instead of being interpreted like Python is,
Mojo is compiled.
It has much stronger type safety.
It supports static typing,
which makes a lot of sense in a compiled language.
There is memory safety.
There's garbage collection.
It uses a sort of Rust-style ownership model,
and I'm going to show you some examples
of that later in the video.
A caveat is that Mojo is still in early development,
so it's not ready for production.
It's still missing some essential features.
In fact, at the moment,
it mostly works well on Unix and Mac machines
and on Windows.
You can still use it,
but you have to use the Windows subsystem for Linux.
Also, that means that probably features that we have now
are going to be removed, replaced, improved over time.
So if you're looking for a really stable language,
Mojo is not what you should use.
But still, it can be fun to take a closer look at Mojo
as a form of experimentation and exploration.
Here's an example of a basic Hello World Mojo script.
And to run this, you can simply type Mojo
and then the name of the script.
Assuming, of course, that you have installed the tool.
Now, I did run into a few issues
with installing the tool, by the way.
That was related with using pyenv
and picking the right Python version,
and there were some issues with it
not being able to find some libraries.
Again, it's not production-ready,
so that's kind of how it is.
But anyway, I got it working,
and this is the result.
Let's take a closer look at some of the differences
with Python and some of the features
that Mojo has on top of what Python offers.
If you look at the Hello World file,
you see that there's a couple of minor differences,
like instead of having a def,
we write fn in front of the function name,
similar to what we have in Rust.
Also, main is the actual entry point of the script.
So that's the function that's going to be run
when you execute the script with Python.
That's not the case.
You simply write your commands
at the root indentation level,
and then that's gonna run.
Of course, my best practice that I recommend
is that you actually always define a main function
in your script and then call it explicitly
so it's clear what the entry point of the script is.
But in Mojo, this is by default the main function,
just like in Rust.
Just like Python, there are types.
In this case, we have strings, ambs strings,
and this also returns a string.
So that's the same syntax as with Python's type annotation,
but these are actually static types.
So that's an important difference.
These are checked at compile time.
Another couple of differences.
In Python, we can simply define a variable like this.
In Mojo, that doesn't work.
You see, we get some sort of error.
It doesn't know what x is.
So we need to actually declare it.
You can do that by writing the var keyword
in front of the variable name.
That makes it a mutable variable.
So you can change the value later.
For example, I can write x equals six after that.
But alternatively, you can also use the let keyword.
And then it's constant value.
And you also see that when we try to assign a value to x,
then this actually gives us an error
that this is not allowed.
Also, if you declare functions like this
and you have parameters like a or b in this case,
you need to supply a type.
So if I remove this,
you see that we actually also get an error here
because we need to indicate to Mojo
what the type is of a.
Otherwise, it can't compile the code.
So let's put that back.
In the function body itself,
you don't have to supply a type annotation.
So if I write, let's say,
let my name equals Arjan.
I don't need to indicate that my name
is actually of type string.
But of course, if you want to,
you can add a type annotation here.
It's just not necessary.
And typically, when I define variables like this,
I don't include the type annotation
unless it's completely unclear what the type is.
Normally, you can easily infer it from the right-hand side.
So there's no need to do it.
By the way, if you like talking about
different programming languages,
their pros and their cons,
how they affect software design,
you should definitely check out my free Discord server.
You can get access by going to discord.arjan.codes.
The link is also below.
A few other things that I want to show you.
So this is another version of that same
hello world example.
So we still have our main function.
And I've added a couple of other functions here as well.
There's a hello function,
but there's also a Python-style world function.
Mojo is, in principle, compatible with Python.
But of course, it's a compiled language.
So there needs to be some kind of boundary
between the unsafe, messy Python world
and the memory-safe, very strict Mojo world.
And the way Mojo does that is with the exception mechanism.
Here you see an example of that.
So I have a Python-style function here
called world that's simply going to print world.
And then when I want to call it,
I need to put that in a try-except block.
So if I turn this into a comment, like so,
then you see that now we actually get an error
that we cannot call a function that may raise
in a context that cannot raise.
So Mojo does these types of checks.
And that means that if you want to call a Python function
from a Mojo function,
you need to put it in a try-except block, like so.
If you write a Python-style function like this,
well, that comes at the cost of type safety
because Python doesn't enforce types.
And because of that, Mojo also uses
a different just-in-time compilation mechanism
in order to compile Python code.
And that's a bit slower than running Mojo code directly.
So that's something to be aware of.
Here's another example that shows a couple
of different things that Mojo offers.
So again, there's a main function at the bottom.
That's the entry point of the program.
And then there's a couple of other things here.
There's a struct and there's a trait.
So these things look very similar
to what we have seen in Rust before.
So let's go over how this actually works.
So we have a struct called user,
similar to what a struct is in Rust.
There's one difference, though.
You can define these sorts of functions
to be part of the struct.
In Rust, you need to use an input for that.
A struct can have variables.
So a user, in this case, has a username and an email.
You need to declare these
with the var keywords inside the struct.
And then we have an initializer with a couple of arguments,
and we can set the values inside the struct
in the initializer.
And there's a couple of other functions
that are added here as well, such as this type,
which means that we can have a string representation
of that struct.
So the struct user implements this stringable trait,
which simply says that the type
can be converted to a string.
Another thing that you can see here is a value decorator.
And this simply means that the user struct
can be copied and moved around,
similar to the copy trait in Rust.
So you may think, okay, so a struct is basically a class.
Well, it is slightly different
in that there is no inheritance mechanisms.
For example, classes are not yet supported in Mojo,
but that is a planned feature.
Another thing that I'm using here
is something called a dynamic vector.
And this is similar to Python's list.
You also see we supply a type of dynamic vector.
So this is a vector, a list of users.
And then we can append users to that dynamic vector.
Now, in order to be able to do that,
we need to implement the collection element trait.
That means this user struct
is allowed to be part of collections.
If I remove this, then you see we're going to get an error here
that this is not allowed
because it needs to have the collection element type.
And finally, similar to Python,
we can use a for loop to go through the list of users.
Now, unfortunately, if you try this,
then that doesn't work
because dynamic vectors currently
doesn't implement the iter method.
I don't know if they want to add that in the future,
but that would actually be helpful
to have something like that.
So things like stringable collection elements,
they're traits just like in Rust.
And you can also define your own traits.
I have here another trait called emailable
that I've defined here at the top.
So this trait defines two functions,
getEmail and sendEmail.
And then of course, if you add a trait,
then you also need to implement the methods here.
So if I change these two comments,
then again, we're going to get an error
because it doesn't implement
all the requirements for the trait.
So let me put that back.
So traits are also in the Rust programming language.
It's sort of comparable to what we have in Python with protocols.
But of course, protocol classes in Python are not enforced at all.
They're simply hints.
And with languages like Rust and Mojo,
these are actually enforced and checked when you compile the code.
The final thing that I want to mention about Python compatibility
and how you would transition from Python to Mojo
is that typically, like I've shown you here in this Hello World example,
you would have your Python code in a def function,
similar to how we would do it in Python.
And then you put it in a try-except block
when you call it from a Mojo-style function.
So if you want to transition from Python to Mojo
to benefit from the higher performance,
then one way that you can do it in steps
is simply call that Python code using a try-except block
and then slowly migrate the functions to Mojo functions
at type safety where necessary.
The final thing that I want to talk about is ownership.
So this is similar to how Rust also manages memory.
And we have a couple of different keywords in Mojo to handle ownership.
So there's in-out, there is owned, and there is borrowed.
And this indicates who owns the value at any given time.
And that in turn determines whether the value is actually still needed
or can be cleaned up by looking at who owns the value.
The first option is in-out.
This borrows ownership during the function call.
And it's also mutable.
But after that, it returns the ownership.
So that means that when we run this function,
we get a self object, and we can actually set values in it.
We can change it. That's what in-out does.
If we remove that, we get an error
because we're trying to set values in it.
So this needs to be mutable.
Next to the in-out keyword, we have the borrowed keyword,
which is exactly the same as in-out, except that it's immutable.
So you can't change the object.
And before there was a tiny mistake here, this actually returns ownership.
The final keyword that you can use to manage ownership is owned.
So this actually transfers the ownership of the value
from the caller of the function to the function itself.
So now username, if it's no longer being used afterwards,
then the value will be destroyed by the runtime after that.
By default, the parameter of mojo function is borrowed.
So if you look at the hello world example that I've shown you before,
so we have the add function.
So actually A and B, they're both borrowed.
So you don't need to write the borrowed keyword in front of it,
even though you can.
If you have a Python-style function, like the function here,
and you add a parameter to that,
then by default that parameter is going to be owned.
So ownership is transferred.
And that choice, that design choice,
also has to do with the more dynamic nature of Python.
So it makes more sense that because Python is more dynamic
and we have less control over what happens,
that we actually transfer the ownership of values
when we call Python code.
So I hope these examples gave you an idea of what Mojo is
and how it's different from Python.
Now, currently, like I said, mojo is not ready for production,
so don't use it for mission-critical applications,
even though it's a nice tool to experiment with
and see what is possible.
It can also help you if you are thinking about moving to Rust,
for example, to get a bit of an idea of how things work
in an ownership model of memory.
And then, you know, maybe later on transition to Rust
if you find that interesting.
So there's still several features that need to be implemented
that still need to be done.
And it also means that the syntax may change over time
and that if you write a program in Mojo now,
that in six months or a year,
it may no longer work correctly
because things have changed in the meantime.
Also, it was kind of finicky to set up, at least on my Mac.
I needed to set paths explicitly, run some commands explicitly,
so it wasn't as easy as just installing Python
and then off you go.
Granted, I think most of those issues were related to me using pyenv,
but still, that's a pretty standard setup for people using Python.
So I think if you introduce a new language like Mojo,
you should take that into account
and make sure that it actually also works in those cases.
But I did get it working as it should in the end,
so I'm sure the Mojo team is working on improving those things as well.
So final thoughts about this.
I think Mojo is an intriguing language.
It's an interesting marriage between Python and Rust.
And I find that intriguing because it gives us an idea of what it could look like
if we have a language that sort of marries the best things of both worlds,
both Python with its flexibility and simplicity
and Rust with its type safety and performance.
So am I going to use it personally?
No, it's not yet ready for production yet.
And when I look at how I use Python,
actually in most cases, by far most cases,
Python is actually perfectly suitable to me.
And if I really need high performance,
which is actually kind of rare for me,
then I think I would first investigate whether I could start using Rust more
and integrate that into Python.
Rust is a completely open programming language.
You don't need to sign up for anything,
and it's also quickly gaining popularity.
So I would put my chips on Rust at the moment.
So the bottom line for me is that Mojo doesn't really solve a problem for me.
It's a bit too early, but that might change in the future.
Who knows?
Now I'd like to hear from you.
Are you using Mojo?
Why are you using it instead of Python or Rust or something else?
What are your thoughts about mojo?
Let me know in the comments.
Talking about Rust, if you want to learn more about that,
I did an introduction video a while back
helping Pythonistas get started with Rust more quickly.
And you can watch that right here.
Thanks for watching and see you next time.

----------

-----
--02--

-----
Date: 2023.11.19
Link: [# SPICE Metric || Image Captioning || Deep Learning](https://www.youtube.com/watch?v=As441oo3yk8)

Notes:
### Video Notes on SPICE Metric for Image Captioning

#### Lecture Content

- The lecture discusses the SPICE metric, a method for evaluating the quality of image captions by comparing the semantic propositional content of captions rather than relying on n-gram overlap.
- The SPICE metric addresses the limitations of other automatic metrics like BLEU, METEOR, CIDEr, or ROUGE, which are sensitive to n-gram overlap but may not accurately reflect the semantic similarity between captions.
- The SPICE metric utilizes a scene graph (Sing graph) representation to encode the objects, attributes, and relationships in image captions, abstracting away the syntax of natural language.

#### Advantages

- **Semantic Accuracy:** SPICE focuses on the semantic propositional content of captions, providing a more accurate measure of the quality of image captioning.
- **Sing Graphs:** By using scene graph representations, SPICE captures the objects, attributes, and relationships in image captions, offering a richer understanding of the content.
- **Interpretability:** The SPICE score is simple to interpret, ranging between 0 and 1, where 1 indicates a high similarity between the candidate and reference captions.

#### Drawbacks

- **Complexity:** The construction and comparison of scene graphs are more complex than n-gram-based approaches.
- **No Partial Credit:** SPICE does not give partial credit for tupos where only one element is incorrect, potentially leading to lower scores for captions that are semantically similar but not identical in structure.
- **Dependency on Dependency Parsing:** The initial parsing of captions using a dependency parser is crucial and may affect the accuracy of the resulting scene graph.

#### Tips and Advice

- When evaluating image captioning, use a combination of metrics (SPICE, BLEU, METEOR, etc.) to get a comprehensive understanding of the performance.
- Pay attention to the semantic content of the captions rather than just the syntactic structure.
- Be mindful of the limitations of each metric and consider them when interpreting the results.

#### Main Challenges

- Constructing accurate scene graphs that represent the semantic content of captions.
- Ensuring that the spice metric's reliance on semantic propositional content aligns well with human judgment.

#### The Importance and Usefulness of the Topic

- The SPICE metric offers a significant improvement in evaluating image captioning systems, focusing on the semantic content rather than just syntactic similarity.
- Understanding and correctly implementing the SPICE metric can lead to more accurate and human-like performance in image captioning tasks.

#### Accomplishments

- Detailed explanation of how the SPICE metric works, including the construction of scene graphs and the computation of the SPICE score.
- Highlighted the limitations of n-gram overlap metrics and how SPICE addresses these issues.

#### Summary of the Content

- The video provides an in-depth overview of the SPICE metric for image captioning, explaining its advantages over traditional n-gram overlap metrics. It details the process of constructing scene graphs, simplifying quantifiers, resolving pronouns, handling plural nouns, and representing semantic relations as tuples. The video also discusses the interpretability and adaptability of the SPICE score, emphasizing its usefulness in evaluating the semantic accuracy of image captions.

#### Interesting Quotes or Insightful Sentences

- "Engram overlap is neither necessary nor sufficient for two sentences to convey the same meaning."
- "The SPICE metric suggests that the semantic propositional content is an important component of caption evaluation."
- "SPICE score is simple to understand and interpret as it naturally ranges between zero and one."

The video offers a comprehensive explanation of the SPICE metric, highlighting its significance in advancing the quality and accuracy of image captioning by focusing on semantic content over syntactic structure.

Transcription:

hey everyone how's it going welcome back
to another video today we'll be covering
the spice metric for image
captioning so the first question is
obviously what are some issues with
other automatic metrics used for image
captioning why do we need this new
metric called
spice well other metrics such as blue
meteor cider or rge they're all
sensitive to engram overlap and engram
overlap is neither necessary nor more
sufficient for two sentences to convey
the same meaning so to illustrate the
limitations of engram comparisons
consider the following caption from the
MS Coco data set the first caption says
a young girl standing on top of a tennis
court and the second caption says a
giraffe standing on top of a green field
these two captions have five fors that
overlap however they convey completely
different messages and thus these two
captions should not be considered
similar however using these engram
techniques these two captions are
actually considered very
similar so the main idea behind
spice spice suggest that the semantic
propositional content is an important
component of caption
evaluation so for example given an image
with the caption a young girl standing
on top of a tennis court we expect that
a human evaluation will consider the
following to score the caption there is
a girl the girl is Young the girl is
standing there is a court court is
tennis the girl is on top of court right
as human evaluators we'll probably have
these in mind so when we're looking at
the given image and the caption we'll be
like hey does the caption have these
criterias right so this is what the
spies metric is trying to model
model now they basically do this by the
construction of something called a sing
graph so they estimate caption quality
by transforming both the candidate and
reference captions into a graph-based
semantic representation called a sing
graph and the sing graph encodes the
objects attributes and relationships
found in image captions while
abstracting away all the syntactic
sugars of natural language so so uh for
example they provided this graph here to
show us what it looks like so we have a
girl here this is um a noun and it's the
subject right and it's connected to all
these other grammar stuff
right
okay now let's go into details of how we
can construct the actual sing graph and
how they actually constructed the in
graph so initial step the captions are
in initial parsed using a dependency
parser to establish syntactic
dependencies between
words so what is dependency
parsing parsing in natural language
processing is like analyzing a sentence
to understand its structure it's similar
to how you might break down a sentence
to understand its grammar in school
right so dependency parsing identifies
relationships like which word is the
main sub subject which is an action or
other words verb and how other words
modify or relate to these words right so
that's what we're doing here uh so like
here's an example if we input a caption
a young girl standing on top of a tennis
court we could assign a part of speech
to each token so uh is a
determiners uh Yan is adjective girl is
the noun and also the subject staning is
the a verb and right all these grammar
stuff so we established dependencies
using a dependency tree here okay and
this is you can see everything that's
going on in this diagram
here so after that we perform some
postprocessing
steps so first we simplify the
quantificational
modifiers so the purpose this step
involves simplifying modifiers that
quantify objects in the caption and
quantificational modifiers include words
or phrases that indicate amounts like
several many or specific numbers like
three right so how it works the parcel
identifies these quantifiers and
simplifies them to make the structure
more straightforward for example if we
have three dogs it will be simplified to
the object dog with an attribute
indicating the quantity three so instead
of representing three dogs as three
separate nodes in the sing graph it will
be represented as a single note dog with
an attribute indicating the quantity
three and we also have resolving
pronouns so pronouns like he she it or
they are used in place of nouns this
step aims to resolve these pronouns to
um the nouns they refer to so how it
works the system determines what each
pronoun refers to in the context of the
caption for example if a caption says it
is running and it refers to a previously
mentioned dog the parcel will link it to
dog and we'll see all of these steps in
more
detail and we have handling plural nouns
so the purpose of this step is to deal
with plural nouns ensuring that the same
graph correctly represents multiple
instan of an object so how it works
instead of creating multiple nodes for
each instance of a plural noun spice
treats plural nouns differently it
avoids duplicating notes and instead
represents pluralities as attributes for
instance dogs will be represented as a
single note dog with an attribute
indicating plurality
okay now the next step is representation
of semantic relation as tup so they
represent sing graphs as tuples the
semantic relations in the sing graph are
viewed as logical propositions or
tupos um this way right because the
machine cannot actually visualize this
graph we have here they represent this
entire graph with
tbos so how did they form this T right
uh they provide a function T and that is
defined
as a function that returns these two Po
from a sing graph so t g of C where G of
C represents the sing graph of the
caption and the twole contain elements
representing objects uh o of C
attributes K of C and relations e of C
so for the sing graph in the example
figure the TST might be girl Court girl
young girl standing court tennis girl on
top of court right so we can see all
these connections girl and young girl
and standing uh girl and court right um
all these stuff
right
okay and we basically match two posts
between SC graphs to see how similar
they are right and this is using the
binary matching operator a binary
matching operator this is the symbol is
used to identify
uh the matching tupos between two sing
graphs um the candidate caption and the
reference S graph right so the reference
sing graph is basically the ground truth
right this is what we're trying to reach
and the candidate caption is the sing
graph generated from uh the caption from
like a machine learning model for
example Right image captioning
model okay so we could calculate the
Precision recall and spice score so the
Precision is the ratio of the number of
matching tupos between the candidate and
reference sing graphs to the total
number of tupos in the candidate sing
graph right so we have TG of c and then
we're trying to find where they overlap
T of G of s and then divided by T of G
of C right this formula here and we also
have recall which is defined as the
ratio of the number of matching tupos
between the candidate and referencing
graphs to the total number of tupos in
the referencing graphs so basically pres
but uh the ratio is to referencing
graphs instead of candidate Sy graphs
okay and finally the Spy score which is
really the F1 score and that is the
harmonic meane of precision and recall
right um spice score is the F1 score so
we apply this form
and P and R we already know how to solve
for those up there so this one is pretty
free okay and this is how you calculate
the spice score if you have two uh two
captions
right so what are the matching criteria
right how can we determine that two
tupos actually match uh they use
something called word net synonym
matching so for matching TST the the
spice metric employs a word net synonym
matching approach similar to the meteor
metric so T post are consider a match if
their lemmatized word forms are equal or
if they are found in the same word net
sin set so lemmatized basically means
that uh for example the word running or
ran they're all simplified to the root
or most basic form run right basically
simplifying all these words to their
root form
and what is the word net right the word
net is a large lexical database of
English where nouns verbs adjectives and
adverbs are grouped into sets of
cognitive synonyms or also known as
sunsets each expressing a distinct
concept sunsets are interl by means of
conceptual semantic and lexical
relationss a sunset is a set of synonyms
that share a common meaning for example
the words sh bow and vessel might be in
the same Sunset because they all refer
to a medium-sized um water craft right
okay and another important thing to
acknowledge is that there is no partial
credit for incorrect tupos so unlike
other metrics spice does not give
partial credit for tupos where only one
element is incorrect right um this is
because many common relations in image
captions like in or on do not deserve
credit if they are applied incorrectly
right they could um change the caption
by a wide
margin and now let's talk about
interpretability and
actability ah that was a mouthful okay
so the spice score is simple to
understand and interpret as it naturally
ranges between zero and one so you know
one obviously means that uh two captions
are more similar so therefore your
candidate caption has a pretty high
score if you score one
right and it does not rely on Cross data
set statistics making it applicable to
both small and large data sets so
overall uh spice is a pretty good metric
but for image captioning um evaluation
you will typically use spies blue meteor
all of those at the same time just to
see what you get right it's not like you
have to choose one out of all of them
and nowadays they're actually uh trying
to expand uh automatic U metrics to
evaluate large Vision language models as
well but they use slightly different
approaches although they still use spy
score uh meteor blue right so it's still
important to understand how they work
and yeah that's it for this video if you
have any questions or suggestions or
comments um just leave them down in the
comment section below and I will try to
respond as soon as possible all right
thank you guys for watching and see you
next time

----------

-----
--01--

-----
Date:  2023.09.17
Link: [# Mojo Programming Language Modules and Packages || Mojo Tutorial](https://www.youtube.com/watch?v=1PQIHzls13s)

Notes:
### Video Notes on Organizing Code into Modules and Packages in Mojo

#### Lecture Content

- The lecture focuses on organizing code into modules and packages in Mojo, a programming language.
- A module is a file containing code that other files can import and use.
- A package is a collection of modules in a directory, marked by an `init.mojo` file.

#### Advantages

- **Modularity:** Allows for cleaner, more organized code by separating concerns into different files.
- **Reusability:** Modules can be reused across different parts of an application or in different projects.
- **Namespace Management:** Packages help in organizing and grouping similar modules, avoiding naming conflicts.

#### Drawbacks

- **Complexity in Configuration:** Importing modules and packages requires understanding of file structure and namespace.
- **Dependency Management:** Managing multiple modules and their interdependencies can be complex.

#### Tips and Advice

- Use `let` for constant definitions in Mojo, as it makes the variable immutable.
- Be cautious with the naming of packages and modules to avoid conflicts.
- Compile your package into a `.mojoPKG` file for ease of distribution and to avoid having source code in the same location as the main module.

#### Main Challenges

- Understanding the file structure and how Mojo recognizes modules and packages.
- Dealing with unexpected errors or bugs in the language or development environment.

#### The Importance and Usefulness of the Topic

- Understanding modules and packages is crucial for writing scalable and maintainable code.
- Helps in organizing large codebases, making them easier to navigate and manage.

#### Accomplishments

- Demonstrated how to create and import modules and packages in Mojo.
- Showed how to compile a package into a `.mojoPKG` file for distribution.
- Provided a workaround for naming issues with compiled package files.

#### Summary of the Content

- The video explains how to organize code in Mojo using modules and packages, starting with module creation, struct definition, and function implementation. It then moves on to package creation, including the necessity of an `init.mojo` file, and demonstrates code importation from modules. Finally, it covers the compilation of packages into distributable `.mojoPKG` files.

#### Interesting Quotes or Insightful Sentences

- "Modules are essentially files that include code for other files to use by importing it."
- "The `init.mojo` file is crucial because if you delete it, then Mojo doesn't recognize the directory as a package."
- "You can't just change the name [of a compiled package]... the package name is encoded in the file."

The video offers a comprehensive guide on using modules and packages in Mojo, addressing the importance of structure and organization in coding for efficiency and scalability. Despite some technical glitches, the content is informative, especially for those new to Mojo or looking to understand the concept of modularity in programming.

Transcription: 

Hey everyone, I hope you found this video to be helpful! If you have any suggestions, questions, or concerns, please let me know in the description below! I will answer as soon as possible, :) thanks for the support!

hey everyone I hope you're all doing
well today we are going to learn how to
organize our code into modules and
packages like how we do it in Python to
understand Mojo packages we first need
to understand Mojo modules so a module
is essentially a file that includes code
for other files to use by importing it
so let's see an example uh let's I'm
currently in the main. mod file but
let's create a new file called my pair.
module this is going to be our module
okay so it's another module file but
this is a module so let's define struct
called pair and we have a first which is
in and our second which is also in let's
deal with integers for now and to uh
simplify this and let's define our
Constructor in it uh in out self first
which is an in and second which is also
an end and self. first equal first self.
second equal second okay so basically we
set first to whatever we pass in for
this and second to what to whatever we
passing for this okay and now for this
struct also let's define a dump function
that basically prints out our pair so
self do first self. second so we can see
what our pair looks like now let's write
this so essentially what we have done is
that we Define a module that defines a
pair struct okay uh notice that this
module we don't see a main function like
we do in the main. modu file so we can't
actually execute our
code um this is the same for many
compiled languages where the main
function is the entry point for program
execution um so we have to import this
module into another file with a main
function so we can use it uh this is uh
so let's see how we can do
that so we have our main function here
and so far I only have print hello
YouTube right okay so now let's define a
pair right let my pair equal pair let's
do one and
two so you see an error here because we
don't know what pair is in this file we
can't access pair in this other file so
we have to import it
oops so let's import that really quick
from my pair import pair so basically
what we have done is that we import pair
from the my pair. modojo file here and
now we can use it to define a pair which
takes in two integers right first and
second and then we set those numbers we
set first s uh we set one and two um we
we set first and second to one and two
respectively
okay and notice I'm using let here which
means that it's constant we won't be
changing this in the future um this
might be counterintuitive if you're
familiar with
JavaScript but the let keyword and Mojo
makes this a
constant
okay um now let's
see my parent dump right let's see what
this looks like sorry you don't actually
need this semicolon at end but you could
includ it okay now let's run it we can
just do Mojo main. Mojo in the terminal
and we get one and
two okay so dot dump pretty much just
prints it out for
us okay and
alternatively we could also delete this
line and we can just do my pair do
pair
uh let's
see I know my
pair oh sorry we could do import my pair
right after we import my pair we can
just do my pair. pair right so if you
have a lot of functions or uh if you
have a lot of struct or functions Define
in um the my pair. modjo file you could
just use one import line and then um use
my pair. pair like this right um we can
also create an alias for the imported
member just like in Python so I could do
import my pair as
MP and then down here we can just do mp.
pair and this will also work so let's
run it boom one and two so this also
works awesome so I hope you guys
understand what modos are in Mojo now
and how they work so let's talk about
packages
now so what is a Mojo package uh a Mojo
package is just a collection of Mojo
modules in a directory that includes a
in it. Mojo file so your file structure
might look something like this you have
your main. moojo file up there
and you have this directory called uh
mik package you can name it whatever
right whatever the package name is and
in here you have to set a init Mojo file
in order to let Mojo know that this
directory is a package and inside this
directory you can Define several modules
like my pair for example that's a module
we can Define and you can Define several
as many as you want down here okay
um so the in it. Mojo file is actually
crucial because if you delete it then
Mojo doesn't recognize the directory as
a package so now let's see how this
works in code so I'm back in vs code
let's create a folder called my
package and inside here let's do
init Mojo So we have a init Mojo file WR
it and inside there we also have uh
let's just move my pair into my
package okay so now it's in my
package okay now how can we use my pair
now that it's in my package right my
pair is now in my package folder so what
we could do is that from my
package. my my pair import pair so what
we have done is that we're importing my
pair from my package and then we're
importing the pair function from my pair
which is the module
okay now let's use that let my pair
equal pair 1 and two let's
see a crash happened with the Mojo pars
okay so this is an unexpected error uh
this shouldn't be happening but so
ignore this error for now um let's just
continue so my pair.
dump um this should theoretically work
but it something is wrong with mod let's
see if we can run it so we can run it
just fine it prints out one and two so
this does work so I guess it's an error
with the um error system
here so basically what you have to know
is that the init
Mojo uh file allows us to recognize the
directory as a package thereby allowing
us to import the module my pair inside
the main. module uh
file now let's say we don't want the my
package source code in the same location
as main. modu we can compile into a
package using this in our terminal Mojo
package my package which is the name of
our directory - o uh whatever name we
want the do Mojo PKG file to be named so
in this case I'm naming it my pack and
then we end it with Mojo PKG which
stands for Mojo package okay then um so
your you your code your file structure
will look some something like this main.
moojo and then you will have a my
pack. mojo
PKG and let's see how we can use it
right so I'm back in vs code let's run
the
commands uh I'm not sure if you guys can
see this but we can run modu package my
package and then - o my
pack. modu PKG
so as you can see here we have a my
pack. modjo PKG file and let's use that
right in
our uh let's delete this in our main.
Modo file we can do from my pack. myair
import
pair so as you can see that didn't give
us any errors so it works so the my
pack. mojo PKG is different from my pack
package my pack is this modjo PKG file
and inside we are accessing my pair
which is this file and then we import
pair inside of my um my pair okay now
let's use that right um let my pair
equal pair 1 and
two and let's do my pair. dump to see
what we have and and let's run
it boom one and two so this works just
fine and we have a single. moojo PKG
file that does the same thing as my
package so what is the benefit of using
Mojo PKG right well you can share it
with other people so you can literally
just send a file to someone else and
they can run it so it's really easy to
use and if you don't want my package uh
this directory to be in the same
location as main. modu you can just
compile it into a modu PKG file
okay um just an important note here if
you want to modify the name of the Mojo
PKG file uh after you compiled it right
um you actually cannot simply edit the
name of this file because the package
name is encoded in in the file so if I
change this
to uh pack. modu
PKG this will still run because it's
technically still uh my pack right so
you can't just change the name that way
you have to uh run module package again
to specify the new name of the do Modo
PKG
file
okay um so now now you might be
wondering can we write any code in the
inet the modjo file since it's currently
empty right and the answer is yes we are
going to see what we can use it for so
let's add the following line in our mojo
inet Mojo file from my pair import pair
so we're importing pair from my pair
which is in the same directory as in it
the modu
okay now what does this actually
do well if we go to main.
module
um so we can let me clear this first we
can simply do from so let's see what we
had to do before right we had to do my
package do my pair import pair right
this is what we had to do before but now
since we imported PA inside the in it.
Mojo file we can just
do my pack from my package import pair
oops sorry I have to save this
file um now it should
work uh package my package does not
contain
pair
interesting let's see if this run
uh sometimes vs code can be buggy so
let's define a my pair equal pair
one2 yep another crash happened uh I
think it's something wrong with this
plug-in uh let's just ignore that error
message for now and let's do my pair.
dump and see if this works let's save it
let's clear our
terminal that did not work okay
unable to locate module my
pair um
move that's
annoying um let's
see
well
okay so I think it's something wrong
with uh Mojo right now because this
should theoretically work according to
the modu
documentation I'm not sure what's
causing this error or how to fix it for
now but in the future if you're watching
this just know that this should
technically print out one and two okay
um yeah
I'm not sure what's causing
there um okay so I hope you guys found
this video helpful except the LA the
last part
maybe um hopefully they'll fix that
error I will definitely report a issue
to the GitHub repo okay so yeah I hope
you guys found this video to be helpful
and hope you learned something if you
enjoyed this video please like And
subscribe I'll definitely be posting
more Mojo videos in the future so if
you're interested in this language so
far please like And
subscribe and yeah hope you guys do well
and see you next time
bye

----------

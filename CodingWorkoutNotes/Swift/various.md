1. [What I Want to See in Swift in 2024 (But Probably Wouldn’t) | @SwiftBird](https://www.youtube.com/watch?v=TnwcB6f9tSw)
2. [# 30 tips to be a better iOS developer](https://www.youtube.com/watch?v=HEQGm1gVtOQ)
3. [# iOS Interview Questions and Answers with Sample Code](https://www.youtube.com/watch?v=gmyEHW7zDYc)✰⋆🌟
4. [2023 LLVM Dev Mtg - Compact Value Witnesses in Swift](https://www.youtube.com/watch?v=hjgDwdGJIhI)
5. [# SwiftUI Navigation Made Easy: Harnessing the Magic of Enums](https://www.youtube.com/watch?v=do4uZBXP6bc)
6. [# All You Need to Know About Swift Macros | Swift Macros Deep Dive (Part 1) | @SwiftBird](https://www.youtube.com/watch?v=LrY9f5kOQ_4)
7. [# 15-Year-Old App Goes All Swift | Caffeine Refactored | @SwiftBird](https://www.youtube.com/watch?v=fehxCCKWpZA)
8. 




-----
--99--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--98--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--97--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--96--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--95--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--94--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--93--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--92--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--91--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--90--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--89--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--88--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--87--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--86--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--85--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--84--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--83--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--82--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--81--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--80--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--79--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--78--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--77--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--76--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--75--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--74--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--73--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--72--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--71--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--70--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--69--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--68--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--67--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--66--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--65--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--64--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--63--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--62--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--61--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--60--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--59--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--58--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--57--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--56--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--55--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--54--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--53--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--52--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--51--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--50--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--49--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--48--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--47--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--46--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--45--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--44--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--43--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--42--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--41--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--40--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--39--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--38--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--37--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--36--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--35--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--34--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--33--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--32--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--31--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--30--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--29--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--28--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--27--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--26--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--25--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--24--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--23--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--22--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--21--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--20--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--19--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--18--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--17--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--16--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--15--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--14--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--13--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--12--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--11--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--10--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--09--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--08--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--07--

-----
Date: 2023.05.17
Link: [# 15-Year-Old App Goes All Swift | Caffeine Refactored | @SwiftBird](https://www.youtube.com/watch?v=fehxCCKWpZA)
Note:
### Summary of the Content

This video by Yakov from The Swift Bird blog shares the journey of rewriting the Caffeine app for Mac in Swift. Yakov discusses the motivations behind the switch from Objective-C to Swift, the challenges encountered during the process, and the improvements made to the app.

### Advantages of Switching to Swift

- **Language Efficiency**: Swift's modern features allowed for more streamlined and robust code.
- **Enhanced User Experience**: The transition aimed to maintain the simplicity and functionality that Caffeine users have come to expect, without altering the app's familiar interface.

### Challenges in Transition

- **Integration Hurdles**: Mixing Swift with Objective-C presented significant challenges, such as import loops and the need for extensive forward declarations.
- **AppKit API Limitations**: Updates to macOS and AppKit's APIs necessitated workarounds, especially for the app's menu bar icon functionality.

### Key Takeaways and Tips

- **Step-by-Step Approach**: Yakov recommends a phased approach to transitioning languages within a project—starting with a literal translation before moving on to refactoring.
- **Swift's Enums for Clarity**: Utilizing Swift's enumeration capabilities can significantly reduce the reliance on "magic numbers" and improve code readability.

### Technical Insights

- Yakov provides a detailed account of converting Objective-C code to Swift, addressing the specific changes made to the time presets and the menu-bar icon.
- The video highlights the limitations posed by deprecated AppKit APIs and describes the creative solutions employed to maintain the app's one-click activation feature.

### Accomplishments and Reflections

- **Successful Rewrite**: The project successfully updated Caffeine for modern macOS versions, leveraging Swift's strengths to enhance the app's codebase.
- **Continuous Learning**: Yakov views Caffeine as a learning project, expressing satisfaction with the rewrite and curiosity about exploring SwiftUI for future developments.

### Interesting Quotes

- "Even though Swift is advertised as a more safe and reliable programming language—and it is, undoubtedly—using it in the mixed environment takes some compromise."
- "Caffeine, just as all of my side projects, is first and foremost a playground where I can learn and practice with new technologies."

### Conclusion

Yakov concludes by sharing his contentment with the rewrite and his plans to delve into SwiftUI, emphasizing the joy of learning new technologies through software development. He encourages viewers to support the channel and teases upcoming content.

### Engagement Encouragement

Yakov invites viewers to like, subscribe, and consider supporting The Swift Bird for more tech and software development content, promising more insightful videos in the future.

Transcription:

Intro
Hey! I’m Yakov, and this is The Swift  Bird, a blog about tech, software,  
and birds. From time to time, I cover  some of my own projects on this channel,  
and in this video, I’ll tell you about  how I rewrote the Caffeine app in Swift.
If you find this video helpful or at least  entertaining, please give it a like and  
subscribe to the channel. You can also support  me with a small donation at the links below.
Now, let’s get started!
About Caffeine
Caffeine is a small Mac utility which prevents the  computer from going to sleep. It was originally  
published back in the mid-2000s and last  updated over ten years ago. Since then,  
the company behind Caffeine has  gone out of business, but luckily,  
it open-sourced the code. Ever since I learned  about Caffeine, I used it nearly every day for  
reading long documents, exporting videos,  and doing other tasks. But as macOS evolved,  
Caffeine’s degraded to the point where the Mac  refused to even launch the app—just because it  
wasn’t signed with a valid certificate. And at  that point, I decided to do something about it.
In my previous video on Caffeine, I explained  what I found in the open-source repo and what  
I did to modernize the app. I reused  the original Objective-C codebase,  
and the result was good enough to put  the app on the App Store. But if you’re  
Why Switch to Swift
familiar with both Objective-C  and Swift, you know how much you  
can improve and optimize by switching to the  new language. And that’s exactly what I did.
I wanted to preserve the look and feel that users  expected from Caffeine, and because of that,  
I didn’t feel comfortable to just scrap the old  code and write new one from scratch. Instead,  
I followed the step-by-step approach:  literally translating the code first,  
and then refactoring it  with Swift-native solutions.
Translating the Code Literally (What Could Go Wrong?)
When you introduce the first batch of Swift  components, Xcode provides a Swift header. You  
import it in existing Objective-C files to make  Swift symbols visible. Normally, you don’t see the  
header file in the project structure ’cause it’s  generated on the fly. However, you can influence  
what goes into the file by annotating your Swift  components with the @objc attribute: in the end,  
only the symbols which have this attribute  become available to the Objective-C runtime.
The Swift header has a counterpart—the bridging  header. The latter is used for interacting with  
Objective-C code in Swift. But unlike the Swift  header, the bridging one requires more manual  
work—just as everything else in Objective-C.  You get an actual file in the project folder,  
and inside the file, you list the components  which should be available in Swift.
I started with importing only the  precompiled header, or PCH. In the  
Objective-C part of Caffeine’s codebase, this file  was responsible for importing the Cocoa framework  
and global constants—that way I didn’t have to  manually import them in each individual file.
Up to that point, everything was going fine. But  as soon as I imported an actual component of the  
app, something nasty appeared—an import loop. You  see, Swift’s module-based system is pretty smart  
about resolving dependencies between components:  all the symbols that sit inside the same module  
can see and interact with each other. The most  common case where this gets handy is when you  
define a delegate protocol. The component itself  keeps a reference to the delegate declaration,  
but delegate methods often use the component’s  type in their signatures. With Swift being smart  
enough to figure out the relationship  between the component and its delegate,  
you don’t need to do anything extra: they  just know about each other’s existence.
But the languages which use headers require  you to think in advance. You cannot import  
the delegate’s header in the component,  and then import the component’s header in  
the delegate, because that would result in  a cycle—sort of a chicken-or-egg problem:  
the compiler just doesn’t know where to  start resolving imports and dependencies.
This problem is usually solved with forward  declarations: you put one in a file,  
and by doing so, you’re just saying,  “I won’t import the actual header,  
but I can guarantee that this component exists.”  If you’ve been making software for a while,  
you know that just trusting the developer is  never a good idea. But on the brighter side,  
you can go piece-by-piece and forward-declare  each component only when it’s needed:  
it’s possible to do so because each component has  a separate header, so you sacrifice only a little.
However, when one of the components comes from  Swift, things become less convenient and safe.  
That’s exactly because you have just one Swift  header for the entire module. You lose that  
sort of granularity. At that point, the number of  forward declarations in Caffeine’s codebase grew  
dramatically, despite my attempts to start the  refactoring with the most isolated components. So  
even though Swift is advertised as a more safe  and reliable programming language—and it is,  
undoubtedly—using it in the mixed  environment takes some compromise. I’d  
say mixing Swift and Objective-C within a single  module puts it in a pretty unstable state:  
ideally, you should separate the  languages at module boundaries.
With some degree of pain, I did finish translating  Objective-C into Swift. I’m not showing you a lot  
of code here because there wasn’t much to look  at: it was literally a line-by-line translation.  
And thankfully, I was able to remove everything  Objective-C-related at the end of the process,  
so the bridging header and the forward  declarations were no longer needed.
And here comes the more interesting part,  where Caffeine gained an actual Swift flavor.
Adding Some Swift Flavor
The thing I was concerned about the most was  time presets. If you used Caffeine—and if not,  
you’ll find the link in the description—you  know that it lets you specify for how long  
the app should be preventing the computer  from going to sleep. Once the timer’s fired,  
the normal behavior is restored. In the original  version I cloned from GitHub, this was achieved  
through a combination of integer literals and  “magic numbers.” For example, positive numbers  
denoted the timeout in minutes, -1 meant that the  app should not disable automatically, and so on.
You probably know that “magic numbers” are a  code smell. They are literally an open gate  
for bugs and confusion. Luckily, Swift provides  a much better tool—enumerations, or enums. Just  
to be clear, enums exist in Objective-C as well,  but in Swift they’re much more powerful. If I’d  
started refactoring the magic numbers before the  code was rewritten in Swift, I would’ve needed  
two entities: one for specifying whether Caffeine  should autostop at all, and another for specifying  
the timeout. Swift let me encapsulate these  features in a single enum with associated values.
Updating the Menu-Bar Icon (Did Apple Break AppKit’s APIs?)
One more thing that’s gotten a major  overhaul was the icon displayed in  
the menu bar. It benefited from Swift as  well, though to a lesser extent. Changes  
in the AppKit framework played a bigger  role in the update, after all. Plus,  
I had to fix a problem that didn’t exist before.  And, frankly, I’m not really happy with the fix.
Here’s a quick overview of how the icon worked  before the change. In older macOS versions,  
icons in the menu bar used to be just regular  views: you could display anything and handle  
user interaction any way you wanted. A few  releases ago, however, Apple began restricting  
the capabilities and deprecating the old APIs.  In El Capitan, the properties and methods used  
for working with custom views got deprecated. You  were given the button property instead and were  
supposed to do only two things: set an image  or title that displays in the menu bar, and  
specify the menu which opens on click. Not some  arbitrary action but a concrete NSMenu instance.
I assume Apple did so for two reasons. On the  one hand, it wanted to make manipulating the  
menu bar easier, and on the other, Apple’s  goal was achieving better consistency across  
all apps and all environments: Light and  Dark Modes, different menu-bar heights,  
you name it. I suppose these new APIs  work pretty well for most of the apps,  
because who wants to mess around with  drawing views in frames, like it’s 2008.
However, Caffeine required a bit more flexibility.  You see, the app appeals to many users because  
of its simplicity: when you want to disable the  computer’s sleep, you don’t have to open a menu  
and select something from the list—instead you  just click the icon; but at the same time, more  
advanced options are just one click away—except  now you click with the other mouse button.
AppKit’s out-of-the-box behavior didn’t support  that, so I had to find a workaround. Initially I  
wanted to continue using the deprecated view  property and only convert it to Auto Layout.  
But macOS Ventura didn’t want to give up that  easily. Eventually, I gave up and switched to  
the new button property, so a separate component  for the menu-bar icon was no longer needed.
However, dropping the one-click activation was  absolutely not an option because as a user,  
I would hate this sudden  complication. As a result,  
I came up with a somewhat dubious solution:  tracking button events target-action style  
and handling them manually: you know,  when one of the mouse buttons is pressed,  
Caffeine activates immediately, and when  the other is unpressed, the menu opens.
And yeah, I said “unpressed;” it wasn’t a mistake.  Just as the solution was around the corner,  
I suddenly found another quirk in the menu-bar  logic. Apparently, if the menu opened as the  
button was pressed down, it didn’t unpress  automatically. I researched other icons but  
didn’t get any conclusive findings: some of them  showed a menu with either button pressed down,  
others only responded to the left one, and  a couple apps didn’t do anything until the  
button was released. These results had gotten  me stumped, so I decided to just leave it as  
is. Maybe I’ll revisit this thing down  the roadmap. Speaking of the roadmap…
Conclusion + What’s Next
Caffeine, just as all of my side projects, is  first and foremost a playground where I can learn  
and practice with new technologies. Strictly  speaking, the entire Swift transition wasn’t  
really needed—the app worked pretty fine without  it. But I wanted to challenge myself at how much  
smaller and more elegant I can make Caffeine’s  code. I’d say I’m satisfied with the results,  
and that little icon quirk will be the  subject of my next caffeine-inspired research.
But a much bigger research subject will  be SwiftUI. I’m still skeptical about it,  
especially when it comes to Mac apps. I can’t  say for sure that Caffeine will transition  
to this framework—in part because doing so  would require dropping older macOS versions.
But again, Caffeine is a  play-and-learn project to me,  
and that’s what I enjoy about software  development: it lets you learn every day.
Outro
That’s it for today’s video. If you found it  helpful or entertaining, please hit the like  
button and subscribe to The Swift Bird. You also  help me maintain this channel when you sponsor  
it at the links below. I’ll see you later—next  week probably—and until then, have a great time!

----------

-----

--06--

-----
Date: 2023.11.01
Link: [# All You Need to Know About Swift Macros | Swift Macros Deep Dive (Part 1) | @SwiftBird](https://www.youtube.com/watch?v=LrY9f5kOQ_4)

Notes:
### Summary of the Content

This video is the first part of a two-part series focusing on Swift macros. The presenter, Yakov from The Swift Bird channel, dives into the concept, implementation, and potential benefits of using macros in Swift programming. The goal is to provide a comprehensive understanding of Swift macros, starting from their inception and rationale to a detailed examination of their operation and applications. The second part, promised to follow shortly, will include hands-on examples of writing, debugging, and testing macros.

### Advantages

- **Swift Evolution**: Macros represent a significant advancement in Swift, allowing for more compile-time checks and reducing runtime errors.
- **Reduced Boilerplate**: Macros can significantly reduce repetitive code, making development faster and more enjoyable.
- **Increased Safety**: By shifting more checks to compile-time, macros contribute to writing safer and more reliable code.

### Drawbacks

- **Complexity and Risks**: Integrating macros adds complexity to the development process and comes with its own set of risks, particularly if the macro expansion introduces errors or unexpected behavior.
- **Limited Access**: Macros operate in a sandboxed environment without access to the surrounding code, which may limit their applicability in certain scenarios.

### Tips and Advice

- **Understand the Basics**: Before diving into macro writing, have a solid grasp of Swift's compilation process and the role of macros within it.
- **Debugging Macros**: Leverage Swift's ability to detail the macro transformation process for effective debugging.
- **Stay Informed**: Keep an eye on the ongoing development of Swift macros, as their capabilities and limitations are subject to change.

### Main Challenges

- Learning Curve: Grasping the concept and syntax of macros, especially for developers new to compile-time code transformation.
- Debugging: Identifying and resolving issues that arise from macro expansions can be challenging without a thorough understanding of their workings.

### The Importance and Usefulness of the Topic

Swift macros are poised to revolutionize Swift development by making code more concise, type-safe, and error-proof. This series aims to equip Swift developers with the knowledge to leverage macros effectively, enhancing both the development process and the quality of the resulting software.

### Accomplishments

- **Comprehensive Overview**: Provides a thorough introduction to Swift macros, including their rationale, types, and operational details.
- **Practical Insights**: Promises hands-on examples in the upcoming part 2, aiming to bridge theory with practical application.

### Interesting Quotes or Insightful Sentences

- "Macros are another step in this direction. By using them, you can implement even more safety checks at build time."
- "Macros are kept separate from everything else. This ensures predictable results—which is a huge plus."

### Lecture Content: Technical Insights

- Detailed exploration of the Swift compilation process and how macros fit into it.
- Discussion of attached and freestanding macros, including their distinct characteristics and use cases.

### Conclusion

The video sets the stage for a deep dive into Swift macros, highlighting their potential to streamline Swift development through compile-time code transformation. With the promise of hands-on demonstrations in the upcoming second part, viewers are encouraged to familiarize themselves with the foundational concepts presented here to fully benefit from the practical applications to be covered.

Transcription: 

Intro
Hey! Welcome to the Swift Bird! I’m Yakov.
Now that Apple has released all  of this year’s major OS updates,  
it’s time to have a deeper look at  what they can offer to us, developers.
Recently, I published a video about the  latest Swift update, version 5.9. One of  
the biggest features this time was macros, and  in my video, I give a brief overview of what  
they are about. I’ll post a link to that video  somewhere here, in case you need a refresher.
It may come in handy, because today, I’m going  on a big journey to learn everything there is  
to know about Swift macros. I’ll have a  look at the vision behind them and some  
implementation details. And of course,  I’ll be writing a few macros of my own.
Well, kinda. I initially filmed this as a single  video, but the result turned out so loaded  
with details, I decided to make it a two-parter  instead. So in this video I’ll be having a look  
at macros in general: how they emerged, how they  work, and how they fit into the big picture. And  
in part 2, which you’ll see in a few days, I’ll  be writing, debugging, and testing my own macros.  
Again, this only came up in post, so the following  narrative doesn’t reflect this change of plan.
If you’re only interested in the tutorial part,  you can skip to that section in the video. But I  
hope you’ll join me on each stop. Knowing how to  use a tool is very helpful for practical tasks,  
but understanding why it was designed this  way makes you a much better engineer. Besides,  
while I was doing the research and  experimenting with my own macros,  
I found several caveats which you’ll  understand better if you don’t skip anything.
If that sounds good, give this video a  thumbs-up, subscribe to The Swift Bird,  
and prepare for the ride. And if you wanna  see more of such content in the future,  
consider supporting this little  channel at the links below.
Ready? Now hold your breath,  because we’re taking a deep dive.
Macros—a Logical Step in the Evolution of Swift
My first stop on this journey is gonna be  discovering the reason why macros were added,  
in the first place. I mean, didn’t  Swift already offer us all the tools  
we need to create great software and,  in the meantime, enjoy the process?
There’s actually a pull request in  the Swift Evolution repo on GitHub.  
The document in this PR answers  many questions about how macros  
came to be. I’ll post a link in this video’s  description, so you can have a look later.
But instead of just going through this document,  
I’d like to draw your attention to one  global trend in the Swift evolution.  
If you look at its history from the very  beginning, and especially if you compare  
Swift to Objective-C, you’ll definitely see  one idea that comes up over and over again.
Take a look at this code. It’s just  one class method calling another one,  
right? Notice anything strange?
Well, this code compiles and  launches normally. But that  
doesn’t mean it works the way I  wanted. It’s quite the opposite,  
actually. The first method has a typo,  so the second one will never be called.
But Objective-C isn’t really concerned.  Because of its dynamic nature,  
it just assumes that some symbol  will match the call at runtime.  
There’s quite a few techniques for  supplying implementations indirectly:  
swizzling is one of them. This behavior  doesn’t make Objective-C a badly designed  
language. But its paradigms sometimes make it  pretty hard to write, maintain, and debug code.
So here is the same code in Swift. As soon as you  try to call a method that doesn’t exist, you get  
a compiler error. You’ll notice something’s wrong  way before you even have a chance to run the app.
Okay, you may say comparing  Swift and Objective-C isn’t fair.
I kinda agree. They were created in very  different eras of technological history.
Then here’s another example.
That is how you decode JSON in Swift 3.
And that’s how you do it in Swift 4.
The Decodable protocol not only  made the code more compact,  
but it also made it impossible to  mess up property names. Once again,  
the responsibility for checking everything  shifted from the runtime to the compiler.
KeyPaths are another example. But I  won’t go into detail. You get the idea.
Swift is becoming more static-oriented.  In other words, more aspects are checked  
while you’re writing the code, and  fewer—when the code is running.
The benefits are clear. The  feedback loop becomes shorter;  
you spend less time debugging, and can more  often write the correct code on the first try.
Macros are another step in  this direction. By using them,  
you can implement even more safety checks  at build time. Besides, macros can reduce  
the amount of boilerplate—the code for common  tasks, which you write over and over again.
Hopefully, by the end of this video,  
you’ll see how macros can make your  work faster and more enjoyable.
Macros Behind the Scenes (+ Compilation-Process Overview)
Now, let’s talk about how  macros work behind the scenes,  
and what they can and cannot do with your code.
At this point, it may be helpful to  understand what happens with your code  
after you click the Build button. I’m not  going too deep into compiler design today,  
but I’ll give you a simplified explanation  tailored to this video’s topic. By the way,  
let me know in the comments if you want an  in-depth video about the Swift compiler.
So, there are three steps we’ll have a  look at today. There’s more in total,  
but the others aren’t really important for macros.
The first one is parsing. Even though Swift code  is not an article or poem, it’s still just plain  
text. It doesn’t have a defined structure. While  it stays like that, the computer cannot do much  
with it. To fix this, the code is tokenized and  transformed into an abstract syntax tree, or AST.
The tokenizer goes through your code while  paying attention to keywords, such as func,  
if, or return. These words declare operations  which help construct the tree and define the  
relationships between its nodes. Here’s  what an AST may look like in the end.
Once the tree is constructed, the compiler  can understand and reason about it. If your  
code doesn’t contain lexical errors, such as  typos, missing returns, or unknown symbols,  
it can be compiled into machine code, a bunch of  ones and zeroes which the processor can execute.
It’s not really machine code at this point.  Because the Swift compiler is based on LLVM,  
it uses the intermediate representation—sort  
of a universal language. The IR acts as a  bridge between the language of your choice,  
be it Swift, Rust, C, or something else,  and the processor architecture: ARM, x86,  
PowerPC, and many more. This is somewhat  similar to the Java Virtual Machine,  
but in contrast it allows the program to run at  the native speed, without any runtime translation.
I won’t go any deeper, but I decided  to highlight this mechanism because I  
believe it’s such a cool feature. I’ll  leave a few links in the description,  
and I encourage you to have a  look at them when you have time.
Once the compiler’s done its job, the linker  comes into play. It looks for any outstanding  
references to external libraries, and makes  sure those calls are handled correctly.
How (and When) Macros Work
There’s a few stages after that, but  we’re interested in the three steps  
I described. To be precise, in the gap  between parsing and compilation. It’s at  
this point that macros are enacted. And, after  compilation, it’s as if they don’t even exist,  
so remaining build phases occur just as always.
Macros are basically separate programs.  They’re built independently of your app’s  
code and run before the main compilation stage.
Once the app code is transformed into an  abstract syntax tree—but before it’s turned  
into machine code—Swift macros get their chance  to shine. They receive the part of the syntax  
tree belonging to the macro, and they transform  it into a new structure. Besides the syntax tree,  
the macro implementation also receives  any input you provided explicitly.
Macros can add new code which is then fed to  the Swift compiler along with your original  
code. However, macros cannot modify or  delete any existing code of your app.
Moreover, they don’t even have access  to it. That’s because macros run in a  
sandboxed environment with no access to your  source file, any other files on the disk,  
or the internet. Just like I said, macros are  kept separate from everything else. This ensures  
predictable results—which is a huge plus. But  it also means that the macro cannot see any  
code which comes before and after the call. So  the macro’s logic cannot take it into account.
The macro code, as well as its input and  output, are checked just like any Swift  
sources. If something’s wrong, the macro build  fails, which in turn triggers your entire build  
to fail. So by integrating macros, you assume  additional responsibilities and risks. However,  
you can ask Swift to show the transformation  process in detail. Thanks to that, macros are  
not some black box to you. I’ll get back  to macro debugging later in this video.
Four Steps of Macro Expansion
Let’s now have a closer look at how macros work.  
This process has four steps, and  they are pretty straightforward.
First, the compiler reads your app code  and creates an in-memory representation  
of the syntax. It’s the very same  parsing step we discussed earlier.
After that, the part of your code’s  AST relevant to the macro call is  
sent to the implementation. The  implementation processes this AST  
and returns the updated structure.  This process is called expansion.
Next, the code returned from the macro  is put back where the macro was called.  
The compiler basically replaces the  macro call with its expanded form.
Finally, the compiler takes the updated code  and continues with the normal compilation.
At this point, you can see how  Swift compilation works in general,  
and how it integrates macros into  the process. Before I start writing  
Attached and Freestanding Macros
and calling macros, there’s just a  few more things I want to highlight.
As you probably know, Swift  offers two kinds of macros:  
attached and freestanding. They’re  similar in how they work at a high level,  
but they differ in where you can use them and  what you can actually achieve by doing so.
Attached macros modify the declarations  they’re used with, such as classes, properties,  
or methods. Without a declaration, attached  macros don’t make much sense and cannot be used.
They can add new capabilities  to the declaration. For example,  
they can define a new method or  declare conformance to a protocol.
Freestanding macros, in contrast, can be used  all by themselves, without being attached to  
some symbol. But there’s more than one flavor  of freestanding macros—there’s actually two.
Declaration macros introduce new symbols,  such as classes. And expression macros produce  
values or perform actions. An example  of an action is compiler diagnostics,  
such as warnings or errors—expression  macros can trigger them based on some  
logic. The difference between declaration  and expression macros is pretty significant,  
and it determines how you  declare and implement the macros.
To Be Continued…
Which finally brings us to the part where I  actually write, use, and debug some macros.
And… you’ll see all of that in part 2 of  this video. It should be out in a few days,  
but my main goal here is to make it  as clear and detailed as possible,  
so I’m not rushing it, I’ll be honest. In the  meantime, let me know if you have any questions  
so I can answer them in the second part. Don’t  forget to subscribe, and stay tuned for more.

----------

-----
--05--

-----
Date: 2024.02.12
Link: [# SwiftUI Navigation Made Easy: Harnessing the Magic of Enums](https://www.youtube.com/watch?v=do4uZBXP6bc)

Notes:
### Summary of the Content

The tutorial introduces an efficient and elegant way of handling navigation in SwiftUI, focusing on decoupling navigation from views using enums and navigation link values. It starts with a basic Xcode project setup and demonstrates how to create enums for navigation stack destinations. The tutorial also introduces a method for using these enums with navigation links in SwiftUI views, including the application of dependency injection for navigation destinations. Furthermore, the video mentions mentoring services for iOS development and hints at future topics like integrating sheets into SwiftUI navigation.

### Advantages

- **Decouples Navigation from Views:** Enhances code modularity and readability.
- **Uses Enums for Navigation Destinations:** Provides a clear and organized way to manage navigation paths.
- **Supports Dependency Injection:** Facilitates passing data between views seamlessly.

### Drawbacks

- **Complexity for Beginners:** The concepts and implementation might be challenging for SwiftUI beginners.
- **Specific to SwiftUI Navigation:** The methods discussed are tailored to SwiftUI, limiting applicability to other frameworks or UI toolkits.

### Tips and Advice

- **Subscribe and Like the Video:** To support the series and receive updates on future tutorials.
- **Consider One-on-One Mentoring:** For personalized guidance and advanced learning in iOS development.

### Lecture Content

- Efficient navigation in SwiftUI using enums and navigation link values.
- Decoupling navigation logic from views.
- Implementing navigation destinations with dependency injection.

### Main Challenges

- Understanding and applying the concept of decoupling navigation from views.
- Implementing enum-based navigation stack destinations effectively.

### Importance and Usefulness of the Topic

Navigating efficiently in SwiftUI is crucial for developing intuitive and maintainable iOS applications. The techniques discussed improve code organization, facilitate data passing between views, and enhance the overall development process.

### Accomplishments

- Demonstrated a method to simplify navigation in SwiftUI.
- Introduced a practical application of enums and navigation link values in navigation.
- Provided a foundation for integrating more complex navigation patterns, like sheets.

### Interesting Quotes or Insightful Sentences

- "Navigation in SwiftUI is confusing, to say the least. Let's fix it."
- "Decoupling all of that from the views is the easiest way of doing that through creating some sort of a coordinator router / enum."
- "As a passionate iOS developer aiming to advance your skills, partnering with me as a mentor could significantly impact your career trajectory."

### Where to Go Next

- The tutorial promises to cover the integration of sheets into SwiftUI navigation in the next episode, indicating a continuation of advanced navigation techniques in SwiftUI.
- Encourages viewers to subscribe and check out one-on-one mentoring sessions for deeper learning and personalized guidance in iOS development.

Transcription:

INTRODUCTION
Navigation in Swift UI is confusing to say the least. There's Navigation Stack and Sheets and  
Navigation Link and values. It is a mess. So let's fix it. In this tutorial series I'm going to  
cover the most efficient and elegant way of using  Navigation in SwiftUI. From Links to Sheets from  
values to navigation destinations, we are going to  cover it all. So let's jump right in. And if you'd  
STARTER XCODE PROJECT
like to hire me on a one-on-one session go ahead  and check out rebeloper.com/mentoring. Now today  
is the first of a series where we are going  to digest and make navigation super fun and easy  
in SwiftUI. So for that I have just started a  an Xcode project with some files already added  
in here. As you can see we have our content view.  It has a tab view, it has root 1 view root 2 view  
here is the root 1 view and root 2 view with some notes here what I have to  
do today and then we have destination 1 view  and destination 2 view. Today we are going to  
talk about how you can make your navigation  decoupled from the view with the help of enums.  
And we are going to continue on that so make  sure that you SUBSCRIBE to the channel and  
maybe LIKE this video also if you do enjoy it  because there is more to come. This is the first  
in a series. So what do we want to do? Well we are not going to use the default navigation stack  
ENUM NAVIGATION PLAN
either with a puff or without a puff with the  navigation link, we want to decouple  
all of that from the views. And the easiest way  of doing that is through creating some sort of  
a coordinator router / enum because that is  what we are going to use as our building block.  
So let's create a new file and I added the  tab view so you can see that we have to create all  
of these enums for the different navigation stack destinations so called but you will see  
why this project is starting as it is. So let's click on the file art over here let's click on  
NAVIGATION LINK VALUES
next and what we are going to do right over here  is specify some values. Most probably you already 
seen some navigation stack tutorials where we have some values. Well this is where we are going to set them up.
So I'm going to name this appropriately. So it will be root 1. So it's the navigation stack for  
our root 1 tab view and navigation link values.  Navigation link values because all of these  
destinations will be added onto a navigation link, okay. So that's our file and let's import SwiftUI  
we are going to need that and let's create our  enum and that will be our root one navigation  
link values and because we are going to use this  inside the navigation destination this has to  
be hashable. So there you go and then because we  want to set all of our destination views right  
over here inside the enum this will be a view. It's really, really interesting right? So let's have  
two cases in this enum. So case destination 1  and then case destination 2 and for  
destination 2 we are going to use dependency injection. So you rest assure that you know how  
to do that. Currently I'm just going to add add in  the title and that is of type string but of course  
you can add in any hashable right over here, any  hashable model that you might want to push through  
the destination 2, okay. So those are the two  cases now it's time to add our actual views.  
It's as simple as that. As a passionate iOS developer  aiming to advance your skills partnering with  
MENTORING
me as a mentor through rebeloper.com/mentoring  could significantly impact your career trajectory.  
Art with extensive industry experience and a  profound comprehension of iOS development, I offer  
invaluable perspectives hands-on expertise and  effective strategies to navigate the complexities  
of app creation. Prioritizing practical abilities,  current industry insights and streamlined coding  
methodologies. I am dedicated to equipping you  with the knowledge and proficiency essential  
for success in the dynamic realm of iOS  development. Come join me at rebeloper.com/mentoring
and together let's elevate your journey in iOS development. So as you can see we are not conforming
ADD A VIEW INTO AN ENUM
to the view protocol just yet, what we need to do is add our body. And here it is our body and now we need to switch through  
all of our cases. So let just go switch self and  I'm going to use Xcode autocompletion right over here  
so it's helping me out really nicely. We have  destination 1 and 2 and right over here  
we are going to add destination 1 view and then  right over here destination 2 view and I'm moving  
the title forward so into the destination 2 view.  And that's it. It's really as simple as it gets.  
Now let's move forward and let's see how are would  we actually use this root one navigation link  
these values. So let's go to our root 1 view and  here we would just add a navigation link to the  
ADD A NAVIGATION LINK
destination 1 view. So let's just add it. So let's just see navigation link and we are going  
to use the one with the value and label. You could just use the title key and value but yeah whatever  
you see it fit. Make sure that you are using  the one with the value. So the value, here comes  
the really, really fun part it will be root 1,  what's it called, 'roort', let's let's rename  
that because I see that I made a  typo right over here. Refactor, rename. It has to  
be a root instead of 'roort', oh really nice, okay. So let's go back to our root 1 view command that  
back in and then root 1 destination, well well  it's not autocompleting, I'm just going to  
well actually not destination, navigation link. So root 1 navigation link values dot and where do  
I want to navigate over here? Well to destination 1 and then the label, let's have a text right  
over here of destination 1 view. I'm just going to copy and paste it right over there.
So that's one and now I also want to show you  how you can move the actual title, well you know  
dependency injection. We are going to set the  navigation link on the destination 1 view to  
move to the destination 1 view. Right over here  let's just have again the value and label and  
that will be root one navigation link values dot  and now we just choose the destination to view  
and the title let's just say it's Ada and then  the label again a simple text to show where  
we are actually going to go, okay. This is how we move. This is how we navigate. It's really, really  
straightforward. Now we do have to set all of this  up because you know this isn't set up inside a  
SET UP NAVIGATION DESTINATIONS
navigation stack at all, just yet. So let's do that. Let's go to the content view. As you can  
see we have root 1 view and the tab item. What we want to do is add this into a navigation stack
of course as usual and then on the navigation stack  we want to set up our navigation destinations.  
And of course if you are a little bit familiar  with navigation stack you want to add it  
onto the root of the navigation stack. So you just say navigation destination and we are going to use  
the one for and destination. So the for that is  our root 1 navigation link values dot self  
and usually what you would do as the next step  you would just hit Return and that would just  
make this hashable available and  according to the value. You would just navigate  
away somewhere, but remember we don't have to  do that in this case because we have our  
body. So we just add in these two brackets  and then dollar sign zero. So it will use itself.  
So the value is a hashable which is fine. It will use itself. Why I mean by itself? Well because it's  
a view. According to the case it will just use itself. It's really, really straightforward, okay.  
So now let's build and run and let's see if we  made everything set up correctly and if we do we  
TESTING THE IMPLEMENTATION
are going to have also a view extension which  will make this a little bit easier. So here we  
have tab 1, tab view that's nice. Destination 1 view, it's working. Destination 2 view.
It's moved Ada into that view. We can just go back over  there which is really, really nice, okay. So that's  
fine but what if I want to add  this also to the root view controller. So I create  
CREATING A VIEW EXTENSION
another root to navigation link values then put  it in the navigation stacks. Set the navigation  
destination and this is kind of encryptic  you know not many developers know about this.  
So let's just create a view extension on this.  So I'm going to create a new file right over  
here call it view+, so it's  an extension on the view. We do need to import  
SwiftUI right over here and it's an extension on  the view, there we go. And I'm just going to add in  
here our navigation link values. So that function  will be called navigation link values and we are  
going to add in some type of data. You will see  in just a second. I'm going to name this   
of type D and then a data and that will be D dot type, there we go and we are going to  
return some view and here we need to specify  what this 'D' is. So where D is hashable and view.
Basically that's it. Now I can just go to our  
content view and try to replicate all of this stuff. So first of all we need a Navigation Stack  
and inside the Navigation Stack we are going to  use self because this view modifier will be added  
to a certain view. We're going to use self dot and  then navigation destination for, what's the hashable  
well that's the data and the destination well  that will be again $zero. it's really,  
really nice. Now we can go back and on the content view we can just replace all of this mumbo jumbo  
so let me just comment this out, so you will be  able to see it later on. I'm just going to use root 1 view
and then navigation link values, there we go. Navigation link values and just provide that  
protocol. So root navigation link values dot self, much nicer if I do say so myself, okay. This is as easy  
as it gets now we have decoupled navigation but we  did not cover Sheets. So if you want to know  
WHERE TO GO NEXT
how we are going to add sheets to this make sure that  you SUBSCRIBE to the channel hit that notification bell
to get notified and we are going to cover  sheets and some more in the next episode and if  
you'd like to meet me on a one-on-one Zoom call  go ahead and check out rebeloper.com/mentoring.

Ponowne odtwarzanie czatu jest wyłączone podczas tej

----------

-----
--04--

-----
Date: 2024.01.15
Link: [2023 LLVM Dev Mtg - Compact Value Witnesses in Swift](https://www.youtube.com/watch?v=hjgDwdGJIhI)

Notes:
### Notes from Dario Rexen's Talk on Compact Value Witnesses in Swift

#### Advantages:

- **Compact Value Witnesses** reduce overall code size by up to 10% and improve application startup time by 5 to 10%.
- They allow for runtime instantiation, eliminating indirection in generic types.
- Compatible with existing value witnesses, ensuring a smooth transition and interoperability.

#### Drawbacks:

- Interpretation of layout strings at runtime can lead to a performance hit, approximately 15% in tight loops for simple structs.
- Complexity increases with enums and generic types, requiring more elaborate handling and runtime functions.

#### Tips and Advice:

- For high-performance critical sections, profiling might be useful to decide whether to use compact value witnesses.
- Future improvements could include an attribute to exclude specific types from compact value witnesses optimization.

#### Lecture Content:

- The talk introduced **compact value witnesses** as a method to represent object layouts compactly in Swift, explaining their role in managing object lifecycles in Swift's generic type system.
- Dario outlined the design and implementation of compact value witnesses, including encoding object layouts and runtime interpretation.

#### Main Challenges:

- Balancing the reduction in code size and startup time with the potential performance hit from runtime interpretation.
- Handling the complexity of enums and generic types, which require special considerations and runtime handling.

#### The Importance and Usefulness of the Topic:

- Understanding compact value witnesses is crucial for Swift developers focusing on optimizing performance and reducing binary sizes.
- The approach demonstrates Swift's commitment to efficiency and performance, particularly in generic programming.

#### Accomplishments:

- Successfully introduced a new system for managing value witnesses in Swift that conserves space and potentially improves performance in many scenarios.
- Demonstrated a thoughtful approach to backward compatibility and future evolution of the feature.

#### Summary of the Content:

- Dario Rexen's talk focused on the implementation and benefits of compact value witnesses in Swift, a feature designed to make value witnesses more space-efficient and faster to instantiate at runtime. He covered the technical aspects, including encoding, runtime interpretation, compatibility, and performance impact.

#### Interesting Quotes or Insightful Sentences:

- "Instead of executable code, we emit a compact representation of the object layout, which we call a layout string."
- "For our simple struct, we're looking at an approximately 15% performance hit...in real-world experiments, we have found that compact value witnesses reduced the overall code size by up to 10% while improving application startup time by 5 to 10%."

#### Conclusion

Dario Rexen's presentation on compact value witnesses in Swift highlighted a significant advancement in the Swift compiler's efficiency and performance optimization capabilities. By focusing on compactness, runtime instantiation, and compatibility, this feature presents a promising avenue for future improvements in Swift's handling of generic types and value management.


Transcription:

Introduction
hello everyone my name is Dario rexen
and I'm working on the Swift compiler at
Apple I'm here today to talk about
compact value Witnesses in
Swift now before I get into details
about how to make comp value Witnesses
more compact I'd like to talk a bit
about what value Witnesses
are Swift has a very powerful generic
type system there are different ways to
implement generic types in programming
language
some languages do it by creating uh all
objects on the Heap and then raising the
actual type so at runtime there are only
opaque
references so generic function like this
would com compile down to
this
sorry other languages use a technique
called monomorph isation which means
creating specialized versions of all
generic functions
uh with a particular types
applied so if somewhere in a program a
function gets called with an integer the
compiler creates a copy of the function
with the type fixed to
integer since Swift uh supports and
encourages the use of value types type
eraser was not an
option another big focus of Swift is AI
stability while still allowing types to
evolve if
necessary that means that monomorph
ization is also not feasible because it
would require a stable type layout this
is where value Witnesses come into
play there are a handful of value
witnesses that the compiler generates
for each type those functions are
responsible for copying moving and
destroying objects witness functions are
stored in a value witness table together
with other information about the types
like its size stride and
Alignment as in this case a generic
function does not receive ownership of
of its arguments it does not have to
call any witnesses to manage its
lifetime unless it pass passes that
object to a function that takes
ownership of it in this case the object
needs to be copied
first the compiler will generate the
necessary code for us I'm showing the
code here in C++ instead of ir for
readability the compiler added in an
additional parameter to the function
that contains the metadata of T through
this meta metadata object we gain access
to its value witness
table we ask the witness table for the
size of the object create a stack
allocation of the given size and copy
the object into the newly allocated
memory by calling the initialized with
copy witness function before we pass it
on to the next
function to take ownership of an object
we Mark the parameter as consuming if a
function owns an object unless it
transfers the ownership again it has to
eventually destroy
it again the compiler generates the
necessary code at the end of its
lifetime we clean it up by calling its
destroy witness
function so we know how value Witnesses
get used now but what do they look
like take this Str struct as an example
it has two stored properties an integer
and a reference to an instance of a
swift
class the destroy value witness for this
type looks as
follows since integer is a trivial type
it does not have to be destroyed so the
only thing this witness function needs
to do is to increment decrement the
reference count on the reference stored
in
y the initialize with copy witness does
a bit more it copies both properties
from The Source into the destination and
then increments the reference count of
y a sign with copy is basically a
combination of the destroy and
initialize with copy an assignment
implies that the destination has
previously been initialized so we need
to destroy the value it contains
first just like in the destroy witness
function we do that by decrementing the
reference count of Y then both
properties are copied into the
destination and the reference count of
the new y gets
incremented for generic types the
compiler has no way of knowing the full
layout at uh of the object when
generating the
just like in the generic function
example it has to call through the value
Witnesses of the applied types at
runtime so in the case of a sign with
copy since X is still known to be an
integer it can be copied the same way as
before but for why we have to call T A
sign with copy witness the metadata of
the type parameters of a generic type
can be retrieved from its
Impact on code size
metadata now that we have a bit of an
idea what value Witnesses are let's look
at their impact on code
size bringing back a non- generic struct
this is the generated arm 64 assembly
code for the witness
functions they take up 208 bytes in the
binary and this is a very simple
type let's add another type that
contains an optional value of the first
one and another reference to a class
instance the value witness for the new
type are 328 bytes at size and that is
in addition to the 28 bytes of the first
type so in total we're now at 536
bytes and these Witnesses get generated
for every non-trivial
type and this is the reason we started
looking into making value Witnesses more
compact our requirements for compact
value Witnesses were they obviously had
to be more
compact we wanted them to be run runtime
instantiable to eliminate the Direction
in generic
types they had to be
fast and they had to be compatible with
the existing value
Witnesses instead of executable code we
emit a compact representation of the
object layout which we call a layout
string that will be interpreted by a set
of runtime
functions a layout string starts with a
header consisting of flags and the size
of the operations in bites followed by
the
operations layout strings pack to make
them smaller but also easier to parse
and
insentience in Swift There Are For
example references to Native objects
which can be strong unknowned or weak on
Darwin we also have Objective C
references which can be references to
regular Objective C objects blocks or
objective c objects that are bridged
into Swift
types and we have unknown references
which can be either native Swift or
objective c references at runtime
looking back at the example type from
earlier the only information required to
implement the six value witness
functions we're looking at is the type
of the reference and the offset to the
reference relative to the previous
reference or the beginning of the object
for the first
reference in this case we have a strong
native reference represented by the op
code
0x02 at a one-word offset from the start
of the object we're currently encoding
this in a single 4 bit value where the
most significant bite is used to the for
the reference kind and the rest for the
offset there's still potential for
improvement here instead of using a
64-bit value we could encode the offset
as a variable sized integer by storing
the offset in a single bite instead and
using one bit as a marker for additional
data in the following bite so for this
particular case we would reduce the size
of the offset to a single bite and we
expect that for most offsets it will fit
into one or at most two
bytes in addition to the reference and
its offset we also need to store the
amount of bytes for any remaining data
after the last reference this is encoded
as the op code
0x00 which also acts as a Terminator for
the layout string followed by the number
of remaining bytes so in this case it
would just be zero but if we had any
additional plane values after the
reference it would be the combined size
of those
values
and then there's the head I mentioned
enums
before so using this compact
representation instead of 208 bytes for
the witness functions we're looking at
only 32 bytes now with the potential to
reduce it even further to just 20
bytes enums are a little more
complicated in structs we have a number
of different kinds of
enums they're enams with no cases at all
enams with only non- payload cases
basically your C style
enums enom with only a single case and
that case has a
payload enums with a single payload and
one to many non- payload cases and enums
with M multiple payloads and zero to
many non- payload
cases empty and no payload enums are
always trivial so we don't generate
layout strings for them the same is true
for any enums that don't contain any
references in their
payload the memory layer of a single
enom is identical to that of its payload
so the layout string will be the same as
well there's one more special case enums
with a single payload case that contain
a single reference as a payload and have
a single non- payload case for example
an optional in an optional of a
reference type is layout identical to
and the only way to express nullable
references in Swift so we treat them as
such which leads us with single and
multi payload enums that contain
references in their
payload for enums we're also looking at
two additional value witness functions
get enom Tech which retrieves the tech
associated with the enum case and
destructive inject enum Tech which
stores the
tech the reason we need these Witnesses
in
Swift uh is that Swift whenever possible
utilizes uninhabited values and unused
bits to store the tag in the payload of
an enum to avoid allocating additional
memory for example on 64-bit do
platforms the first three two bits of
the address space are unused so empty
cases in single payload enums are
represented using those uninhabited
values while any valid value in this
position means we have a
payload if more space than the number of
available uninhabited values is is
required to represent all TXS of an enum
extra memory will be allocated after the
payload because of the added complexity
even this fairly simple looking enum
single payload
comes in at a whopping 480 bytes for the
eight value witness functions we're
looking
at to handle a simple single payload
enum in a layout string we need to know
at which offset the member storing the
extra inhabitants is and how many bites
are used we also need to know if there
are any extra Tech
bites we use at most eight bytes for the
extra inhabitants and at most four bytes
for the extra Tech Bytes so we can
encode those two values in the most
significant bite and use the rest for
the
offset we also need to know the size of
the payload in this case there there
extra tag bites to read which are
appended after the
payload because the extra inhabitants
don't always start at zero we also store
the the value of the first non- payload
case and the number of non-p payload
cases so we can identify the particular
case we're looking
at we also store the number of bytes
used for the payload operations and the
skip value these are required to skip
forward in case of the non- payload
case and at the end we store the
operations for the
runtime
payload as you can see layout strings
for enums are a bit bigger but we're
still reducing the size from 480 to just
88
bytes now we know what comp compact
value Witnesses look like uh but how do
they get interpreted at
runtime as I mentioned earlier we have a
of runtime functions corresponding to
the generated value witness functions
that interpret the layout strings
conceptually uh conceptually they all
work the same way we start by reading an
OP code at its in its
offset a non-zero offset means that uh
means there is Trivial data between the
previous and the current reference so we
have to copy that
data next or if there was no offset the
offset was Zero we interpret the op code
for each type of witness there is a
separate dispatch table that contains
pointers to the respective functions for
each op code for example if we're
executing the destroy witness the entry
for a native strong Swift reference
would point to a function that called
Swift release at the current
offset if the op code is zero we are
done otherwise we continue with the next
one most of the op code functions are
very simple for references it's just
copying and incrementing or decrementing
reference counts enums are more compx at
let's look at the single payload enum
case first reread the enum layout
information if it has extra tech tech
btes we read them and check if they are
non
zero if they are this is a non-p payload
case so we skip the payload and they're
done if they are zero we check if there
are extra
inhabitants if there are no extra
inhabitants this is the payload case so
we interpret the layout string for the
pay payload and are
done if they're extra inhabitants reread
them and check if they have a
payload if we do we handle it otherwise
we
skip if we don't have extra TCH bites
and there are no extra inhabitants this
layout string is
invalid if there are extra inhabitants
we handle them as
instantiation
before as I said earlier one of the
goals of compact value Witnesses was to
remove the indirection of recursively
calling through the witness functions of
generic properties this is done by
instantiating compact value Witnesses
for generic types at runtime we already
instantiate the metadata of generic
types when they are first requested in
runtime so we we utilizing this mechan
the same mechanism for compact value
witnesses as
well to instantiate a layout string we
iterate over all properties of an object
and get that type
metadata if the type is Trivial we don't
have to handle it directly so we add it
size to the current offset into the
object and move on to the next
property if it is a reference we add the
op code for the respective reference
kind to the layout string and continue
with the next
property if the type has a layout string
we copy it into the current layout
string which results in a flattening of
the combined layout strings thus
eliminating the previously required
indirection we also have to be able to
work with types that are not compiled
with layout strings enabled so if none
of the other conditions Supply we fall
back to calling through the witness
table for that we emit a special op code
together with a pointer to the metad
type metadata of the property the
runtime function will then read the
metadata pointer and call the
appropriate witness
function there are a few more special
cases that are left out to keep it
simple for example there are some
situations where we store relative
pointers in the layout string and they
have to be resolved at insentient
compatibility
time another important factor is
compatibility and by that I mean both
compatibility with the existing value
witness infrastructure since that is
part of the AI but also ensuring that we
can still evolve this feature and adjust
the format of the layout strings if
necessary for compatibility with regular
value Witnesses we're using the same
value witness tables for types that are
not using compact value Witnesses the
entries in the witness table point to
the generated witness functions and for
types with compact value Witnesses they
point to the shared runtime functions
but we need to access the layout string
from within the runtime
function we're already passing the type
metadata into the witness functions so
it's seem reasonable to store it there
the metadata has a header that contains
a pointer to the value witness
table the metadata pointers that we
access at runtime point to the be
beginning of the actual metadata so the
header sits in front of the actual
object so without breaking any existing
assumptions we can add the pointer of
the layout string in front of the
witness table pointer because type
metadata that was generated with older
compilers do not have this extra pointer
we also had to add a flag that will only
be set when a type has a layout string
the flag is guaranteed to not be set for
all existing type
metadata for statically generated type
layout strings the solution is to keep
the existing runtime functions and add
new ones for any incompatible changes so
the witness table generated for an older
compiler may look like this one
generated by a newer comp uh compiler
like this
but they can coexist in the same
application we also need to be able to
instantiate layout strings from
different versions looking back at the
instantiation diagram we have two
options we could check if the versions
are compatible and call through the
witness table if an incompatible version
is
encountered like we do for the types
without layout strings that is not ideal
because it adds indirection but it would
be a simple working
solution another option would be to
translate the layout string to the newer
version which would add some overhead to
the instantiation but benefit runtime
runtime performance
performance lastly I want to talk about
impact on runtime
performance since we are replacing
natively executable code with an
interpretive version some performance
hit is expected for our simple struct
for example from earlier we're looking
at an approximately 15% performance hit
and that is when executing the Witnesses
in a tight Loop since we're
instantiating layout strings at runtime
for generic types performance should be
identical to non-generic types of the
same shape for this particular case
we're seeing a runtime performance
Improvement by about 10% compared to
regular value
Witnesses in real world experiments we
have found that compact value Witnesses
reduced the overall code size by up to
10% while improving application startup
Time by 5 to
10% with no perceivable impact on
performance
QA
ments before I end my talk I would like
to especially thank Gwen M trer who
created the initial draft for this
feature as well as my colleagues for
providing their help and
feedback and uh I don't have a timer so
I don't know if we have time for
question we do okay good any
[Applause]
questions
do you imagine that any sort of
profiling be useful
to not enforce the Val witness on like
very
MH um I'm just going to repeat the
question uh for the recording so the
question was uh if it would be useful to
use um profiling to determine very hot
um types so so types where the value
Witnesses are called very often um and
to avoid creating uh compact value
Witnesses for these cases yeah for like
select very specific very high yeah I
mean I I think it always depends on on
the use case right um I mean you can't
really say upfront what performance will
look like so um would always be best to
measure performance and um you can
certainly uh compile specific types
without this feature enabled
um it would maybe be interesting to add
some kind of um attribute or whatever to
say hey please don't do this for for
this type uh we don't have that today
but it would certainly Poss be possible
yeah all right if there are no more
questions let's give Dario a big round
of applause

----------

-----

--03--

-----
Date: 2022.04.05
Link: [# iOS Interview Questions and Answers with Sample Code](https://www.youtube.com/watch?v=gmyEHW7zDYc)

Notes:
### Notes from the Video Transcription

#### Advantages:

- Understanding iOS developer interview questions can significantly boost preparation and confidence.
- Deep diving into reasoning behind answers enriches knowledge beyond just solving problems.
- Mock interviews help simulate the real interview experience, making it less daunting.
- Learning about the lifecycle of view controllers and differences between structs and classes in Swift offers foundational iOS development knowledge.

#### Drawbacks:

- The video does not cover SwiftUI or Combine, which are relevant and modern topics in iOS development.
- Some concepts, like the difference between `weak` and `unowned` or `@escaping` closures, can be complex for beginners without additional context or examples.

#### Tips and Advice:

- For interview preparation, focus on fundamental concepts since they are commonly asked.
- Use sample apps and code to understand complex concepts like the view controller lifecycle.
- Consider breaking down complex code into smaller parts or using code folding in Xcode for better understanding.
- Always refer to official documentation for the most accurate and up-to-date information.

#### Lecture Content:

- The video covers top iOS developer interview questions, including MVC architecture, protocol-oriented programming, `defer` statement, Grand Central Dispatch, and the difference between `frame` and `bounds`.

#### Main Challenges:

- Understanding and remembering the nuances of iOS development concepts can be challenging.
- Writing clean and efficient code under interview pressure.

#### The Importance and Usefulness of the Topic:

- Mastery of these topics is crucial for passing iOS developer interviews and for practical iOS application development.

#### Accomplishments:

- Comprehensive overview and solutions to common iOS developer interview questions.
- Demonstrated how to apply theoretical knowledge through practical examples and code.

#### Summary of the Content:

- The video provides an in-depth look at common iOS interview questions, offering solutions and explaining the rationale behind them. Topics covered include the view controller lifecycle, the difference between structs and classes, MVC architecture, protocol-oriented programming, and the use of `weak`, `unowned`, and `lazy` keywords, among others.

#### Interesting Quotes or Insightful Sentences:

- "Understanding iOS developer interview questions can significantly boost preparation and confidence."
- "For interview preparation, focus on fundamental concepts since they are commonly asked."
- "The best way to learn about the view controller lifecycle is basically to open the project and go through each of those steps."
- "Classes are reference types, and structs are value types, but don't make assumptions about what's going on under the hood."

### Conclusion

The video serves as a comprehensive guide for iOS developer interview preparation, highlighting key concepts, common pitfalls, and effective strategies for understanding and applying iOS development principles.

### Anki Flashcards for iOS Developer Interview Preparation

#### Card 1

- **Q:** What is the view controller lifecycle?
- **A:** It's a series of events that occur from the creation to the destruction of a view controller, including `viewDidLoad`, `viewWillAppear`, `viewDidAppear`, `viewWillDisappear`, `viewDidDisappear`, and `deinit`.

#### Card 2

- **Q:** Difference between structs and classes in Swift?
- **A:** Structs are value types, and classes are reference types. Structs are copied on assignment, while classes are passed by reference.

#### Card 3

- **Q:** What are SwiftUI and Combine?
- **A:** SwiftUI is a modern way to declare user interfaces for any Apple device in Swift. Combine is a framework that provides a declarative Swift API for processing values over time.

#### Card 4

- **Q:** Why are fundamental iOS interview questions important?
- **A:** They cover basic concepts and patterns essential for iOS development that companies commonly ask during interviews.

#### Card 5

- **Q:** What does the `defer` statement do?
- **A:** Executes a set of statements just before the current scope exits.

#### Card 6

- **Q:** What is Grand Central Dispatch (GCD)?
- **A:** It's a low-level API for managing concurrent operations in iOS and macOS applications.

#### Card 7

- **Q:** Difference between `frame` and `bounds` in UIView?
- **A:** `Frame` refers to a view's position and size in its superview's coordinate system, while `bounds` refers to the view's own coordinate system used by its content.

#### Card 8

- **Q:** What is Protocol Oriented Programming?
- **A:** A programming paradigm in Swift that emphasizes the use of protocols and protocol extensions to achieve polymorphism and reusability.

#### Card 9

- **Q:** When to use `weak` and `unowned` references?
- **A:** Use `weak` to avoid strong reference cycles when the referenced object might become `nil`. Use `unowned` when the referenced object will not become `nil` during its lifetime.

#### Card 10

- **Q:** What is the MVC architecture?
- **A:** Model-View-Controller (MVC) is a software design pattern that separates objects into three distinct types: models for data, views for the interface, and controllers for logic.

#### Card 11

- **Q:** What does the `lazy` keyword do?
- **A:** It delays the object's initialization until it is actually used, which can improve performance and resource utilization.

#### Card 12

- **Q:** Difference between `@escaping` and `non-escaping` closures?
- **A:** An `@escaping` closure can be called after the function it’s passed to returns, allowing it to escape the current scope. A `non-escaping` closure can only be called within the function it’s passed to.

#### Card 13

- **Q:** What is an `@autoclosure`?
- **A:** It's an attribute that automatically creates a closure around an expression when passing it as an argument to a function, simplifying syntax for functions that take closures as arguments.

#### Card 14

- **Q:** How to handle memory leaks in iOS?
- **A:** Use weak or unowned references to break strong reference cycles, and utilize Instruments to detect and analyze memory leaks in applications.

#### Card 15

- **Q:** What is the importance of understanding memory management in iOS development?
- **A:** Proper memory management prevents memory leaks and ensures that your application uses resources efficiently, leading to better performance and stability.

These flashcards cover a range of fundamental topics and best practices for iOS development, aiming to aid in interview preparation and reinforce key concepts.

Transcription:
Overview
interviews can be daunting but it don't have to be if you're well prepared in this video i'm gonna go through the top
10 ios developer interview questions and not only go through them and solve but actually uh we'll dive deep into the
reasoning behind the answers and probably look into some documentation as well let's look at some sample apps and
sample code and to assist me to make it look like a real mock interview my
Daniel, the interviewer
friend daniel will be helping he's on the other side of the call and dan say hi
hey what's up everyone so yeah the first question will be to you actually and uh
could you tell me more about yourself
yeah so hey everyone my name is daniel and i'm a web product developer working
mostly with react and i did ios like five years ago
for a little bit so i am a bit familiar with the questions so i can assist richard with the
interview so you'll be my intro now uh yeah basically so you've seen the uh question
list what do you think of them so far um yeah it's like nothing has changed
much i'm just wondering why you didn't add any swift ui or combined questions
yeah i think um it's a good idea i think swift ui and combined and such are new topics and uh they really worth a
separate video on that on the topic so probably will make a separate one and not to miss it just
make sure to subscribe to my channel and uh if you want to combine and swipe ui
a separate video just let me know in the comments below i'll make one just on that topic
uh yeah but why i started with those questions
Why these questions?
basically they are very fundamental and all the companies right now are asking some sort of them
uh when interviewing for an ios developer role and this is really interesting because uh if
you watch this video till the end there are about 10 questions uh it's
very likely that you'll get one or two of them in your next interview so
i think that's a very good uh training and exercise for for preparation for interview
all right yeah so let's get started yeah let's go ready
View Controller Life Cycle
yeah so the first question is can you explain me what is the view control life cycle and
what are the most important events uh yeah i think this is basically the classic ios interview question is being
asked for 10 years at least so uh to actually see what is the view
controller lifecycle is i just created this um
basic app which is printing out uh each method so that we can see what's
going on in the view controller while we show it or hide it so i used the storyboard
and created a very very simple app which will show just the uh model view
controller basically presenting a sheet from the bottom and we'll see what events we'll be printing
out let's run this app and see for ourselves and uh
what are lifecycle events and what are uh what are
uh the most important ones so open lifecycle press button and we start with a view controller
so as you can see the first one to be called is initial coder which is basically an initializer and
in that case it might be called a different one in some cases because for example if you're uh initializing
your uh view controller programmatically an input frame will be called or this one
init with nib name or nail so one of those basically the initializers are always going the first
the next one is load view which is a
method when asking for a view to be loaded and the view that load follows it
immediately basically once the view is loaded you get the view that load event
uh i don't understand why load view if needed is called after that probably some sort of legacy
uh artifact because it does make a lot of sense maybe it's just to ensure that the view is loaded
but and at this stage it does nothing and then we have the so-called uh
appearance and layout events so you will appear it's called before the view appears on
screen and the view will layout subviews is called uh before the layout pass and
then after the layout has been completed we have the view dead layout subviews
all of those are available to be overwritten and um yeah and once the view is about
to appear once you already appear you have the view that appear and once i drag it down we have them in
the reverse so we have the view will disappear and view the disappear and the d init
is called last uh in case you don't see d in it for some reason in your view control that
means that you have a memory leak and it's still in the memory so you have to work with the memory profiler
and one more important thing is that if we clear the console
that this view will appear and you did appear as well as you did disappear might be called multiple times so if i
try to dismiss the view for example and then i'll decide to pull it back
i have the view will disappear but i never see the view did disappear
because it's still on the screen and we are going back you will appear and view did appear so
apple actually has a very nice a very nice sample
for that has a very nice chart i'll link it i'll link it in the description for sure and
um understanding this chart is really crucial to understanding the view control life cycle
so uh you basically have four states uh appeared and disappeared and
transitioned between them into multiple directions so uh and what's important
you can move to appearing state you and immediately move to disappearing state or vice versa
this is usually emitted by all of the candidates and they just think it's one
time event and this is a big mistake so
these events might be called multiple times in the life cycle of the view controller as we've seen
and of course the one when rotation is happening is that you will
transition to uh size with coordinator and the same as
uh called when uh for example you're in an ipad and trying to resize the
uh resize the view control on a multitasking screen so i think that's it regarding the uh
view control events so hopefully you're satisfied with this question what do you think
yeah i mean i didn't know that there are that many methods around the
like the view control life cycle so it's also new to me
but what do you think what are the most important ones to remember because there are quite many and yeah which ones
yeah to summarize summarize really it's uh it's all about
grouping them into categories the first one is the initializer
that's the main one that's the first one the initializer is the first and then the initializer is the last
then you have the view loading related callbacks load view if needed load you and view
the load those are the next step and they are uh what ones are the most important like
which ones are i think i think i think i think the load view and viewed it load so view that low is probably the most
used one i think if you create a template right now it will be there it will be included there
yeah and what's the difference between load view and view did load
um load so basically load view is uh so they're going in a very specific
order right so you have the load view first and then view that load after that it's pretty clear and load view is the
one to override if you want to use a custom view for example if you want to have view equals ui table view let's see how
it works like i'll i'll make just this change and let's see if uh i will have a
different view there i mean i should uh life cycle
button that looks like like is it a table if you actually know because probably i'm
using the storyboard that's why it won't really uh it won't really plug it in so i don't
know but uh
if i were to use uh if i were to use um where is this dimming you drop shadow i
can't see anyway life cycle you i actually you're a table you see us here
pretty cool oh yes yeah so it's there so yeah loadview is what you use to uh
connect your custom view uh and overwrite the default but if you
don't do anything it basically adds a ui view here like that and you just can't ignore it
you really don't need it and view that load is when the view is loaded and you can do some
customizations for example adding in sub-view or something else too that's why i kind of prefer to group
them by the purpose instead of like selecting the most important ones
and then we have this appearance callbacks you will appear you did appear
uh and view will disappear you did disappear so regarding the presentation appearance disappearance and we can uh
add a third class which is to layout related layout transitioning to sizes
and so forth so yeah initializer d initializer view loading
presentation and [Music] layout and i didn't even go into details
like for example things like um did receive memory warning that's not
the one or will add uh or sorry
add child view controller did add will move to parent view controller so there are a lot of
callbacks to you think about like apart from those but basically view controller is a very important class obviously
there are a lot of uh connection points to work with so
those i've listed are the main and of course this project is available on github so
make sure to play with it and i think the best way to learn about the view control life cycle is basically open the project and
go through each of those steps in the event you understand how how it behaves and
instead of like just reading the documentation
yeah so hopefully we can move to next one yeah i'll do this next one so
i think this is the most common one which one what's the difference between a struct and a class
The difference between a struct and a class
yeah it's a very common one though so um
well let me try to answer it yeah yeah go ahead go ahead
at least i remember something about it so i think the class is referenced
it's reference based and struct is value-based value-based what does it
mean in practice like in practice like when you
create an instance you get like i guess a pointer to it if it's a
class and if you create an instance of a struct then you
get a like the value instead so
yeah but what if you try to modify uh the same class like will it modify at the other
sides which holding that reference or not if it's with class and what do you mean if there's gonna be
another like for example if you pass class to multiple objects and then you modify
something like a value at that class for example let's say point uh of the player
will it be reflected for each objects who own that class or
uh will they act like independently yeah i think it's going to be like a singleton yeah well the e8 will be
reflected for all yeah that's that's that's the means called reference uh beast but yeah a lot of but but a lot of people
are going into details like for example
uh saying that uh extract is always copied when you pass
it or saying that you like something details like uh oh you cannot uh you cannot
extend the struct you can't subclass track but you can subclass a class right
but those are uh the problem with those answers that they are not very uh
they don't always hold true for example you can uh you cannot subclass a final class
right and uh you can uh extend their structure using a protocol
and uh the most important thing which usually all the people are uh not aware of is that
this truck might be passed by reference to and for example all of the
uh collections in the standard library like dictionary arrays and so forth
strings sets they use the optimizations to reduce uh the cost of coping so
if you try to to pass the array it will be actually under the hood passed by reference
and only when you modify it will actually duplicate the whole array which is an interesting
idea to know like for ios developer when profiling for performance problems
and if you look at the ios or actual swift um array code
you'll see that there is like a buffer which is uh used like internal storage
for an array and when you try to copy that a lot of uh functions actually
all the functions are actually passed to um
they are passed to uh to this buffer and uh there are a lot of
optimizations for example like mutations uh for coping and so forth
um simply because uh because it has to be faster
uh for those optimizations and this is doing the job of making run fast and uh
from from the developer's perspective it appears if the array is copied immediately but in fact
it's doing this copying right on the hood so because swift is such an optimized language and a lot of complexity is hidden from the
developer so yeah my answer would be that
classes appear to be passed by reference have the reference semantics and
uh structs are appearing like they are passed by value so basically copied but
they just appear like that those are only semantics do not make assumptions of what's going
on under the hood and i'll link those nice articles from apple which describe
uh difference more like in practice it's important to understand those uh
those uh differences but basically yeah the main one is the value versus uh like
having an independent instance or uh in case of uh struct or having the
same instance shared shared memory in case of a class and yeah of course you can have the identity
um hey richard do you have like an analogy how did you compare the class
and the structure yeah yeah i think yeah i think the class is more like a bank account so whenever you deposit
something to it and withdrawal uh it refers back to the same bank account so
let's say i put a thousand there i have a thousand i withdraw a thousand i have zero right
but uh a struct would be like more like a bank statement uh so
i have the bank statement for from today which shows thousand i can get the same from tomorrow which will be zero
and uh i can copy i can remove it i can pass it to someone else there will
be no uh it will be like a different copy basically so independent of my bank
account independent of everything so i think that would be the best analogy okay
so so so uh that's sort of the benefit why using structs might be a good idea because
uh you can pass them between threads because basically it's copied so you are not afraid of any sort of race
conditions mutations because uh once you pass it to a different thread
it this truck lives on its own and the class will still have that reference and that's sort of the notion why they
wanted to get rid of classes uh as much as possible in move into structs and move the spherical random
programming thing i think that was the idea
cool should we move to the next one yeah let's go so what's the difference between
The difference between "frame" and "bounds" properties of an UIView
frame and bonds property of you uh i think it's important to figure out
what what they are similar i have again a sample app here that will help us to figure out what they are and what they
are not so um first of all uh let's go to check uh the ui view
class we can just take a look at it and we have the frame here
and we have actually both frame and balance this you can see they are both of type c direct which means they're
essentially the same uh type and you can set one for another so
that really makes them similar uh but what's different is their
semantic and the way they apply to the way they used to and this is the most important thing
uh the most important difference and uh in short it boils down to
uh if i launch the app i'll just launch the app so uh the frame
is about the they both if we zoom in here like if we go into the uh c direct they both have
the origin which is the starting point and the size which is basically the size of the rectangle so
uh they uh they uh the difference is that
in case of frame the origin points to the uh position in its super view so if the
view is not added to a super view there is no concept of frame right and the size is well it's clear it's the
size which it occupies in the super view this is one of the important thing we all get back soon
uh and with the rect with a with the bounce it's slightly different concept so uh the origin is relates to the
content that the view is showing so what piece of the content the view is showing
in its frame and the size is basically the size of that viewport let's call it like that
so to sum it up uh the frame is about position of the view
so size and origin in relation to its super view and the bounds
it's the uh what portion of the content the view is showing
and uh i'll have few examples to demonstrate this a bit further so uh first one is the scroll view
the white one is the scroll view and we have two views there which are sort of showing how the view scrolls itself and
i'll try to drag it now a bit so see how the bounds and the frame are
changing so as you can see there is a frame and
bounce and i'll try to drag it to different directions as you can see if you can take close attention uh pay
close attention to the frame uh the frame is actually always the same here
uh it never changes so whenever i drag it no matter it doesn't matter
uh but the bounds of the scroll are actually changing all the time in both directions so
uh the size stays the same 350 and 241 is the same here and here because the scroll size doesn't change
and the content size doesn't change right but the origin is changing
so that's how the scroll view scrolls and decides what piece of content to display
and one more thing of course we have the case when the size of the scroll
bounds also changes and that's when you have uh for example page to zoom gesture
then you will have your size increasing and scroll you will
basically zoom on to something and then there is another demo which i've prepared is more
interesting probably it's rotation so the red rectangle is showing the frame and the purple is showing the
bounds now rotate it a bit as you can see the area which occupy which this purple
rectangle is occupying in its parts superview it has to be rectangular
it's growing once i rotate it but the content stays the same basically right and if we
take a look what's going on under the hood is we'll get the same answer
so the bounds always stay the same it's 100 100 here
but it's the frame that changes and as you can see the numbers are very very
complex here and yeah because we're just rotating
and if we go to the official documentation we see that the if the transform property is not the identity transform
the value of this property is undefined of the frame property so it to be ignored but in this case it
actually makes sense i think because you can see the frame of this view is larger right
so uh it occupies a larger part of the part view so yeah i'll briefly show the
code which i brought here uh it's nothing fancy just a regular
regular view controller and when rotation is being detected i'll just rotate it on the same
level as the uh as the actual
as the actual uh paint gesture rotate gesture
all right that was a pretty deep answer yeah i mean i mean yeah it's not like an
interview question after it's more like a bit more explanation so yeah
uh to sum up the the frame the frame of the view it's what it
occupies in relation to its parent view to its super view no superview no frame
and bounce is how it positions its content in its own let's say canvas so that's to
be the summary so the bonds are always larger than the
frame the bounds are always larger than the frame i actually don't know i mean
could be that the balance will be smaller than the frame
let's see
well maybe actually no there is a thing called clips to bounce you know right
so if you uh you can you can clip to bounce probably some of the
sub views might extend to the bounds right uh and they will still be drawn but if
you set clip to bounce property to true then will limit to this balance so again
the bounds uh the bounds can be uh so the content might extend slightly
further uh than the bounce yeah okay
all right let's go to the next one so what is what is protocol oriented programming
Protocol Oriented Programming
uh yeah so protocol random programming is the new or not so new paradigm which was introduced to swift
and the main idea was to differentiate from object oriented programming and to
uh solve those problems that were introduced with object-oriented programming and i have actually a keynote a
presentation uh about the type system of swift actually i'll link the video as well
and in short if uh the swift has a very strong very strong protocol system so
you can have the classes structs and enamels conform to protocols and the problems can have the inheritance
between them so there's a very very flexible way to define relationship
and if i compare the objective c the object-oriented language with swift the way this relationship
power can be expressed with protocols in objective c you have the uh for example
ns number uh the ns number subclassing uh is a subclass
of ns value and which in turn is objects so for example there is such particular peculiar
peculiar so there are such issues that you could compare the view
controller with uh an s number for example if this number is equal to the view controller
which does make a lot of sense and um uh because they are the
uh the descendants of the same class and in swift they fixed it by using a protocol
basically protocol that can ensure that um
that the compared values are of the same time so the protocol-oriented programming is the idea that you can
detach the relationships of between of the objects from the objects
themselves and if an object satisfies some sort of constraints some sort of rules
uh then you can embed this whole object into a relationship without writing too much
code and like repeating it yourself over and over again for each uh different kind of object
and basically that's a the idea of particle range programming is separating the uh hierarchy of relationship of
inter-relationship and hierarchy of objects of methods uh and that's a pretty powerful construct for example
you have a lot of power in in the thing called retroactive modeling like you have for example the equatable
protocol and the way uh the equal sign is defined the equality operator
and the inequality operator is defined as the uh the opposite of uh
of a quality operator so pretty cool and you can compose the protocol so you can work on a very very high level
without touching the concrete types and develop software in a much much more
modular and flexible way and yeah so let's focus on the types and
relationship between them and if you have a new type created you can quickly embed it into an existing
relationship between them and basically
use all the power that you've already developed uh to have new types supported
immediately and i think the biggest analogy for me is um using some sort of algorithm to capture
the list of uh to capture the photos of the tallest buildings by using the map of the city and the
list of those buildings so you have to have a map and you have to have a list to go
through each of those buildings and take a picture the only thing that you have to care about is that your uh map and your list
are of the same city then you'll get the proper pictures right so the protocol
protocol expresses this whole algorithm without naming the city once you have a
new york for example here you can make the same for barcelona or you can make the same for let's say los angeles
and you can have the same uh set of photos taken simply by having these two
um objects and i guess that's the idea of it
what do you think okay yeah i mean
i see protocols are like kind of like interfaces
so i don't really remember that much of it
but your answer was pretty good yeah yeah i mean the the the most important difference because we have the
interfaces in objective c uh the most the most important difference uh in swift is that you can
actually uh work only with particles you can combine them you can
express more more flexible relationship more concrete
relationship and between objects and that will give you
let's say more compiler support in while you develop so you don't have to type cast as much
uh because protocol already constrains that thing that type to a specific
subtype and you know that it will be of that specific type and so forth so you are getting a lot of
type safety uh and but but at the same time you have a lot of flexibility
which in the object-oriented languages like objective-c was uh
what was implemented with the dynamic dispatch dynamism and so forth that's why you could compare like a ui view
controller with a number or whatever of course it will return a false but
you still can do that and in swift it will just throw an error
all right it will not even compile i mean
all right okay but let's move on so yep
"defer" statement coding question
grand central dispatch yeah so deeper question yeah let's try to open the
playground yeah nice one
yeah i like this question quite a lot so uh i guess the task is to figure out what
will be printed out in all of those questions let's start with the first one right do you want to try
to solve it i mean when i look at that code it's like
who who writes this kind of yeah by the way by the way before me write this girl for sure it's not
written this code half an hour ago but before we start with that i i highly recommend watching
this protocol oriented programming talk by apple uh in 2015. without dc and i'll
link it of course so um it's more entertaining probably than this video but
it definitely takes a longer time to understand so uh yeah let's get back to this
question uh so uh yeah i think the first thing to say
in an interview in my opinion when you see this is that this code should not really be written
and if you have if you see this code the best thing is to go back to the drawing board
figure out what should it do and uh and uh then
uh write it from scratch by understanding the requirements but uh that's the first thing any for example
if you were to be interviewed by me you'd get definitely some bonus points for that
and yeah but what do you think what do you think
the answer is here
um so defer does things
as the last stuff and
um so the print f is going to execute first
this one yeah yeah let's try
and [Music] yeah so
yeah so i think i think the the next one is going to be the
print e because i think the difference goes in the reverse order yeah
this is very important thing to remember they go in the reverse order so uh if this defer is called first it will
be executed last and the first station for those who don't know this it's
basically a a way to work with a legacy api for example if you have some some
resource acquisition happening here and you want to clean it up immediately instead of remembering to clean up and
all those if cases you have in the code you basically write as soon as you lock onto something you write a deferred
statement immediately and you'll sure that the moment the function is closed that resource will be
close to basically yeah so uh
then this one is obviously to be the next one which one is the next after e
yeah so it's going to be the one above it so that where the prince b
is yeah and in my opinion just do this so um whenever whenever we have
something complex just hide it here with the um
with the uh code folding and then you can unfold those ribbons so you
see the f help make xcode help you then you unfold this one which is the next one right
makes it really clear e then we unfold this one right yeah because we go one level up
and uh what is the order here so it's gonna print b the first one b
because it's the yeah the b or running the b here yeah then that's gonna go to
the print d because the first statement is default right we just hide it yeah it's gonna be
excuse or fast then d and then we have c because uh we are
exiting this whole close right yeah and this is the last one
oh yeah let's check this out i think i agree with you
f e b d c a f e b d c a looks like we are correct
cool yeah cool let's let's let's tackle the next one which is a bit more complex
and again the idea is that this code should not go into the real system into the real
application so uh it's better to refactor it than trying to decipher and understand
GCD / DispatchQueue coding question
so what would be your approach so actually how would you reach factor
code like that yeah well well it's a synthetic code so
the like i don't know the purpose i'll go back and look at the look at the
look what this code is doing and then try to restructure it but yeah we can actually this is a good
help um and the preferences you can actually set up the code
uh in a text anything you have the code folded ribbon here which will add you
this ability to fold the code and this is really convenient to solve this
kind of tasks that did actually ask quite a lot in the interview for some reason
uh so yeah just fold the ribbons and you can focus on uh want to be executed first so yeah how
would you tackle this question yeah so dispatch queue let's go
so the first one that's kind of printed is the a a because it's the first in the
uh yeah first line of code then this dispatch queue line gets executed so it like
creates a new queue yep it doesn't create a new queue it just
dispatches to a different queue right oh yeah well yeah yeah
lower level stuff yeah well yeah sure but uh it's it's an async it's an async
cue right so uh oh yeah yeah yeah that's true it's in the sync one
so okay well yes it's it's a sync it's gonna like i guess
go through this function first so it's gonna the whole thing print
so yeah correct we can just hide it because it's the essence writes a separate queue we just hide it
yeah so yeah the i is going to be next correct and what else so we now need to look
here right yeah so then it's gonna check out the
the syncqueue and it's gonna print the b all right pretty clear
i don't think i have any concerns regarding that okay and then there's the syncq so it's
gonna like skip this well put it on another cue yes so we are
hiding this for now yes so it's going to go to the d
d right yeah and then
uh okay so there's a sink not async but yeah
synchronous yeah and so
they are in the same queue right they're the main cue yeah yeah so
so first of all what what is the sync doing to the queue what is the purpose of the sync how it's different from this
like you have two of those uh you have the async here and you have sync what's the difference between this
i think it's gonna block the ui until the print e gets it well it won't block the ui it will it'll block the execution
so basically uh you you go the b then you go to d this is scheduled right this is sync it
just skips it then you have d and then it goes to this line and then it waits basically it schedules this
part to be executed on the main queue again but it will wait until this finishes
the while it waits uh it ha the main queue has uh there is one
more important difference uh there are serial and parallel cues right so we know that main queue is
serial queue so uh it will execute the tasks in the order that we send to it so it will not
start executing this task before it will start uh it will finish this one so the
c will be finished first and then only it will go to e right oh for read yep
because it is serial queue so it will uh take task by task so it will not
uh execute them in parallel so it will not be able to there would be no race condition between
the c and the e this is very important yeah so even though there's the sink
like method or like yeah it is it is s it is s-sync right but you see it's it's
been as sink in relation to this global queue uh but but then it sends it on the main
queue and uh and uh it is scheduled there so uh the task has been put to that
queue right now you go next to the printing d and now the sync is again with relation to
this queue basically waiting synchronously while this whole thing executes on the e
on the main queue and uh you're waiting waiting waiting but it takes the first task which is c it prints c
and then it will print e right because yeah and then it will skip
for them so uh actually i'm interested i'm i'm i'm interested yeah i think it will block
the queue right so the the h is still here so it will not reach it right so this should be yeah
so then again we're having the async thing right yeah so we're just getting so we so
we're skipping this right yeah so h is going to be next h let's see i'm not even sure myself uh
but i would agree with you it's h and now it's time to unwind the async
h i is already here so f how about g
well yeah i guess that's the only thing left i think it won't be uh printed out
for real all right yeah look at look at this look at this so we have the we have the dispatch q uh main async
so basically dispatch tasks and move on this special test can move on so
the age is here so dispatch the test can move on but then inside that task you're again
scheduling a next task to be executed synchronously right just
in front of your current task because this one i still haven't finished remember the main queue is the
synchronous queue it's oh sorry it's a serial queue it takes one task after another so until it's finished executing this
task it can't start doing this one so uh and because it never finishes this
one because it waits for this forever this is called a deadlock so basically the g will never be printed
and uh uh yeah that's my opinion let's take a look
uh this is not an easy task i'll say but let's see what will be in practice
now [Music] so a i b d
c e h c e h f and as you can see the g is not printed right
so just zoom in on this one yeah really interesting so
uh these are actually uh the questions are asked in the interviews like uh some of the variations of them you might get
a different one you can get the guard let question not necessarily defer or not necessarily
dispatch but the idea is the same it's some sort of spaghetti code i wouldn't call it something else
and um and and they're trying to trick you into
uh making a mistake with the understanding of those intricate intricacies let's say like that this is
actually very high level question also very high high complexity questions
so yeah how was that for you yeah it was quite difficult
the last one definitely is a bit more complex than the first one and i think because this test so much
uh you need to learn about the synchronous versus asynchronous scheduling you need to
uh learn about the deadlock and serial and parallel cues so there is a lot of things to to
to dissect in this question in a way even if it's it looks so simple and
and the the diff difficult part is that it's actually quite easy to
mistake the sink from asking it looks almost the same like there is one ladder difference
and you just can like make a mistake by not looking
uh well enough let's see yeah and i think it's quite important to
make the code readable also for others yeah yeah so that you know
like if the guy leaves the company the other one comes in i think i think i think this code is unreadable if we have
to spend like 10 minutes if it's asked in the interview it's definitely unreadable but it's a good thing to it's
a good thing to mention that in my opinion yeah absolutely
but okay let's go to the next one so let's go um
MVC architecture (Model, View, Controller)
could you explain what is mvc architecture and what are their main components
uh yeah so the mvc architecture is actually pretty old and the best way to learn about is to
read about the apple's document and i believe it's actually retired documents so it's not supported anymore
uh so there are plenty of materials if you um
there are plenty more heroes but the gist of it is that you have a separate classes for
uh each of your components let's call it like that you have the model which is defining the
uh data layer and the logic of the app uh you have the view which is uh
responsible for the uh presentation and for the uh
user input controls and the controller is actually linking those together for example user presses a button the
controller gets that signal gets that event and then it does something to the model uh and the model
somehow um doing some job and then it notifies the controller about the changes so
basically that's the idea of structuring the app in a way
okay and in ios of course you have the view
and the controller really really closely tied together so that the rvu controller
uh basically a very very uh let's say uh sandwiched approach and the model is
usually uh might be different because it might be a coordinated model it can be a remote
modal on the server or something else but um yeah this is usually the architecture of
the ui kit ios applications so is the controller only used for dui
or could it be used for like data fetching and stuff like that
um no not really i think if i uh the first which i remember is
actually the fetch results controller no i don't know why i'm looking at the
objective c but i think that there is a swift version of it so um of course so the fetch
results controller is basically uh having a fetch request to core data basically responsible to
preparing the data to be displayed to the table views so you have like a table view controller fetch results controller
and you combine them together and you basically got your data presenting showing up in the table view
and that's more like the idea of this small view controller approach to have the modularity
uh that you have the building blocks and you combine them together and uh you
have the ready making like really working app and
fetch results controller doesn't have any ui classes in its import declarations because it's just a
it's just a modal controller it's good like that and then there's a ui document
which is doing the same job essentially a model layer model controller layer for
reading and writing documents for the both mac and ios so
not necessarily uh ui view controller is the most known one and but uh it's not necessarily that
you have yeah you can have the combining roles like for example
uh both controller and view roles this is a view controller then there is model controller
so definitely you can have a different as you can see there is like a different controller
uh objects and there is not necessarily like a it's not necessarily controls the view
in the model it might be it the controller can connect together different pieces it can connect for
example multiple controllers like a navigation controller for example it doesn't operate on the view level
mainly appraising the controller level all right
so how about like when you have modern apps they combine a lot of different content
on a single screen how would you kind of how would you tackle that are you gonna
have like many view controllers like yeah
yeah i think i'll do that so i'll just uh instead of putting everything into one
view controller uh i will uh split the content i'll split the responsibilities among
multiple view controllers and then i'll use something similar to a child view controller approach so i'll add one
controller in a way like you add a sub view i'll add the same way a controller on top of each other and have them
handle specific responsibilities and one of the examples is like of
course there is a official guide for that uh for making a custom view controller
but uh there already is so many of those controllers like navigation controller is one of the
examples and everyone uses is using it and splits view controller is doing the same job and doing quite a lot of work
uh by adapting the interface to the ipad and iphone and split view on ipads so
without even knowing what's the interface all about it just has two controllers and coordinates between them
so i'll definitely go with this hierarchical controller approach
all right clear let's go to the next one so
"weak" and "unowned" keywords
the weak and unknown keywords so
where are they used and what are they for so uh those keywords are related to the
uh they are related to the memory management so um
if i take a look for example in the ui table view uh
if i just go to the ui table view and uh for example data source and delegate are both declared as weak
which means that it will not hold a reference to the data source basically
it will just use it it will query it but it will not hold the memory so whenever
the table view uh whenever a data source has no references
outside now if it doesn't have any anything else it will be deallocated and it's usually uh made so because the
table uses a view and that's why it has to have let's say usually the controller
provides the data and that's why it has to have the delegate weekly hell otherwise we have this reference cycle
so usually the uh when the week is used is used during the
reference to break the reference cycles and uh unknown is very similar to weak
so in the fact that it doesn't add the uh reference count but um
so it will not hold the object strongly in memory but uh the difference is that it will not be
declared as optional so you you use usually unknown cell unknown
cells when when you 100 sure that it will never be
it will never be nil and you just want to like work around the compiler to make it uh to
make it to make it a non-optional type so that you don't have
to like unwrap it all the time and so forth usually you can use that in closures for
example or yeah if you for example refer to uh if you for example refer in lazy
uh closures and laser variable or uh just an enclosure you have to use either
weak or not so not to create a reference cycle all right
usually it's used with usually it's used with a delegates like usually all of the delegates in apple platforms they are
they are connected as weak so they don't hold the the object they are referring to
strongly so are there any exceptions when delegates not held weakly yeah yeah
there are some exceptions for example um there's an serial session it's a very
interesting case uh the basic networking object on ios or
url sessions i'll just switch to the swift version of it and
session delegate the session delegate which is basically an object that receives the events from
the session uh it's a strong reference so you create a session you set a
delegate but the session will hold its delegate strongly and this is important because it might
have a memory leak uh if you don't remember this specification the task is very
simple i guess the intent was that you just instantiate um this delegate and the session basically
handles it the the only purpose of this delegate is to be held by the session
you don't really need anywhere else that's why it was designed that way probably
because if the table view if you think about table view uh the
table as table view is held by the controller and the controller usually is a delegate but in this case like the
session is the main object and delegate is just a additional behavior that you want to
customize that's why it's okay to hold strongly but this inconsistency is really
actually quite tricky and if you forget about that it's really easy to to
to make some problems in the app all right
so always refer to the documentation uh whether it's a weekly or uh strongly
held uh property got it
cool how about the lazy keyword what is that one yeah it's an interesting one uh lazy
"lazy" keyword
is basically laser initialization so that the let's let's take a look at this one uh
i'll find the view that load for example here for patient view controller i'll create something here lazy
variable um what could it be um
another view so for example you can use something to
add like a customization here so uh first of all it's really
convenient to have something customized um like instead of uh if i were to create a
lat constant let view 2 u2 it would be i have to have like that
i have to have it like that and then i have to use a muted load to configure it but here i can just add all the
configurations here
and yeah so the lazy one is used for um mainly for uh
calculating values that you might not need for example if you don't want to add
another view all of the time depending on the on some conditions so like if uh
random you um view adds a view another view so in
this case uh in some of the cases uh when this would be a false the another view will not only will be
added to the uh subview but it won't even be instantiated so that will increase the
performance of the of that a bit so that's one of the uh cases and um
another one is that you have some customization here available so that you can sort of add a tag and so forth so
it's really convenient to uh to add something that you will otherwise
have to write in the method so to keep it close here how about kindle easy keyword be used on
the collection on collections uh yeah yeah yeah it can be used on the collections too
uh so if i create an array then i have to create lazy it'll produce the laser
sequence and then when i have to when i execute a filter it will
um take it one by one basically so or map
so it will not uh it will not uh go through each of those
uh it will not execute the whole code for that but it will execute only when i need the values
to map then map something else if i do map like that to string let me just try
a string in it then map and dabble
in it and if i take the first this will only
take the first value out of this it will not map those will not touch two it will not touch three so if you have a really
really huge collection this will be quite efficient to use lazy on the collections
what if you remove that first would it still go through all what do you mean
if you remove the last method i don't know i know i probably should not go through any of those
okay i don't know the only the only way the only way is to
run i think
i'm going to check it out so probably will be
not even executed because it's just the uh because it's just like a unused
result but let's see trying to figure out what this result is
because this lazy map sequence integer doubles what is this result
lazy map sequence optional dowel and the base sequence is
three elements right so you have these three elements and one two three which are here and the
transformation like combined function which is probably a combination of everything here
and let's try to execute the first
so we're getting the double here right so it went through this
and let's print out the result again uh yeah so we have again
i'm not sure if it's actually caching but but as you can see it didn't execute
anything but it will return you whenever you ask for it whenever you ask for
something okay all right so
let's go to the closures and
"@escaping" closure attribue and non-escaping closures
i hope it's the last one yeah it is the last one so
closures there's those two keywords that always kind of
as a beginner kind of yeah made it difficult to understand
and one of them is the escaping key keyword and the non-escaping is the
other one yep maybe there's another one as well but i'm not sure but can you tell me about
what is an escape enclosure yeah sure there is a there is another one uh auto closure
auto closure but that's probably a different auto closure yeah but that's in a
different video so yeah uh i've added this this simple class here to uh look
at the escaping and no escape so uh the difference is really simple
uh if you so the first of all the escaping parameter applies not only
not really to the closure itself uh but to the closure as the parameter
of the function so um and and what it says essentially is that
you can uh it tells compilot you can store this closure in some variable
that's it because if you don't have this escaping modifier
attribute you you will have to execute it only in the scope somewhere here in
the function as the part for example all this ui view ui kit completion handlers they are
executed in the scopes and there are no escape enclosures and of course you can execute the escape
enclosure here as well there is nothing wrong with that
but if it's a no no escape enclosure you won't be able to assign it so i'll just
uncomment that and i'll get a warning assigning a non-escaping
uh parameter handler to an escape enclosure and if i try to it's implicitly known as
keeping uh at some point and so if it used to be the other way around so the default was
uh the default was escaping and you have to have this no escape attribute to
um change it but if i fix it it will basically add this keeping
and uh not sure if uh if it still has no escape
no it does not so this one is removed yeah
cool so yeah escaping is the one you can store in the variable no escape is the one you can't and there's no escape by
default as of swift five something
okay so like are there any performance benefits if
you kind of yeah i think it has to do with the
performance issues or with the performance optimizations but i don't know uh the details
all right cool but yeah those all the questions i had and
Summary and feedback
i think you you know pretty well all of them so you definitely passed the interview
that's glad to hear unless you're here yeah so
yeah great job glad to hear so yeah
uh i guess that was it thank you dan so much for assisting me and uh grilling me through this interview
uh that was tough to say the least and uh who our viewers enjoyed this as well
yeah i'll put the links i'll put the links to dan uh social media or youtube channel if you
decide to start one and uh uh i think would be good idea so
yeah hopefully that was entertaining and uh if you want to have some if you want me to make some of the
videos on any other topic like um different interview questions just ask them in the comments below i'll go
through all of them and if there is something interesting i'll definitely make a video with the
with those questions and answers so yeah uh good luck in learning ios and uh
subscribe to my channel that's where the new content is going to be soon
cool bye-bye
you

----------

-----

--02--

-----
Date:  2024.02.12
Link: [# 30 tips to be a better iOS developer](https://www.youtube.com/watch?v=HEQGm1gVtOQ)
Transcription:

paste here

----------

-----

--01--

-----
Date: 2024.01.11
Link: [What I Want to See in Swift in 2024 (But Probably Wouldn’t) | @SwiftBird](https://www.youtube.com/watch?v=TnwcB6f9tSw)

Notes:
### Swift Bird 2024: Swift's Future & Wishlist

#### Intro

- **Host**: Yakov
- **Channel**: Swift Bird
- **Topic**: The future of Swift and development tools in 2024, marking the tenth anniversary of Swift.

#### Swift Enhancements

- **Consistency Improvement**: Address language inconsistencies that have crept in over a decade.
- **Example Issue**: Misinterpretation of `private` and `fileprivate` in extensions, stemming from changes in Swift 3.

#### AI Integration in Xcode

- **Ambition**: Incorporate AI into Xcode, enhancing code suggestions and testing, inspired by tools like OpenAI's ChatGPT and GitHub's Copilot.
- **Current Limitations**: Existing AI tools offer limited support for Swift and lack integration with Swift's specific codebases and compiler insights.

#### Swift on the Server

- **Vision**: Expand Swift's presence beyond Apple platforms, specifically for server-side development.
- **Personal Goal**: Develop a fully-functional project on a serverless platform, such as Firebase Functions, using Swift.

#### Additional Thoughts

- **Cross-Platform Development**: Skepticism towards Swift for Android development and cross-platform solutions, based on personal experiences with Kotlin Multiplatform.
- **Swift as a Web Front-end Framework**: Potential but unlikely near-term progress in using Swift for web development.

#### Feedback and Future Content

- **Request for Feedback**: Yakov asks viewers for their opinions on Swift's current state and the points raised in the video.
- **Content Direction**: Consideration of diversifying the channel's content beyond tutorials to include analysis and opinion pieces.

#### Conclusion

- **Next Video Tease**: Upcoming content on a crucial aspect of the software development process that can be improved quickly.
- **Call to Action**: Encourages likes, subscriptions, and support for the Swift Bird channel to help it grow.

Transcription:
Intro
Hey! I’m Yakov, and you’re  watching the Swift Bird.
In the first video of 2024, let’s talk about the  future. This year is an important one for Swift,  
because it marks the tenth  anniversary of the language.
Yeah, I know, it’s hard to believe that.
To me, the introduction of Swift feels  like it was just a couple years ago. I  
still remember that “one more thing”  added to the very end of 2014’s WWDC.
We have a new programming language.
But this video is not about reflecting on the  past. Nor is it about predicting the future.
This time, I’d like to share a few thoughts on  what I wish to see in Swift and the dev tools  
this year. I’ll start with something  small and then go more ambitious.
But before I do, I’m asking you to subscribe  to the Swift Bird. It’s a small channel,  
so each like and subscription makes a big impact.
Swift is nice—but it could be even less confusing
First and foremost, what I want to see improved in  Swift this year is overall language consistency.
Over the ten years Swift’s been out, it’s  become a very versatile tool—something  
like a Swiss army knife. Even though  most updates were publicly discussed,  
debated, and refined before their  release, ten years is still enough  
for some inconsistency to creep in. The  Swift of today is a mix of the concepts  
implemented from the very beginning—and  the paradigms introduced along the way.
I’m not going to overdramataze and say Swift is no  longer easy for beginners. It still is—mostly. But  
at the same time, Swift now has several things  which can confuse even experienced developers.
Here’s one of them. It is something I see  fairly often in all kinds of projects:  
a bunch of symbols meant to be used within just  one class. They can be constants, utilities,  
formatters, and so on. Because they’re  not needed anywhere outside the class,  
it makes a lot of sense to mark them  private. And in many cases, instead of  
putting the keyword before each symbol, they all  are just enclosed in a single private extension.
Except the symbols inside this  extension are not private.
In fact, they’re fileprivate.
Had these symbols truly been private, I wouldn’t  have been able to references them from a different  
object, like this. Even when the object is within  the same file. That’s because the private mode  
is supposed to be stricter than fileprivate.  But in this scenario, that is not the case.
You see, many years ago Swift’s  access-control modifiers used to  
behave slightly differently. Only in version 3  they became what they are today. This redesign,  
however, had certain side effects. One  of them is this implicit transformation  
of private to fileprivate. It was a  compromise for backward compatibility.  
But this compromise remains even after  eight years since Swift 3 came out.
I don’t think every engineer must know  about every caveat of the language. I  
don’t even think knowing about them adds much  value to the engineer’s skill or experience.
Well, I mean, it does. But it really shouldn’t.
I believe the programming language—and  technology in general—is merely a tool  
for solving real-world problems. And for most  engineers, it’s the reality: we work to create  
products that deliver value to the users, not to  impress someone with our textbook-perfect code.
Unless you are writing code  snippets for textbooks, of course.
This was only one example, but you can easily  find many more. For instance, take the APIs  
of some built-in frameworks. Why do you have  functions in some cases but properties in others?
And yeah, I know these are separate frameworks  and not Swift itself. But many of them were  
updated specifically for Swift, and there’s no  reason they cannot be made to look and behave  
even more natively. Even though Swift  was made open-source many years ago,  
Apple still retains huge leverage  over the language evolution. It  
certainly can polish it a bit more and  remove those artifacts of the past.
To sum up, I believe the programming  language should be helping the engineer  
by taking any complexity and confusion  out of the process. And because of that,  
I’d love to see Swift finally say goodbye  to the legacy caveats of the past.
AI’s great, ain’t it? Why not add it to Xcode?
Now we’re moving on to the more ambitious things.
In the last couple of years, artificial  intelligence has made a real breakthrough  
in many areas. You’ve most likely  tried OpenAI’s ChatGPT, Google’s Bard,  
or Microsoft’s Copilot. And chances  are, you use them on a daily basis.  
I do it all the time, especially when  I research something for the videos.
But besides those general-purpose chatbots,  
there’s also a large number of specialized  tools. For example, Google’s NotebookLM  
managed to analyze and explain my own bachelor  thesis even better than I remember it myself.
And of course, AI tools have already made their  way into software development. Perhaps the most  
widely used one is GitHub’s Copilot. But it  has very limited capabilities when it comes to  
Swift. So is Google’s Bard, even though in my own  experience, it works slightly better with Swift.
But even the best tools available today are still  not good enough. That’s because neither of them  
is tailored to the specific Swift codebase  you’re working on. And none of them’s been  
able to marry AI assistance with input from  the actual Swift compiler. That is why you  
sometimes get the code which looks correct but  doesn’t compile when you paste it in Xcode.
And this is where Apple could do a lot.  Just imagine Xcode not only giving you an  
empty template for tests but also filling  it with complete test methods. Moreover,  
imagine how much faster you could work  if Xcode automatically amended any AI  
suggestions based on your actual module  interface and test-coverage percentage.
But sadly, at this point this feels  like only a dream. Because come on,  
right now Xcode often struggles even with  very simple tasks, such as renaming symbols.
Besides, Apple hasn’t demonstrated any sort of  advancement in artificial intelligence yet. And  
when it does, I bet it’s going to be focused  on consumers, not developers. But anyways,  
this is just something I want to see in Xcode  moving forward—it’s not a prediction in any way.
But if you do use AI tools  in you coding work today,  
let me know in the comments. I’m very curious  about your experience: how good they are.
My own use of them is mostly limited to  generating boilerplate—like writing setup  
code in tests. But even in this scenario  I often have to fix the generated code  
afterward. And more complex cases,  such as refactoring large classes,  
so far turned out not even worth my time.  Every time I tried, I ultimately ended up doing  
everything by myself—just because sorting out  the suggestions was much longer and much harder.
What about the back end?
And here comes my biggest wish for  Swift this year. But it also was my  
biggest wish last year and the year before that.
It is about Swift going beyond just  Apple platforms. First and foremost,  
I’m talking about Swift on the server.
As you perhaps know, there’s nothing that  prevents Swift from running on Windows or Linux,  
and even compiling for platforms like WebAssembly.
But just the ability to compile and run  the program is not enough to ensure any  
sort of traction for the language. Swift’s been  available on other platforms for many years,  
but its actual use outside the  Apple ecosystem is still pretty low.
Honestly, I think that’s unfair. Because  all the features that make Swift so great  
on the iPhone could also benefit back-end  developers. Using the same stack could give  
many opportunities to the people developing  client apps that interact with the back  
end—which is basically most developers—and  especially to the people developing client  
apps alongside their back end—people like me.  Right now I mostly use TypeScript and Node for  
writing server-side code in my projects,  and I cannot say I enjoy using them.
With the status quo of Swift on the back end, it’s  just not worth the hassle for most engineers. And  
to me, that feels kind of sad, because there’s  a number of great projects that make using Swift  
on the server just as easy and enjoyable  as on iOS and macOS. And more importantly,  
there’s a fantastic community behind these  projects. Last summer, I was in Apple’s  
mentorship program where I got a few great tips  on using Swift on the back end. It wasn’t the  
easiest thing to set up and use, compared to  developing client apps, so after having built  
a prototype of my own project, I switched  to something else. But anyway, it gave me  
some insight into the overall process—and  also the future plans of the community.
No matter what Apple does this year to push  the server initiatives forward—and frankly,  
I doubt it’s going to do much—my own goal  for this year is to build a fully-functional  
project that runs on a serverless  platform such as Firebase Functions.
Let me know in the comments if you’re  interested in this topic. If you are,  
I’ll be covering my progress on this channel  and probably open-source the project in the end.
In my understanding, Apple has little interest  to invest its own resources into making Swift  
more widespread on the back end. But I guess  it’s time to stop relying on Apple, after all.
A few more things
Before I wrap up, I’d like to mention a  couple things that didn’t make it to my  
wish list. I realize they could have a  huge impact on the developer community,  
and as such they’re wanted by many people.  But I’m just not invested in them personally.
The first thing is yet another aspect of using  Swift beyond just Apple platforms: it’s using the  
language to develop Android apps. A few years ago,  I got some experience with the opposite approach:  
using Kotlin to write the common business logic  for both iOS and Android. And let me tell you,  
it didn’t go well. Though Kotlin Multiplatform  is a first-party initiative of JetBrains,  
the maintainer of Kotlin, even setting up  the cross-platform workflow turned out to  
be a nightmare. My team and I focused  just on the business logic and didn’t  
touch the user interface whatsoever, but  bugs and crashes were abundant, anyways.
Granted, many things could change in  the two years since then. But so far  
cross-platform app development still seems  to mostly come down to using JavaScript  
frameworks like React Native. And in most  cases, such apps don’t feel native at all.
Swift seems an unlikely candidate to become  the cross-platform solution in the near future,  
because its maintainers are mostly  focused on just the Apple platforms.
And here comes one more thing related to  cross-platform development in Swift. It is  
using the language as a front-end framework on  the web. This is something rarely discussed—I  
guess that’s because there’s just  so little overlap between app and  
website developers. But technically,  with its excellent support for DSLs,  
Swift could really shine at building powerful  websites. In addition to easy-to-read syntax,  
it also features built-it safety checks,  so invalid code would just not compile.
But again, I doubt we’re going to see much  progress in this direction any time soon.
What do you think?
And now’s the time for a wrap-up. I explained some  of the things I want to see in the next iterations  
of Swift. I intentionally did not limit myself to  what Apple and the Swift steering board are likely  
to do. It’s more like feedback from someone  who’s been using Swift for over six years.
Of course, now I’m looking forward to  your feedback. Tell me in the comments  
what you like and dislike about today’s Swift. Do  
you agree with any of my points? Or  do you have a different perspective?
I guess it would be interesting  to go back to this topic later  
this year and see what 2024 actually  brings to Swift and its community.
If you enjoyed this video, please give it a  thumbs-up and subscribe to the Swift Bird.  
It’s something that really helps me grow  this little channel. In the description,  
you will also find the links where you can  support the Swift Bird by sponsoring it.
Also tell me what you think about this analysis  genre. I’ve had a look at my last year’s videos  
and noticed most of them were just explainers  and tutorials. While they’re good at answering  
specific questions, sometimes I feel restricted  by the format—that’s without even saying that  
researching and fact-checking every detail  takes a lot of effort. I’m thinking of making  
the channel’s content more diverse with videos  like today’s. I’d love to get your input on that.
Stay tuned for the next video
Next week, I’ll be back with a video on one  crucial piece in the software-development  
process—and how you can improve it in just a  few minutes. Stay tuned, and make your year fly!

----------

1. [What I Want to See in Swift in 2024 (But Probably Wouldn’t) | @SwiftBird](https://www.youtube.com/watch?v=TnwcB6f9tSw)
2. [# 30 tips to be a better iOS developer](https://www.youtube.com/watch?v=HEQGm1gVtOQ)
3. [# iOS Interview Questions and Answers with Sample Code](https://www.youtube.com/watch?v=gmyEHW7zDYc)✰⋆🌟
4. [2023 LLVM Dev Mtg - Compact Value Witnesses in Swift](https://www.youtube.com/watch?v=hjgDwdGJIhI)
5. [# SwiftUI Navigation Made Easy: Harnessing the Magic of Enums](https://www.youtube.com/watch?v=do4uZBXP6bc)
6. [# All You Need to Know About Swift Macros | Swift Macros Deep Dive (Part 1) | @SwiftBird](https://www.youtube.com/watch?v=LrY9f5kOQ_4)
7. [# 15-Year-Old App Goes All Swift | Caffeine Refactored | @SwiftBird](https://www.youtube.com/watch?v=fehxCCKWpZA)
8. [# iOS Dev Job Interview - Must Know Topics](https://www.youtube.com/watch?v=XTAziR-tY-A)
9. [# Autorelease Pool, Lazy Initialization & More | Advanced Memory Management in #Swift](https://www.youtube.com/watch?v=5Yi3KFLz8Ms)
10. 




-----
--99--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--98--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--97--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--96--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--95--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--94--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--93--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--92--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--91--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--90--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--89--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--88--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--87--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--86--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--85--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--84--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--83--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--82--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--81--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--80--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--79--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--78--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--77--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--76--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--75--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--74--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--73--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--72--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--71--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--70--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--69--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--68--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--67--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--66--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--65--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--64--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--63--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--62--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--61--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--60--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--59--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--58--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--57--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--56--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--55--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--54--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--53--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--52--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--51--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--50--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--49--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--48--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--47--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--46--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--45--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--44--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--43--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--42--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--41--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--40--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--39--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--38--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--37--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--36--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--35--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--34--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--33--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--32--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--31--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--30--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--29--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--28--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--27--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--26--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--25--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--24--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--23--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--22--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--21--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--20--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--19--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--18--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--17--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--16--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--15--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--14--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--13--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--12--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--11--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--10--

-----
Date:
Link:
Transcription:

paste here

----------

-----
--09--

-----
Date: 2024.02.21
Link: [# Autorelease Pool, Lazy Initialization & More | Advanced Memory Management in #Swift](https://www.youtube.com/watch?v=5Yi3KFLz8Ms)

### Notes on "Lazy Initialization, Autorelease Pool, and Alternatives to Reference Counting" Episode

#### **Advantages:**

- **Lazy Initialization:** Improves app performance by delaying object creation until needed, saving resources.
- **Autorelease Pool:** Manages memory efficiently in ARC and MRC, ensuring objects are released at appropriate times without leaking memory.
- **Alternatives to RC:** Offers different memory management strategies like garbage collection and Rust's ownership model, which can be more suited to specific use cases.

#### **Drawbacks:**

- **Lazy Properties Thread Safety:** Lazy-initialized properties are not inherently thread-safe, which can lead to issues in concurrent environments.
- **Garbage Collection Pauses:** Can introduce noticeable pauses in program execution, affecting user experience, especially in real-time applications.

#### **Tips and Advice:**

- Use lazy initialization for heavy objects or when initialization depends on conditions that might not always be met.
- Employ autorelease pools to manage temporary objects efficiently, especially in loops or intensive operations.
- Consider alternatives to reference counting for projects where their benefits outweigh the cons, such as Rust for systems programming.

#### **Lecture Content:**

- Explanation of lazy initialization, autorelease pools, and alternatives to reference counting, with a focus on Swift.
- Distinction between lazy properties and computed properties.
- Usage scenarios and considerations for autorelease pools in both ARC and MRC environments.
- Overview of garbage collection and region-based memory management as alternatives to reference counting.

#### **Main Challenges:**

- Balancing memory management techniques to optimize performance without compromising safety or user experience.
- Choosing the right memory management strategy for a given project's needs and constraints.

#### **Importance and Usefulness of the Topic:**

- Understanding different memory management techniques is crucial for developing efficient and effective software, especially in resource-constrained environments like mobile devices.

#### **Accomplishments:**

- Provided a comprehensive overview of memory management strategies in Swift, including practical tips for using lazy initialization and autorelease pools.
- Introduced viewers to alternatives to reference counting, broadening the scope of memory management techniques available to developers.

#### **Summary of the Content:**

This episode covered the concepts of lazy initialization, autorelease pools, and alternatives to reference counting, focusing on their application in Swift programming. It highlighted the advantages of using lazy initialization to save resources, the role of autorelease pools in managing memory efficiently, and explored other memory management strategies like garbage collection and Rust's ownership model. Practical advice was offered on when to use these techniques and the challenges associated with each.

#### **Interesting Quotes or Insightful Sentences:**

- "Lazy initialization—one of the easiest tricks to make your app appear faster."
- "Without an autoreleasepool block, you’ll be accumulating all the garbage until the entire loop finishes."
- "Reference counting seems like the optimal choice for systems which heavily rely on real-time interactions and at the same time have a limited amount of resources."

The episode emphasized the importance of understanding and effectively applying different memory management techniques in Swift to improve app performance and user experience.

QA:
### ANKI Flashcards for "Lazy Initialization, Autorelease Pool, and Alternatives to Reference Counting"

**Q: What is lazy initialization in Swift?**  
A: Lazy initialization is a technique where object creation is delayed until it is needed, saving resources and improving app performance.

**Q: Why are lazy properties in Swift always declared as variables?**  
A: Lazy properties are declared as variables because their values are not retrieved until they're called for the first time, and variables allow reassignment at any point.

**Q: Can computed properties in Swift be declared lazy?**  
A: No, computed properties cannot be declared lazy. They act like lazy properties in terms of deferred execution but are computed from scratch every time they are called.

**Q: What is an autorelease pool in memory management?**  
A: An autorelease pool is a mechanism that keeps objects for a while and sends a release message to each when it's drained, extending the objects' lifetime momentarily.

**Q: How do autorelease pools differ under Automatic Reference Counting (ARC)?**  
A: Under ARC, instead of an autorelease-pool object, an @autoreleasepool block is used, which acts like a box that releases every object created within it when the block ends.

**Q: What are the alternatives to reference counting for memory management?**  
A: Alternatives include garbage collection, region-based memory management, and Rust's ownership model, which enforce memory management rules at compile time.

**Q: What is the main downside of garbage collection in memory management?**  
A: The main downside is that it can introduce pauses in program execution, as it freezes the entire program momentarily to manage memory.

**Q: How does Rust's ownership model manage memory?**  
A: In Rust, each object in memory has an owner, and when that owner goes out of scope, the objects owned by it are destroyed, allowing explicit lifetime management of objects.

**Q: Why are global symbols in Swift considered lazy by default?**  
A: Global symbols are lazy by default to avoid initializing every static property at launch, which would introduce a significant delay.

**Q: What is the key difference between real lazy properties and computed properties in Swift?**  
A: Real lazy properties are executed only once and then keep the resulting value, whereas computed properties run from scratch every time they are called.


Transcription:

Intro
Hello and welcome to the Swift  Bird. Or rather, welcome back.
This is the second part of the third  episode on the first topic in this series…
…never mind.
I’m Yakov, and today we’ll be talking about  lazy initialization, the autorelease pool,  
and the alternatives to reference counting.  Hopefully, after that I’ll be able to leave  
memory management alone, and instead  focus on something more practical.
If you find this video helpful, please give  it a thumbs-up, subscribe to the channel,  
and consider sponsoring it at  the links below. With that said,  
let’s move on to the first topic of  today, which is lazy initialization.
Lazy Initialization
In Swift, as in many other languages,  when you want to create a new object,  
the runtime needs to do two things for  you. First, it finds some unused bytes  
in memory. That step is called allocation.  And second, it actually creates the object  
so it can be used in your program. This  second step is called initialization.
The separation of these two operations opens  a few opportunities to make memory use more  
efficient. The key technique for that is  called lazy, or deferred, initialization.
Swift, still being a modern language by  today’s standards, does quite a few tricks  
to optimize the initialization process, and lazy  initialization plays an important role in it.
Here’s the key idea. Instead of  creating the object directly,  
you provide instructions how to do that  at runtime. These instructions look like  
a closure and act as a recipe that’s used  only when needed. If your program doesn’t  
need the object, it doesn’t use this  recipe, and no resources are wasted.
In Swift codebases, you find this pattern  used all across the place. For example,  
preparing data to be displayed may involve  formatting dates. The DateFormatter object  
is a relatively heavy one in terms of  initialization, so unless you actually  
have a date to format, it makes a lot  of sense to declare the formatter lazy.
Another scenario where lazy initialization  can help is when your app implements some  
sort of caching mechanism. In that case, you  can defer initializing your networking stack  
until the user has requested something  that doesn’t exist in the local cache.
There’s a few things to keep in  mind when using lazy initialization.
First, lazy properties are always declared  as variables. That’s because their values  
are not retrieved until they’re called for  the first time, and constants do not allow  
that. It also means that at any point, you can  reassign a lazy variable with any other value.
Second, computed properties cannot be declared  lazy. Though in terms of deferred execution,  
they act just like lazy properties,  there’s one crucial difference:  
computed properties run from  scratch every time you call them,  
while real lazy properties run only once  and then they keep the resulting value.
Third, global symbols cannot be declared lazy  too—but that’s because they’re already lazy  
by default. That makes a lot of sense,  because if the app tried to initialize  
every static property at launch,  this would introduce a hefty delay.
With the last two points in mind,  sometimes you’re left with a dilemma  
what to use for declaring constants. The  expressions look very similar—and in fact,  
the difference gets important only  in a handful of cases. In general,  
I use a static constant when I’ll be using it  more than once, and for single use I go with a  
computed variable. But again, the difference  is really negligible in most scenarios.
And one more thing to be aware of,  lazily-declared properties are not  
thread-safe out of the box. If multiple  threads attempt to access the property,  
the closure which emits it  may be called more than once.
That is lazy initialization—one of the  easiest tricks to make your app appear faster.
Autorelease Pool
Now, let’s talk about a thing lots of developers  
have heard of—but never used in  practice. The autorelease pool.
As with many other memory-management concepts,  
the autorelease pool emerged back in the days of  Objective-C, and even before Automatic Reference  
Counting arrived. But it survived the ARC  transition, and even made it to Swift.
The autorelease pool is an interesting tool.  In MRC, it offers some elements of automatic  
memory management; but in ARC, it lets you  regain some manual control over memory,  
that was taken away from you by ARC. In either  mode, autorelease pools play an important role,  
and if you use Cocoa without  them, you’re leaking memory.
As you know, before Automatic Reference  Counting, you had to send retain and release  
messages to each object. But in addition  to these two, there is a third message,  
aptly called autorelease. What it does is, instead  of deallocating the object immediately, it adds  
it to an autorelease pool—which is basically a  scratchpad. It keeps the objects for a while,  
but when it’s drained, as it’s called in this  whole “pool” concept, it sends a release message  
to each of the objects. Normally, the pool is  drained at the end of every event-loop cycle.  
So by sending autorelease instead of release,  you extend the object’s lifetime for a moment.
But why would you want that? You see,  it’s quite common for methods to create  
and return objects which are only needed for a  short time. The calling code gets the result,  
processes it in some way, and then discards.  Without the autorelease pool, it would be the  
calling method’s responsibility to dispose  of the created objects, but it may not have  
enough information to decide whether it’s safe to  release them. By sending the autorelease message,  
the called method clearly indicates that  it wants nothing to do with the object  
after it’s returned. And the autorelease  pool handles the cleanup automatically.
This technique is used in  many built-in Cocoa APIs,  
such as NSString initializers and more.  Moreover, Objective-C has an entire  
naming convention for that. The guidelines  suggest how you should name your methods  
so it remains clear who’s responsible  for releasing the objects they produce.
But I’m going too much into detail here.
In ARC, including Swift, instead of an  autorelease-pool object now you use an  
@autoreleasepool block. It looks like a closure—or  block, as they’re called in Objective-C and some  
other languages. To the developer, it acts like  a box with one particularly useful feature:  
when the block ends, every object created within  it receives a release message. In other words,  
you set explicit boundaries which  limit the object’s lifetime.
In Cocoa and Objective-C, especially  its pre-ARC variant, the importance of  
autorelease pools is quite significant—to the  point where each thread must have at least one  
pool available—otherwise you’ll be leaking  memory. Adding objects to an autorelease  
pool was often used to group many short-lived  objects together, or defer their deallocation,  
or do both. You see, releasing each  object individually imposes some overhead,  
and in that scenario draining the whole  pool in bulk can be more efficient.
In Swift, the autorelease pool is available for  your convenience—but you don’t really have to  
use it. One of the situations where it may come  in handy is similar to the old use case. Imagine  
you’ve got a loop whose each iteration creates a  new object. You don’t need the object itself—just  
some part of it. Without an autoreleasepool block,  you’ll be accumulating all the garbage until the  
entire loop finishes. But with this block, the  objects are released at the end of each iteration.
That’s a pretty rare use case, but as always,  
the more tools you have at your disposal,  the more flexible your code can be.
Alternatives to Reference Counting
I’ve got one last topic for today. And  this one is not about lazy or pools—
or lazy pools.
It’s not even about Automatic Reference  Counting at all. Quite the opposite:  
it’s about the alternatives to RC.
I’ve already touched on the basics of manual  memory management in a previous video,  
so I don’t want to repeat myself. Besides,  allocating and deallocating memory manually  
can’t really rival reference  counting in its ease of use.
The main competitor to RC is garbage collection,  
and just as reference counting, it comes  in multiple flavors. The most common one  
is called tracing garbage collection,  and it uses the mark-and-sweep approach.
This approach consists of two phases happening  at regular intervals. During the mark phase,  
the garbage collector goes through the entire  memory graph, starting from the program’s root,  
and checks which objects are accessible.  Those that are receive a flag. Then,  
during the sweep phase, all memory  is scanned from start to finish,  
and objects which don’t have the flag  are considered garbage—and cleared.
The main downside of garbage collection  is that it can introduce pauses to the  
program’s execution. Instead of managing  memory on an object-by-object basis,  
it freezes the entire program for a moment.  No one enjoys glitches while scrolling or  
doing other stuff, and early iPhones weren’t  very powerful. That fact—as well as reference  
counting’s constant-time complexity—seems to be  the main reason for iOS to favor RC in the end.
But actually, early versions of Cocoa  on macOS supported garbage collection  
as the alternative to manual memory management.  
The only alternative—as there was no  Automatic Reference Counting back then.
Heck, Cocoa even supported coding in Java.
Besides garbage collection, we’ve  got something called region-based  
memory management. This technique  is not very common, so I won’t stop  
here for long. Basically the program’s  memory is divided into multiple regions,  
each having an expiration date. When it arrives,  the whole region is emptied. This approach works  
for programs whose objects have predictable  lifetimes, but on iOS, it’s not really common
And then we have something quite unique. It  is Rust with its ownership model. In Rust,  
each object in memory has an owner,  and when that owner goes out of scope,  
the objects owned by it are destroyed.  You can move a value to a different owner,  
or borrow it for a moment and then return. In  Rust, these rules are enforced at build time,  
so when the program runs, the lifetime of  each object is known beforehand. That makes  
the language extremely efficient, placing it right  next to C with its fully-manual memory management.
By the way, in last year’s update, Swift added  similar tools for explicit lifetime management.
So, to summarize, reference counting is  not the only technique that exists to make  
memory management more approachable. Some  of the alternatives may be even easier to  
use. But reference counting seems like  the optimal choice for systems which  
heavily rely on real-time interactions and  at the same time have a limited amount of  
resources—in other words, systems  like your smartphone or laptop.
Tip for Your Interviews
By now, I’ve covered many frequently-asked  questions about memory management in  
Swift. If you’ve got more, leave them in the  comments so I can do a follow-up video later.
But my best interviews—on either side of  the table—were never about remembering  
stuff. You may not know one specific fact,  but if you’re familiar with the big picture,  
you can make assumptions, think  out loud, and often come to the  
right answer in the end. And even if it’s  completely wrong, your ability to analyze  
and reason usually earns you more points  than an answer that you simply remembered.
Outro
And that marks the end of this episode.  This was the last video on memory management  
in Swift—at least for now. But I’ve got  many more topics planned for this series.
I just wish I had more time to work on them.
You can help me by giving this video a  thumbs-up, subscribing to the channel,  
and supporting it at the links below.  All of that is great motivation for me.
I’ll see you soon with a new video.  Until then, make your references fly!

----------

-----
--08--

-----
Date: 2023.07.03
Link: [# iOS Dev Job Interview - Must Know Topics](https://www.youtube.com/watch?v=XTAziR-tY-A)

notes in a q-a form:
Given the extensive nature of the video transcription, I will create ANKI flashcards for several key topics covered in the document up to the 39% mark visible. I'll focus on fundamental iOS development concepts, networking, JSON handling, Swift specifics, and some interview tips based on the content provided.

1. **Question:** What is JSON and why is it important in iOS development? **Answer:** JSON (JavaScript Object Notation) is a lightweight data-interchange format used for data exchange between a server and an iOS app. It's important because it's easy for humans to read and write, and easy for machines to parse and generate.
    
2. **Question:** What is the purpose of using async-await in Swift? **Answer:** Async-await in Swift is used to write asynchronous code in a synchronous manner, making it easier to read and maintain. It allows for non-blocking network calls, enabling the UI to remain responsive while data is being fetched or sent to a server.
    
3. **Question:** How do you use Codable in Swift for JSON parsing? **Answer:** Codable is a protocol that enables easy encoding and decoding of JSON data. By conforming a Swift model to Codable, you can decode JSON into Swift objects and encode Swift objects into JSON with minimal boilerplate code.
    
4. **Question:** What is the difference between classes and structs in Swift? **Answer:** Classes are reference types, meaning multiple instances can refer to the same data in memory. Structs are value types, meaning each instance keeps a unique copy of the data. Classes support inheritance, while structs do not.
    
5. **Question:** How do generics enhance Swift programming? **Answer:** Generics allow for writing flexible, reusable functions and types that can work with any type, reducing code duplication and increasing the abstraction level without losing type safety.
    
6. **Question:** What are closures in Swift and how are they used? **Answer:** Closures are self-contained blocks of functionality that can be passed around and used in your code. They are similar to blocks in C and lambdas in other programming languages, allowing for capturing and storing references to variables and functions.
    
7. **Question:** Why are network calls in iOS development marked with @escaping? **Answer:** Network calls are marked with @escaping because the closure passed to the function might be called after the function returns, escaping the scope of the function, which is common in asynchronous operations like fetching data from the internet.
    
8. **Question:** What is the use of map, filter, and reduce in Swift? **Answer:** Map, filter, and reduce are higher-order functions in Swift that operate on collections. Map transforms each element in a collection, filter selects elements based on a condition, and reduce combines all elements into a single value.
    
9. **Question:** How does Swift's URL session handle networking? **Answer:** Swift's URL session provides an API for performing HTTP network requests, such as fetching data from the web, submitting data to servers, and more. It supports both synchronous and asynchronous operations, including handling data, downloading files, and uploading data.
    
10. **Question:** What is the significance of using guard let in Swift? **Answer:** The `guard let` statement is used for early exit strategies. It unwraps optionals and ensures that variables have valid values before proceeding, reducing the nesting of if-let statements and making the code clearer and safer.
    

This set of flashcards covers a broad range of topics introduced in the transcription, providing a solid foundation for understanding key iOS development concepts, Swift programming specifics, networking essentials, and interview preparation tips.


Transcription:

I've put together a collection of my best iOS  Developer interview question videos here's a  
list of what we'll cover and they are time  stamped in case you want to jump around now   of course I can't cover every topic you could  possibly get asked about in an interview but  
these are very common topics that are asked  about all the time all right let's get started
the vast majority of iOS apps have some sort  of networking component to them data lives on a  
server and the IOS app needs to go to that server  download the data and display that data nicely to  
the user on the device today's video breaks down  the basics of how that works we talk about what   is Json and how to use it and then we write a  network called encode using async await and Swift  
and this process is a foundational skill for any  iOS Developer and will almost certainly be asked  
about during an iOS Developer interview before  we dive in I want to say that Learning Network   calls is very tricky it took me a long time to  fully grasp them and it took me writing a ton of  
different network calls to fully understand them  this video is meant for the beginner to give you   the foundational skills on a simple example but I  want to encourage you that hey you're not going to  
be a network call Pro after this video or any  singular video on the internet it is going to  
take you time and repetition to learn this so  I want to let you know that before we dive in   this is meant to be one of your first steps on  this journey of Learning Network calls okay so  
we need to download data from a server and make  it look pretty on the device when working with   data from a rest API that data will be formatted  in what's called Json short for JavaScript object  
notation here's a basic example of a user object  in Json you can see it's encapsulated by curly  
braces it has key value pairs in this example we  have a username a bio and an avatar URL that's a  
super simple example let's look at a real life  version of this in the GitHub API documentation  
so I'm going to get a user section of the GitHub  documentation over on the left here you can see   all the different areas you can go into so I see  I'm in user uh get a users what I want to be in  
now so this is documentation it'll tell you  what's in the API over here on the right you   see this default response now because I have my  screen blown up it's a super little window but  
you can see right here's this curly braces there's  a login there's an avatar URL down here you'll see  
a bio now this is just an example of you know the  response what I like to do is take this URL here  
in the curl copy it and then if you open up your  terminal you can type in curl and then paste that  
URL now you see it's api.github.com users and then  username this is like the placeholder so let's  
delete username and I'll type in my username  s-a-l-o-e-n0400 you can type in your GitHub  
username hit return and this returns real data  from the API so you can see here's my login see  
here's my bio iOS Developer specializing in Swift  you can see you know follower count so this is  
what I really example of Json would look like and  again you can see it's encapsulated by the curly  
braces you can see the key value pairs right the  key is login the value is sln0400 and this is an  
example where I just get one object back it's very  common that you're going to need a list of objects  
so I'm going to down here in the next prompt here  curl same thing except now I'm going to do slash  
followers and I know this from the API I just want  to show you if I hit return this is going to be  
a list of my followers now so I want to show you  this we'll scroll back up to the top here's where   I typed it now the reason I want to point this  out is because this is another common example  
of Json you see this bracket here it probably  looks familiar from an array so here we get back   an array of my followers right there's the login  the Avatar URL and then you see it separated by  
comma here's another follower here's another  follower so I want to point this out because   yes the Json could return a single object or could  return a list of objects I mean you can do a lot  
more but these are two very common examples that  that I want to introduce you to for working with   Json and a quick note about the GitHub API this  is an example of an open API some apis require  
you know authentication where you have to have  a login and a username some apis require an API  
key because this video is meant for the absolute  beginner right writing your very first Network   call learning this tough subject I wanted to  keep it as simple as possible just know that  
Network calls are very deep subject we're just  scratching the surface and dealing with API keys   and oauth that's an adventure for another time  we're sticking with the absolute Basics okay so  
now you know the data is formatted in Json you've  seen real examples of it so let's get back to the   task at hand and that is we need to download this  Json somehow convert this Json into models in our  
Swift Code base and then use those Swift models  to build our UI to show the final result to the  
user when I'm building this I like to break this  down into Steps step one is to build out the UI   with dummy data and this helps me visualize you  know what I'm working with step two is to look at  
the Json respond fonts that you see here and use  it to create the models in our Swift Code base  
and then step three is to actually write out the  networking code and then step four is to use that  
networking code and connect the UI with the final  result okay step one build out the UI with dummy  
data here I am in xcode I already have this built  out but as you can see super basic Swift UI code  
I wanted to save some time here and this step goes  hand in hand with designing the feature of course   if you're designing your own app right if you're  working for a company they have their own server  
they have a designer giving you a spec that's  different you build what they give you but if   you're designing your own app this is the step  where I look at the Json and I say okay this is  
the data I have to work with right I have an  avatar URL I have a bio right I have the the   Twitter URL I can only build my GitHub profile  screen to include what data I get back right and  
this is what happens when you're working with  someone else's API whether it's GitHub YouTube   Twitter you're limited by what they give you so  that's why in this step look at the Json build  
out your fee feature and again I like to build  out my dummy UI to visualize what I'm working   with and in our simple GitHub profile user page  we're just going to have the profile picture  
their username and their bio now that we have the  basic UI sorted I move on to step two and that is  
creating the models that I'm going to use from the  Json so here next code let's do that I'm going to   create all this in one file by the way I'll talk  about that in a second but let's create a struct  
called git Hub user so this is the object for the  user that we're going to use now what properties  
do we need again looking at the UI we need the  profile picture the username and the bio now  
pulling up the Json you can see the username is  called login I have the Avatar URL and I have the  
bio so that's what I want to work with now back in  the day a swift developers used to have to parse   the Json manually and it was a major pain I'm not  even going to get into that nowadays we have a  
nice protocol called codable so I'm going to make  GitHub user conform to codable you can see here  
and real quick actually you see the documentation  right there bull down down here says codable is  
decodable and encodable this just combines both  of them but the use cases when you're decoding  
something that is when you're downloading the data  from the server you have to decode that Json into   your models and codable is when you're uploading  something say you're creating a tweet we have to  
encode that tweet on the app into Json and send  it up to the server so we're just going to do   codable technically since we're just pulling we  could just do decodable but we're going to keep  
it as codable for both of them now when working  with codable your property names need to match the  
Json exactly now there's a more advanced caveat  you know if you want your property names to say   whatever you want you can use coding Keys that's  out of the scope of this beginner course you know  
if you just make your property names exactly match  your Json that is what you're going to do 90 of  
the time so we'll say let log in and that is of  type string and then going back our Avatar URL you  
can see is let Avatar underscore URL and then bio  is just bio so let bio of string now I'm going to  
contradict myself a little bit because here's our  GitHub user and we are matching our Json exactly   so this will work but in Swift right look at our  Avatar URL that's snake case we don't typically  
write our property names using snake case it's not  how we do things in Swift right we use camo case  
so instead of Avatar underscore URL we're going  to do Avatar Capital URL and when we write our  
Network call we can create our decoder and there's  a property called convert from snake case on our   decoder that we're going to use that's just a  sneak preview we'll come back to that so that's  
one potential gotcha when you're matching your  Json exactly and again this is just because that   Swift convention to use camel case now we have our  model object ready to go okay so let's write this  
network call and I'm going to do this right on our  view here in our Swift UI View and this is purely  
for educational reasons and your understandings I  remember when I was learning it was very helpful   for me to see everything all in one place right  now in a real project you know you'd refactor your  
network calls into a view model or an API service  network manager your GitHub user object would be  
in another file but again when I was learning  having everything in all those different places   it was difficult for me to make the connections  in my head to know what was what so to be clear  
I am spelling everything out on this screen to  keep everything in one place so hopefully you   can make those connections you know this video is  not about refactoring and project organization but  
just knowing a real project you would organize it  and refactor it but again keeping everything in   one place for the ease of your understanding okay  so the function here on The View we're gonna say  
func git user and we're going to mark that async  because we are using async away and we're going   to Market throws because we want to throw errors  now you don't have to mark this throws but when  
working with network calls there's so many things  that can go wrong right they may not be connected   to the internet uh maybe you know you have the  wrong URL or the server is down right so many  
things can go wrong with a network call so you  pretty much always are going to have it throws   here and we want to return a GitHub user that's  the object after we make our Network call that  
we're going to return from this function so open  curly brace close curly brace now the first thing   we need is the URL that we're going to point  to to get the data from if we go back to the  
GitHub API here right get a user that's what  we're working with and then here you can see   the URL this api.github.com users username so I'm  going to copy this back to xcode we're going to  
say let endpoint equal and it's going to be a  string paste this here now we don't want this  
dummy username right you can put in your name I'm  going to put in my name or put in whatever name   you want of a GitHub user now in real app maybe  the user you know can type this in and then you  
search based on that but again we're just hard  coding to demonstrate how the network call works   so now that I have my endpoint we're going to  use what's called URL session which in Swift is  
basically how you make Network calls let me type  out the code and then I'll explain it so I'm going   to say let data comma response equal try oh wait  and again this is uh Swift concurrency async await  
URL session Dot shared dot data from URL this  is an example of a get request so there's four  
main types of requests you can make with network  calls there's the get which means you are just   pulling down data read only there's post which  means you are posting data to the server you're  
sending things up to the server right get would  be downloading post would be uploading right if   you created a tweet and uploaded it to Twitter and  then there's the put which means you're editing  
something and then there's delete which obviously  you would be deleting something those are the four   main basic types of requests again we're doing  a get because we're just downloading and pulling  
the data so from URL but you can see I need a URL  object and if I go back to just typing in the data  
so we can see that quick little documentation  data from you can see I get back data in a URL  
response so that's why here I say here's data and  response so what the data is it's going to be the  
data you know the Json the response is response  codes we'll get back to that in a second so data  
from URL so now I need a URL object this looks  like a URL but this is a string so in Swift We  
have a URL object that we need to convert this  string to and when we initialize URL object   it returns an optional so we need to do some  unwrapping here guard let URL equal here's our  
URL string right we're initializing a URL from a  string the string we're going to pass in is that  
endpoint that we just had up here so we're going  to pass in this string to our URL initializer   and it's going to return a URL object which we're  going to use in our URL session but it can return  
an optional so all I'm doing here is handling  the error we'll say Throw error we'll come back  
to that in one second I just want to finish this  placeholder so the URL that we're going to pass in   is the URL that we just created right here on line  32. let's talk about these errors real quick right  
we're throwing this error isn't going to work we  can create our custom error objects to handle each  
error specifically and this is a common practice  with network calls so again I'm just doing this   all in one file maybe you'd have a separate error  file but we'll say enum GH for GitHub error I'm  
just putting the GH in front of it to name it  something you can name it whatever you want I just   can't be normal error because that already exists  in Swift and our custom error needs to conform  
to the error protocol so I can say case we'll say  this is invalid URL so if the URL fails I'm going  
to throw the error called GH error.invalid URL  I'm going to put this on a new line for structural  
purposes so again we're creating a URL if that  URL can't be created we throw the error invalid  
URL and then if we have a good URL we're going  to call URL session share.data from that URL and  
that is going to return data in a response so now  we need to work with the data in the response so  
first we want to check the response because what  the response is if you're familiar right 404 not   found you know 500 server error or 200 everything  went great these are all the HTTP response codes  
on the internet and this this is your opportunity  to handle those accordingly so let's do that we'll   say guard let response equal response as I'm  going to cast this as an HTTP URL response so I  
can get the codes here and then get the response  dot status code again this is that 404 not found  
or 500 server error so I want to just make sure it  equals 200. 200 means everything is A-Okay we're  
good to go else and I want to throw but I don't  have the air yet so again down here in GH air  
we'll say case invalid response and then I will  throw GH air dot invalid response now again this  
is the opportunity I'm only checking for 200 if  we have 200 great we're good to go if not throw a  
generic invalid response error this would be your  opportunity if you did get a 404 not found or 500  
to show very specific errors to that code again  for your app and when dealing with network calls  
it's very important to be specific about your  errors right have you ever used an app and it   just says on unable to complete the task and you  have no idea what's wrong this is your chance to  
tell the user exactly what is wrong which is  what you want to do and for the sake of time   I'm just giving you a couple examples to point you  in the right direction so now that we have a good  
200 status code that means everything was A-Okay  now we want to work with our data to convert the  
Json into our GitHub user object so to do that we  want to do a do we want to create our decoder so  
let decoder equal Json decoder right this is how  we're going to decode this Json and then this is  
what I talked about earlier we want decoder dot  key decoding strategy equals dot convert from  
snake case so pulling up the Json remember Avatar  URL had that underscore space URL well again in  
Swift we use camel case not snake case so luckily  Swift has a built-in it'll convert it for you so  
that's why if I go back to my user I can have  Avatar URL in camel case because what convert  
from snake case does it deletes the underscore and  capitalizes the first letter that's what convert   from snake case does so again this is the gotcha  where you may not want to match the Json exactly  
now you could match the Json exactly and keep it  snake case have the underscore your Swift Code   will just look weird and other Swift developers  will be like what's this snake case stuff here so  
that's why I want to use convert from snake case  but again if it's one word or it's already in   camel case you want your property names in your  object to match the Json exactly again with the  
exception of you know converting from snake case  okay finally let's return try decoder dot decode  
and then we want to pass in a type and then from  data so when we're decoding we have to tell it   what type we're decoding into so we're going to  say GitHub user.self that declares the type from  
the data well that's the data we got back here  from our URL session up here in line 36 so we're   going to type in data and then a do try you know  requires a catch this error handling and then if  
this fails we will throw again we need another  error we're going to create another error here  
called case invalid good data and then up here  what we're going to throw we're going to throw  
GH air dot invalid data and again all I'm doing  is giving you an example of how you can really  
customize your errors and let the user know  exactly what is going wrong if something goes   wrong if you get this invalid data 90 of the time  the reason this will fail to decode right because  
what this line of code does here is it is trying  to use our decoder here using codable to decode  
the data we got back which again is this Json you  see here into a GitHub user object in Swift that's  
what this whole section is doing now it will  fail again ninety percent of the time there's   many other reasons it can fail because you didn't  match your property names correctly so our Network  
call is written let me run through it again as  a refresher right so we're calling git user we   marked it async so we can use async await we also  marked it throws because we want to throw a few  
errors because again so many things can go wrong  in a network call and we're returning a GitHub   user and we need to know what endpoint to pass it  to right right so this is the user's endpoint and  
again where I got that from was the GitHub rest  API documentation I want to get a user like you  
see here on the left and you can see the URL for  that that I already have highlighted is right here   so the documentation will let you know what URL  you want to point to so back to xcode cool I need  
to create a URL object from this string that's  what we're doing here as long as that's good then  
I use my URL session to get data from the URL  again this is an example of a get request but  
we're just downloading right we're not uploading  anything we're not editing anything we're just   downloading the data and I need to pass a URL that  I created up here on line 32. now this returns a  
tuple of data and response so again the response  is what we talk about first this is all the you  
know 404 not found 500. we want to check to make  sure we have a 200 so we're doing here that means   everything is good to go cool so if we don't get  to 200 we're going to throw the invalid response  
error show it to the user you know handle it if  this is good we go to 200 back now we can work  
with our data here so that's what we're doing here  in this do try catch we create a Json decoder and  
the reason I created it was so I could set the key  to coding strategy and because I want to convert   from snake case right that's this Avatar URL issue  we had here if I didn't have that issue with snake  
case on Avatar URL I would not need this line of  code right here okay and then like I said we try  
to use that decoder to decode the Json into a  GitHub user and from that data again that's the  
Json we got back if that works we're good to go  we're going to return a GitHub user the function   worked properly if we fail to decode we're going  to throw the invalid data error okay so that is  
our Network called written now for step four is to  actually use this network call and connect it to  
our UI to show the final results okay so I'm going  to scroll up here to our Swift UI view remember   this is normally refactored this get user this is  probably in a view model somewhere so it's not as  
messy but again keeping it all in one place so  up to our view here so in order to call this I  
want to below the padding here we'll do a DOT task  now a DOT task is used for as you can see at the  
bottom here adds an asynchronous task to perform  before the view appears it's kind of like on   appear if you're familiar with swift UI but it's  ready to go for asynchronous code for example that  
our async await Network call so that's what I want  to do here I want to call this but I need to set a  
user equal to what we return right we're returning  a GitHub user object but I don't have the concept   of that in my view so we can do that real quick at  State private VAR we'll say user and then it's up  
type GitHub user and that is optional because when  the view first loads we don't have that right we   don't have it until we make our Network call so in  order to call our async Network call here I want  
to do do we'll say user equals try await get user  So This Is Us calling our Network call right here  
so when the view appears I need to have a catch  here let's just put that in there for now we're  
going to handle the errors in a second but yeah so  I am setting the user that I created here and this   is a state variable which means in Swift UI once  my network call is completed and I set this user  
to the user I get back then the UI will update  which we'll get to in a second so I'm setting user  
equals to the result of my network call which  again we went through that I'm doing all that   Parts in the Json setting the user cool so if it  is successful great I set the user to the user I  
get back my UI updates we got to write the code  for that in a second but if it's not successful   here's where I can handle the various errors so I  would do catch GH error dot invalid URL and then  
I would print you know in valid URL catch GH air  dot invalid response and obviously you wouldn't  
just print this you would show like a pop-up or  do whatever you need to do in your app you know to  
let the user know what's going on and then finally  catch GH error.invalid data print and again I know  
this looks long and tedious but hey if you're  going to do proper error handling and showing   the user exactly what's going on it is long and  tedious I could just have one error be generic  
and you're unable to complete the task at this  time please try again later that's not helpful to   the user so you could be lazy and not do all this  that's not very good and then we'll do our final  
catch which is kind of like the catch-all we'll  say unexpected error do command B should work  
okay so like I said this is just an example of uh  handling uh very specific errors okay so now that  
I have my user the final step is to update the  UI to take in the actual user data so for example  
username is not just text username right it would  be user Dot Login and that is an optional so we  
want to provide a default thanks we'll say login  placeholder of course if you're building a real UI  
you'd want to make this look nice some placeholder  now for the bio again user.bio and if that is nil  
we'll say bio placeholder whatever that is for  you and then now we need to handle our Avatar  
URL which for that we're going to do async image  which is nice for Swift UI we don't have to make a  
separate Network call switch your eyes this async  image already built in it does take a URL so we'll   say URL from string and that will be the user dot  Avatar URL and if that is now if our users know  
instead of passing in the Avatar URL or passing  a blank string which will give us a placeholder   that's what this placeholder is right here and  we'll use our Circle here as the placeholder that  
means while it's loading or if the URL comes back  nil then it'll just show that gray Circle again if  
you're designing your UI make the placeholder nice  looking let me actually take out this frame and   put it on the async image itself so I can reuse  that okay so now I get back an image so there's  
just a normal Swift UI image which means I can do  things like dot resizable dot aspect ratio dot fit  
and finally dot clip shape of a circle because I  want it to be rounded okay so to recap basically I  
created the async image which will pull the user's  Avatar URL create an async image from that if that  
doesn't work we'll show the circle placeholder  and then the text I'm using for the login will   be the user's login if that's nil show the login  placeholder same thing with the bio so now when  
I run my preview let's refresh it it should make  the network call there you go sl0400 there's my  
profile picture there's my bio let's try some  other developers here so I just need to change   the username in the endpoint like I said in a  real app maybe the user could type this in you  
know however you want to do in your app but let's  say two straws run it back we should see Paul's   stuff yep there's Paul's profile picture his  username his bio uh John sundo we're making our  
Network call it is working and I know this video  threw a lot at you with writing all the network  
calls the async await throws you know async image  definitely don't be afraid to go back and re-watch  
it like I said at the beginning Network calls are  very tough topic if you're just learning them it's  
going to take you a while you're going to have to  watch many different videos you're gonna have to   hear it explained many different ways you're  gonna have to write 50 of them like this is  
a process and again this video was meant to  be one of your first steps in that process
Classes vs. Structs
a very common iOS Developer interview question  is to explain the difference between classes and  
structs I'm going to teach you the answer to that  question by explaining value types and reference  
types and I've got a nice little analogy  using Google Sheets in Microsoft Excel to   help you remember and then I'll teach you when you  should use classes and when you should use structs  
classes and structs are both ways to create  objects in the Swift programming language as   you can see here I have a class called car which  is creating an object the car has a year make and  
model more realistic examples in an app would  be something like a user or a product but for  
the sake of explaining this concept we're going  to stick with our simple car so the main answer   to this interview questions on classes versus  structs is that classes are reference types and  
structs are value types what does that even mean  well let's write some code to show you an example   so I have my car class here let's create a car  we'll say VAR my car equals and I'll initialize  
the car you can see I need to pass in a year make  and model so say 2022 make Porsche color gray  
so I've created a car with the year make and  color because this is a class this is a reference  
type what that means is that it's a reference or  pointer to specific data so for example if someone  
steals my car right so if I do VAR stolen car  equals my car right so I took this my car object  
and set it equal to stolen car well now I have  two variables again it's a reference they're both  
pointing to the same piece of data which is this  car here so on the stolen car if someone wants to  
make you know my car a different color it's going  to affect the original my car let's see this here   so if I do stolen car dot color equals yellow and  then if I do print my car dot color you notice I'm  
not printing stolen card.color I'm printing my  card.color if I run that you're going to see my   car.color prints out yellow and this is where the  Google sheet analogy will help you remember this  
so the way a Google sheet works right you share  the sheet with multiple people and then when   multiple people make changes to that one source  of truth right they can all make changes to that  
Google sheet it's a shared document that's kind of  how reference types work again I change the color  
property on the variable stolen car but it also  changed the property of color on the variable my  
card that's demonstrated on line 18 by printing  out mycard.color so again classes are reference  
types and if you create multiple variables of the  same class they're all going to point to the same   piece of data and if you change that piece of  data on any one of those variables again we  
have my car and stolen car is going to change  that property for all of those variables that   are all pointing to that same piece of data that  is a reference type now let's talk about structs  
and value types so I'm going to copy this class  here and then I'm going to comment it out just   so you don't lose all the code here and then we'll  paste that in here instead of a class being a car  
we'll do a struct of a car and then trucks have  member-wise initializers that's another topic so  
I don't have to have that in it and I have my  struct of a car same thing again they're both   ways to create objects in Swift but structs are  value types remember classes or reference types  
structs are value type types when a value type  gets passed around it is copied and this is where  
the analogy of the Microsoft Excel spreadsheet  comes in right if I have my own Excel spreadsheet   I made all my changes to it I save it I make a  copy of it and I email that copy to you well now  
when you get that copy that's yours you can make  all kinds of changes to that spreadsheet you can   do whatever you want to it it is not going to  affect my original file version so that is the  
analogy for Value types where again reference  types was like a Google sheet where everyone   can make changes to the one source of Truth let  me demonstrate that in code so I'll come up here  
copy the my car variable what kind of gonna do the  same example but you'll see now if I do VAR stolen  
car equals my car well now that it's a struck  that basically just made a copy of my car and  
assigned it to the variable stolen car so now if  I do stolen car.color equals we'll say red now now  
when I print my car dot color again my car was the  original object that I created it is still going  
to be gray right help right that's how it should  work run it great there it is right and if I did   print stolen card.color now it's going to print  out red because again struct is a value type so  
it created a copy of my car and assigned it to  stolen car we're again as a class to reference   types all pointed to the same underlying data  now let's talk about when you should use a class  
versus a struct in the pros and cons of both  a benefit of classes is that they have what's  
called inheritance which means I can subclass or  car class up here I can create a subclass of car  
maybe called race car that inherits all the basic  properties of a car right our year make color but  
I can also add more properties to that right  I can maybe add a number right race cars have  
numbers and a team race cars have teams so you can  see it gets all the basic car stuff but I can add  
on the unique stuff that a normal car doesn't  have but a race car would have that's called   subclassing and when you subclass you inherit  everything in the parent class another common  
example and I'll show you some documentation that  will help out here is if you say class my custom  
button and that inherits from UI button and  if I option click on UI button I'll go to the  
documentation so when I make my custom button  I don't want to reinvent the wheel everything   Apple has done to make a button work like look  at all this stuff in the documentation that you  
you get customizing color Edge insets you know  setting the title I'm going to go down to the   bottom here of all the properties that are on  it right set title title color all the stuff  
that Apple has built in a button you inherit  when you create your custom button and then  
now you just add differences you want to make to  make your button custom maybe you want it to be a   circle and always be pink who knows but that's  what you can do with inheritance you can build  
on top of the UI button now that sounds like  a really cool benefit but as you can imagine  
when you're inheriting everything of a UI button  which also inherits from UI view you're starting  
to inherit a lot of bloat and extra baggage  you may not need so that is where structs   come in and value types if you don't need all  that inheritance you can just use a struct and  
that's why trucks are a lot more lightweight and  performant and if you've written Swift UI you'll   notice a lot of Swift UI is built on structs  for that exact reason right a swift UI view  
is a struct so it can be created and redestroed  all the time and it's not so heavy so when you  
need an inheritance or you need a reference type  that's when you go for a class when you don't need   inheritance you want something lightweight  and performant then you go with a struct
Generics
generics can be intimidating and confusing angle  brackets single letter types protocol conformance  
what's going on here this video teaches you what  generics are with a basic and real life example  
and then we'll talk about The Balancing Act you  have to do with generics because once you learn   them you're going to want to use them everywhere  but you can easily add unnecessary complexity to  
your code so let's make sure you don't do that  generics can eliminate co-duplication by creating   a general solution that can handle various types  here's an abstract example to help illustrate the  
point let's say you have a function that can drive  you home from work this function will work no   matter what the vehicle is right it doesn't care  it could be a motorcycle a cyber truck a Porsche  
911 GT3 as long as it has a motor and wheels the  function will work it doesn't care what type of  
vehicle it is so you have the drive home function  and then you have the angle brackets with the T   colon and drivable in the middle so this is  a protocol conformance or a constraint on the  
generic so inside the angle bracket we call the  generic something right now we're calling get T   that is convention to use a single letter variable  typical T sometimes U sometimes V you could if you  
wanted to like name it vehicle as you see here  but again common convention is to just use the  
single letter T so we're calling our generic  T and then after the colon we're constraining  
it or we're telling it what protocols it has to  conform to so like I said our function will work   it doesn't care what the vehicle is as long as it  has a motor and wheels and that is our protocol  
drivable so you see drivable here requires a motor  and wheels and you see our function takes in the  
parameter called vehicle which is of type T which  again is our generic T can be any type as long as  
it conforms to drivable so a quick example you see  I have a Porsche 911 GT3 object and a motorcycle  
object both of them conform to drivable they  both have motor and wheels and then you can see   I create a 911 by initializing the Porsche GT3 and  I create a motorcycle by initializing motorcycle  
and you can see I can use my function here by  passing in either the 911 or the motorcycle  
the function function will work it doesn't care  what actual type it is as long as it conforms to  
drivable that was a high level example just to  introduce you to the topic if you weren't quite   following we're going to dive in deeper so let's  write a basic example all from scratch to practice  
this concept we'll create a function called  determine higher value and if we want to make  
it generic that's where the angle brackets come  in and like I said we're calling our variable t   or our generic T and if you just wanted to take  literally any type no constraints this is enough  
but we do want to constrain our generic and again  all constraining your generic means is it has to  
conform to a certain protocol so we're going to  conform to the comparable or comparable whatever   protocol so again we'll take any type as long as  it conforms to comparable and then we're going to  
take in two parameters here we'll say value one  is of type T and then value two is also of type  
T so they have to be the same type right I can't  compare an INT and a string have to be the same  
type and now we'll determine the higher values so  we'll say let higher value equal we'll do a turn  
every operator here value one greater than value  two if that is true value one will be the higher  
value and then if not value two there might be a  better way to write that that looks repetitive but   whatever not the point so we'll say print higher  value is the higher value and you'll see us use  
this okay so again let's walk through the function  signature we're determining the higher value we're   saying hey we want to take in a generic well we're  going to name that generic T and then we're going  
to constrain that generic it has to conform to  comparable okay cool and then we take parameters   whatever parameters you want value one that is of  type T and value two is of type T so they have to  
be the same type so let's see this in action so I  will say determine higher value of you know three  
and eight and then if I run it you'll see 8 is  the higher value cool that was an INT now let's  
do strings of Sean and so by the way strings  are alphabetical order when you compare them  
so do that it'll say Swift is the higher value  because Swift comes after Sean alphabetically  
so again anything that's comparable we ins floats  doubles strings even like look dates so I can do  
date dot now or I can do I don't want to create  a whole date so let's do date dot distant future  
right so the distant future date should be the  higher value so I'm going to play this and we'll   see year four thousand and one so January 1st  4001 is the higher value than right now okay  
so like I said you're passing in strings in  doubles it doesn't matter this function will  
work as long as it conforms the comparable now if  I try to compare a date to a string like that's  
not going to work you'll see me get an error so  it does have to be the same type again that's why   we're designating it t here but as long as they're  the same type you have this one generic piece of  
code that can handle various specific types and  generics are all over the Swift language behind  
the scenes so look at something you use all the  time in an array so I'm going to say let number   array and I'm going to declare it like this  so I can dive into the documentation say array  
repeating let's say I want to repeat the number 3  10 times and you'll see over here right there's my  
array all the threes but the reason I did this  because I want to dive into the documentation   on array so if I option click on array open in  developer documentation you can see right here  
the Declaration array has a generic of an element  so what that means is if I have an array of ins I  
can still do things like numbers array actually  I have to make numbers array a VAR if I'm going   to manipulate it here numbers array dot append  new element and you can see it knows it's of  
type int right here so if I append a 4 I can  do that to the numbers array now let's do VAR  
string array equals array again repeating here  this time we'll repeat Sean and we'll just do it  
five times so now I still have this dot append on  array right I don't have to have a specific a pen  
function for Strings and a specific a pen function  for INS because in our array is a generic of type  
element I can do append count first of all the  stuff arrays have no matter what the type is  
whether it's an INT or strings right so I can  do string array dot append and we'll say Swift  
right and that will still work and then again  back to the documentation that is because array   is a generic of type element so again generics  all over the Swift language behind the scenes  
now let's look at a real life example from an app  I built for my course GitHub followers the app we   pulled down a list of followers you can tap on  a follower to see their information so we have  
a network call called Fetch user as you can see  here now I've removed all the air handling and   the response validation to make this super simple  code just know that if you're not familiar a real  
Network call is much more involved than this  but again stripped it away for Simplicity of   generics so this is not a generic function right  we're calling fetch user from URL it returns a  
specific type of user and then you can see down  here in the do try catch we're decoding user.self  
so this network call is very specific to users  however it is very common in an app to make a  
network call to fetch an object and then decode  it using codable very very common like here's   another example if we were going to do fetch  repository you can see very similar code fetch  
repository it returns a repository type we make  the network call we decode it using decodable or  
repository.self it's the same code just swapping  out user for repository so instead of writing  
separate Network calls for for each specific type  we have right this is only an example of two what   if we had five different types we were doing we  can make this generic as you see in this function  
signature again the angle brackets after fetch  data we call our generic T the constraint we put  
on the generic and again the generic constraint is  just making it conform to a protocol we want it to   conform to decodable because we're fetching data  from the server and we're decoding it we need to  
pass in the type this 4T DOT type because we need  to you know let the network call know which type  
it's going to be and then we pass in the URL  and then you can see we're returning T which   again is whatever type we pass in that conforms  to decodable and then you see the code is the  
same right we make our URL session share.data  make the network call in the do try catch we're   decoding it but instead of user.self or instead  of repository.self you can see it is T dot self  
so we're making the T the generic so we can pass  in a user a repository or whatever other object we  
have again as long as it conforms to decodable  now that you understand the basics of generics  
let's talk about The Balancing Act because once  you learn this skill you're going to want to put   generics everywhere right every little bit of  repetitive code you're going to want to make it  
a generic or the dreaded trap of oh let's future  proof this in case we write more Network calls  
like this spoiler alert most of the time when you  future proof that Future Never Comes that's called   premature optimization and you should avoid it  because adding generics everywhere can really  
add unnecessary complexity to your code so here's  my advice only use generics when it's like a slam  
dunk use case in my opinion even going back to our  Network calls and GitHub followers we're fetching   a user or fetching a repository that was only two  Network calls that were exactly the same even if  
there's only two I wouldn't use a generic because  concrete types are way easier to read way easier  
to understand what's going on now like I said If  instead of just a user or repository maybe you're  
fetching a project or you know five other things  from the GitHub API and now you have five or six   of these Network calls that are all the same to  me slam dunk case use a generic that's awesome but  
again if there's only one little bit of repetition  don't automatically throw generics at it you're   just over complicating things we just scratched  the surface on generics they're a very deep and  
Powerful topic but hopefully this video gave you  the fundamental understanding to start you on your   journey of learning generics and help you answer  that pesky interview question about generics
Closures
what are all these parentheses what's up with  these dollar signs escaping like who are we  
running from trailing closure syntax what does  that even mean look closures are tough these  
are all things that confuse the hell out of me way  deeper into my career than I'd like to admit let's  
make sure you understand closures a lot faster  than I did closures are self-contained blocks of   functionality that can be passed around and used  in your code to put that simply they're functions  
that can be passed around to illustrate that let's  create a closure and put it to good use here I am   in my xcode playground all I have is an object  of a student that has a name and a test score  
and then I have an array of those student types  we're going to create a closure to filter out the   students by their test score VAR top student  filter and that is of type now of type is the  
key word here to explain this because just like  our student has a name that is of type string a   test score that is of type int our closure is a  variable that is of type and this is where the  
parentheses come in it's essentially the function  signature so I'm going to type this out and we'll   walk through and explain it so you get one set of  parentheses and then the return type is the other  
set of parentheses and that equals and then the  actual curly braces to define the scope so let's   walk through these parentheses one by one because  I know this confused me greatly when I was first  
learning closures so the first set of parentheses  is any parameters the function takes in however we  
don't need to name them we just need the type so  we want to take in a type of student now of course  
if you're doing something with an INT or a string  that's where you would pass this in we're dealing   with our custom type here of student so that's  why we passed in that and then this is going to  
return a Boolean I'm going to back up and explain  this real quick because you may have seen you know   sometimes it doesn't return anything so you may  see empty parentheses or sometimes if it doesn't  
return anything you can see void as well those  empty parentheses and void are the same thing   just two different ways to say it in our case  we're going to pass in a Boolean because this is  
a filter we're going to look at our student and if  our student has a score of greater than 80 we're  
going to return true that means there are top  students so that's why we passed in a student and   returned a Boolean we just want to check if they  have a score greater than 80. so return student  
but we can't do this quite yet we're missing a  piece here where we need to name our parameter   here student in you've seen this before so this  is basically the parameter name so we can use it  
down here in the scope of our closure so I can do  return student DOT test score I don't know why the   audio complete's not cooperating but greater  than 80. let me run it real quick just make  
sure I didn't miss anything should be good cool  everything's good to go and actually maybe this   will help let's write this as a function so you  can compare the two because I'm assuming you're  
familiar with functions a bit so I just copied and  paste that so to write a function right it's Funk   top student filter I'm going to put an F after  it for function and then instead of having all  
this right here I'm just going to go ahead and  delete that right you would say hey this takes in   a student of type student it returns a Boolean and  here's our scope and we would say return student  
DOT test score greater than we'll say 70. so to  compare the the function and by the way these  
are very similar you can even use the function  you'll see we'll do that in a second but I just   kind of want to put these side by side so you can  see how similar it is like I said it's a property  
with the name of type just like you know string  and int the type here is the function signature  
right it takes in a type of student and returns a  bull that's what's going on here type of student   returns a bull and then here the student is what  we named it we can name it whatever we want just  
like we can name this parameter name anything we  want and then you see obviously in the scope is   basically the same so hopefully that clears up  what these parentheses are when you see that in  
the closures again it's just any parameters and  what it returns just like a function parameters   and what it returns so now that we've defined  our closure up here in top student filler filter  
filter has a t there we go but anyway now that  we have our closure we're going to pass it around   using our variable so let's do that let's say let  top students equal students by the way students  
is our array up here this is our array of all of  our students dot filter and you can see our filter   takes in a closure and just like we said here is  the type taking a student and it returns a Boolean  
so the only way we're going to be able to pass in  our closure is if it matches that perfectly right   takes in a student and returns a Boolean let's  say our closure up here had a student and an INT  
right by the way they say you can have multiple  types maybe student Dash age if you had multiple   types in your closure I guess would be multiple  parameters now our closure wouldn't work because  
it doesn't match exactly so I'm going to delete  that because I want it to work so now I can just   pass in top student filter and now let me paste  in a quick little for Loop to save some time  
just basically just prints off the student name  we'll run it and that filter should work yes we  
have Luke lay and Ahsoka those scores have to  be greater than 80 right Luke has an 88 Leia 95  
Ahsoka and 86 so our filter is working by passing  in our closure there again closure is a function  
that can be passed around and this is a lot neater  than if we wrote it out so let's demonstrate that   well real quick let me demonstrate how we can also  pass in this function so let me do top student  
filter with a capital f at the end right that's  what this is up here and then now when I run it  
were greater than 70 this is why I did this  so we can differentiate so now when I run it   I should get a longer list of students which I do  because more students up here are greater than 70.  
so again whether it's a property or a function  very similar a closure is a function that can be  
passed around and used now that you've seen that  let's start talking about shorthand and what all   these dollar signs mean so I'm going to rewrite  this filter here or I re-autocomplete it here so  
filter is included so as you can see this is going  to give me a closure that takes in a student and   returns a Boolean if I hit return I get a little  bit of the shorthand and it automatically goes to  
Trail enclosure syntax which we'll talk about  more in a little bit but the introduction if I   do command Z Trail enclosure syntax is when you  can omit this argument label when your closure  
is the last argument we'll talk a lot about that  in Swift UI because Swift UI uses that heavily a   little bit more in the video but our closure is  our only parameter so of course it's our last  
parameter so when hit return we get trailing  closure syntax which is omitting the parameter   names in the parentheses and just going right into  the body of the closure like that so now we have  
our argument name and we don't have to define  the type the reason we don't have to define the   type is because it knows this running filter on an  array of students right our students array right  
here has Type inference it knows it's an array of  students it's not an array of strings not an array   of doubles or anything like that it's students so  that's why we don't need to define the type and we  
can just call this whatever we want you can see  the capital S for student means it's the student   type we're going to name it lowercase student  just as the name again we could have named this  
person right you can name it whatever you want  student obviously makes the most sense but we   know it's of type student so here we can write  the same code so I'm using simple one lines of  
code but obviously this could have been 40 lines  it could have been super complex filtering code   that is why you might not want to write it out  all at once you might want to put it away into a  
property so it can be reused passed around very  easily versus right now I'm writing it out like   on site within the scope of the filter again it  looks fine right now because it's just one line  
of code but I want to use this simple example to  show you the shorthand these parameters come with   a built-in shorthand syntax you've probably  seen dollar sign zero or dollar sign one  
what that represents is each parameter here so  right now we only have one so it's dollar sign   zero in a second I'll show you an example where we  have dollar sign zero and dollar sign one so how  
I can slowly make this shorthand is if I don't  want to use the actual named property here get  
rid of that and get rid of the end and then now  instead of student down here I can replace that   with dollar sign zero because I only have one  argument there is no dollar sign one it's just  
dollar sign zero so I know that's the student  and now when we only have one line of code we   can omit the return and if we're going to omit  the return we can put this all on one line to be  
nice neat and clean so that's your introduction  to the shorthand and with the dollar sign zero   and the dollar sign one is so right now we just  have top students we filtered out all the top  
students based on if their test score is greater  than 80. now let's actually sort this so you can  
see an example of dollar sign zero and dollar  sign one and just more repetition on closures   because again closures are tough so let's say let  student ranking equal top student so we only want  
to take the top students dot sorted by and here  again you can see this is an example when we   have two of these parameters we have student one  and student two and it returns a Boolean so if  
we were to write a closure for this one we would  have to make sure we had two students in it right   so we'd have to be student student and then of  course we would write different logic to do all  
the Sorting here but like I said I just want to  point out that oh and we would also here have to   have student two but I wanted to point out that if  you are going to use a closure in a built-in like  
sorted or filter it has to match exactly or if you  wrote a function yourself it has to match exactly
so I'm gonna do a command Z to get our closure  back to that and I'm gonna hit return and walk   through that shorthand again so like I said you  could have student one student two and then do  
return student one dot test score greater than  student2 DOT test score and this will sort them  
based on Whose test score is higher but again  back to the shorthand we don't need Student one   student two I know that is dollar sign zero and  dollar sign one so we can get rid of that to make  
it cleaner and then I'll replace student one with  dollar sign zero and student two with dollar sign  
one now if you add three or four parameters up  there it'd be a dollar sign two dollar sign three   and so on like I said before we don't need the  return so we can put this on one line and there  
you go so like I said if you've seen a lot of  these closures with the dollar signs and dollar   sign one dollar sign two those are essentially  shorthand Syntax for each property like we  
just showed with the student and student one and  student two I hope that cleared up all the dollar   sign Syntax for you I know that was confusing  for me as well when I was starting out let's talk  
about trailing closure syntax before we get on to  to escaping let's go to a swift UI project to see  
how this is everywhere in Swift UI here I am in  my course called dub dub grub by the way you can   check this out Sean allen.teachbowl.com if you're  interested if you've ever written a v-stack or an  
htac in Swift UI you've used trailer enclosure  syntax and if you've written a lot of Swift UI   you've done that many many times so let me explain  that here I am in just a basic little button let's  
say I wanted to put this text in a v-stack so  I do that v stack cool now when you wrote the  
v-stock you just did open curly brace closed curly  brace and you probably thought nothing of it if   you didn't understand Trail enclosures but that's  what it is it's a trail enclosure so let's talk  
about what a v-stack really is so if I do v-stack  hold option to get all the parameters there right   they're just optional and Swift UI is riddled  with optional parameters and default values I'll  
show you that in a second but what I want to point  out to you is cool here's a parameter you can dot   leading spacing we'll say 10 but look what does it  end with it ends with content and what does that  
syntax look like to you that looks like a closure  and the closure is the last argument so we can   omit it and just do the trail enclosure syntax  which is is going right into the body of the  
closure the braces and real quick to show you if I  command click onto the v-stack jump to definition   go to the init here you can see the alignment  has a default value of Dot Center spacing default  
value of Nils like I said default values are  everywhere in Swifty that's what allows that clean   syntax and here you go does this look familiar  We'll add view Builder that's a different topic  
but you can see the last argument is the content  that closure looks familiar right it takes in no  
parameters and it returns of type content so back  to the v-stack real quick that is why we can get  
rid of this and that's why you can write a v-stack  which is a simple v-stack open curly brace close   curly brace Trail enclosure syntax all over Swift  UI if you've ever written a network call prior to  
async await you've dealt with completion handlers  or closures they're the same thing let's take a   look at this function signature for get followers  by the way this goes up to the GitHub API pulls  
down a list of followers to display on screen okay  so parameters username page completed though this  
is the closure here and it's marked at escaping  we're going to talk about what that means but   to review the closure right our closure takes in a  result type and the result type returns a follower  
or GF error and then it returns void so it doesn't  return anything so again like I said this could   easily be just closed parentheses same exact thing  but why is it marked at escaping well the closures  
that we were doing before like when we were  filtering the students those happen instantly   right they get called right away they happen  right away no big deal on network calls this  
fires off and it goes up into the cloud to GitHub  API and depending on your network right it could   be super slow it could take 10 seconds could take  a millisecond maybe you're not even connected to  
the internet could take forever so what escaping  does is it allows the closure to live on past the  
lifetime of the function that called it speaking  of the function that called it let's actually go   look at that so on the follower list VC which is  that screen you can see here in the get followers  
function I call networkmanager.share.getfollowers  and again as you see here we're using the trail  
enclosure syntax because that is the last  argument in the function but what happens   get followers fires off and then that function  is done however the closure is still living it  
outlives the function because it is waiting to  get the information back from the network call   so that is why you mark it at escaping so it can  live on past that now this is where things get a  
little tricky with retain cycles and memory  leaks because most of the time when you do   a network call you're capturing a reference to  self because once you get that list of followers  
back whether it's 10 seconds later 15 seconds  later one second later you have to update the   UI on the phone so our closure still has to have a  reference to whatever called it in this case it's  
a view controller in UI kit so that's why you got  to be careful with Escape enclosures we marked it   weak South here so it's a weekly held reference  so it can break that gets into memory management  
automatic reference counting all that stuff that's  a whole another topic I have a video on that I'll   link to that in the description if you want but  that's what escaping means essentially the closure  
has to live on past the life of the function that  originally called it if this was helpful and you   enjoyed my teaching style check out my courses at  shawnis.teachable.com see you in the next video
Filter, Map, Reduce
we're talking about filter map reduce I'll show  you how to chain them together then we're going  
to talk about compact map and Flat map a good  way to think about these higher order functions   is they are shorthand Syntax for a basic for  Loop filter map and reduce iterate over an array  
and spit out their results into a new variable  so I'm going to need an array so I'm going to  
copy and paste that here as you can see I have  an app portfolio of my object here of an indie  
app which has a name monthly price and users and  as you can see I've created four Indie apps with  
different names monthly prices and number of  users and thrown them into an array called app  
portfolio this is the array that we're going to  use with the examples on filter map and reduce   let's dive into filter first so let's say I want  to filter through my portfolio of Indie Ops and  
pull out the free apps so right now fit hero with  the monthly price of zero is the only free one so  
let's say let free apps equals say app portfolio  so this is the array that I'm going to iterate  
over dot filter and you can see it takes an  enclosure and a simple way to write this is   with a trail enclosure I'll explain that in a  second so we'll do dollar sign zero dot monthly  
price equals equals 0.00 a brief explanation of  this Trail enclosure is the dollar sign zero it's  
every item in the array for example the first  iteration over the app portfolio array is the   Indie app creator view dollar sign zero the second  iteration equals fit hero dollar sign zero over  
the third iteration equals buckets and so forth so  it's going to check every element's monthly price  
and if it is equal to zero it's going to spit it  out into this free apps array so when I come down  
here in print free apps in the console down here  you should see just fit hero print out Indie app  
fit hero monthly price of zero but the way Filter  Works is you just need to pass in a conditional   so this has to equate to true or false as you  can see it equals equals zero or not so let's  
try another one uh users let's say if users  is greater than 5 000 and instead of free apps  
we'll call this High users right I don't want to  filter all my apps by which ones have high users  
so now when I run it you should see the array  here buckets has 7598 users Connect Four has 34  
000 users so again it filtered out all the apps  with high users based on this conditional that I  
passed into the filter and as I said in the intro  these are basically shorthand Syntax for for Loops   you could do the same thing by doing this very  basic for Loop here right you have an array  
called high users you go for app in-app portfolio  so it's going to iterate over all these apps it's  
gonna say if app.user is greater than 5000 go  ahead and append that app to the high users  
array up here and then we'll print out High users  if I print this again we should see the same thing  
buckets and Connect Four same thing we just got so  essentially what filter is is a way to take these  
you know whatever five lines of code we'll delete  that and to put it into a nice one-liner all right   now let's talk about map so a very common use of  map is to pull out all of a specific property so  
let's say I wanted to pull out just the names  of the Indie apps put them in a list and sort   them alphabetically so say let app names equals  app portfolio dot map and then again you pass in  
the closure dollar sign zero dot name and then now  if I print app names I'm going to comment out the  
filter print so we don't jumble up the console  here and get confused here so print app names   you see Creator view fit hero buckets Connect Four  so again map went in just pulled out all the names  
I could have pulled out all the prices I could  have pulled out all the users and put that into   its own array and then now that you have that into  its array you can also dot sorted right and then  
now that will put it in alphabetical order so you  can see pulled out all the names of the array and   sorted them in alphabetical order let me actually  run it it see buckets Connect Four Creator view  
all in one simple line of code so again shorthand  Syntax for basic for Loops now that's the example  
of pulling out a specific property but let's say  I wanted to add a transform to that property let's   say I wanted to do increased prices so I can  do app portfolio map over that array instead  
of dollar sign zero dot name I'm gonna do dollars  on zero monthly price but I want to multiply it by   1.5 say I want to pull out all my prices and then  also multiply them by 1.5 so another aspect of map  
is it'll iterate over that and apply a transform  or an operation to each element so now instead of  
print app names I'm going to print increase prices  we'll run it and you're going to see an array of  
all my prices that have been multiplied by 1.5  if I were to increase them okay on to reduce and  
then we're going to start with a super basic  example and then I'll show you a little more   we can do so super basic let's say let numbers  equal I don't know 3 5 9 12 18. so what reduce  
does it will reduce all these value values into  one and the most common way that you use reduce   is to you know sum up an array so say I wanted to  get the total sum of all these numbers so say let  
sum equal numbers dot reduce and then reduce has  a very tricky autocomplete but again you can pass  
in simple closure here so we do a starting value  so I have an INT so I want my starting value to be  
zero we're going to come back to this in a second  and an operator so I'll do plus so the plus means  
I want to sum them all up so now if I print sum  and then let's comment out increase prices so we  
don't clutter up the console now when I run that  you will see the sum of numbers is 47 1812 395 is  
47. now again remember the initial value was Zero  let's say I wanted the initial value to be 100 so  
now it's going to add basically an add 47 to 100  so I get 147. so you can start with an initial  
value and then whatever you want to do now let's  say I wanted to subtract the total of this array   from 100. now instead of the plus I do a minus  now it's going to be 100 minus 47 which as you  
can see is 53 down there so the simplest version  of reduce we're going to do a little more complex   version in a second but the simplest version of  reduce again you start with an initial value and  
then you add an operator in here okay now let's do  a little more complex example let's say in my app  
portfolio I want to get just the total number  of users right I want to add up all the users   from each of my Indie apps so here we can do let  total users equal app portfolio again that's this  
array up here that we've been working with DOT  reduce and again the initial value we want to   start with zero and then now we want to pass  in another closure to add these two together  
so we do dollar sign 0 plus dollar sign one I'll  explain this in a second dot users and then here  
we will print total users so this operation we're  passing in here again remember I told you dollar  
sign zero is the placeholder for each iteration  through the array dollar sign one is the next   iteration so you're adding those two together  so when you're adding them up you're adding  
here in Creator view you're adding four three five  six two one seven five six then you're adding that  
to seven five nine eight so that you're going  through and adding those together that's what   the dollar sign zero and dollar sign one mean so  when we print total users we're gonna get that  
number again let me comment out some and it's  forty seven thousand seven hundred ninety one   that is the total users of all my app and again we  went through and reduced just the user's property  
of the app portfolio down to one variable called  total users now let me show you how you can chain  
filter map and reduce together to do some complex  calculations all on one line now a little caveat  
here this can get a little uh messy if you take  this too far so always consider code readability  
versus trying to get everything on one line  that's my caveat but I just want to show you   an example of what's possible and I'll let you use  your judgment on what's readable code and what's  
not so let's try to figure out a recurring monthly  Revenue so each of these apps has a monthly Price   Right 11.99 399 and they have a number of users  so monthly recurring revenue for each app is you  
know monthly price times number of users but we  want to get the total for a whole portfolio not   just each app so we got to do some combinations  here so for chaining we can say let recurring  
Revenue equal app portfolio dot map so the first  step we're going to do is for each item in the  
array we're going to multiply monthly price times  dollar sign zero dot users now we have a little  
issue here because if you look monthly price is a  double users is an INT so we're gonna have to cast  
our int to a double so we can multiply that once  we've mapped each of our apps recurring Revenue  
again monthly price times users then we're going  to tack on or reduce at the end of that to total   up that array to get our total monthly recurring  revenue for our whole portfolio that's the process  
that we're going to do here so what it's saying  here is I need to make this a double so we can   cast the dollar sign users to a double so now  if I print just to show you these steps here if  
I print recurring Revenue that's coming out total  users so if I print recurring Revenue we're going   to see is an array a of the recurring revenue  for each app so this is Creator views recurring  
Revenue fit Hero Zero you know buckets was thirty  thousand Now by tacking on our reduce I can sum up  
this total to get the overall portfolio recurring  Revenue again you can just chain them so the map  
like I said spits out its result into a variable  well that variable can be held like temporarily in  
memory if you tack on another reduce here and then  we want to start with zero and then this is just a   simple version right we just add the plus we want  to sum that up so what happens is we map out and  
get each app's recurring revenue and then we tack  on or reduce at the end and then the result of   that we will get spit into recurring revenue and  then we're going to print out recurring Revenue so  
if I run this this should spit out one number  for my overall apps recurring Revenue so 150  
000 for my app portfolio and if you wanted to  know what it's going to be after Apple's cut   you can you know multiply each one by 0.7 because  that's all you're going to get or if you wanted  
to account for taxes all that stuff so now we're  taking each app's recurring Revenue so multiplying  
it by 70 because that's you know the developer cut  then we're reducing that run it again now we're   150 Grand a month turned into 105 000 a month so  like I said you can combine Maps filters reduces  
but as you can also see this code gets to be uh  quite unreadable especially to newer developers so  
like I said be careful with this power but just  you know they can be combined and for certain  
situations it makes for a super clean one-liner  but it can get out of hand now let's talk about   compact map and Flat map these are relatively  new additions to to Swift I shouldn't say I'm  
getting old it's like Swift four point something  but they weren't around from the beginning so to   put these really simple what compact map does is  it removes Nils from an array let me show you an  
example we'll say let nil numbers which is an  array of int but they're optional right maybe  
you know in your array you have one nil 17 nil  three seven nil 99 right for some reason when  
you get in Array you can either have new or a  number but when you want to use this array you   just want to get rid of all those Nils and only  deal with the numbers so to do that let non-nil  
numbers equals nil numbers dot compact map and  then you just pass in the closure of dollar sign  
zero and then now if I print non-nil numbers let  me comment out recurring Revenue run that print  
the non-nil numbers you can see I get 11737.99  just got rid of the Nils so again the simple way  
to remember compact map is it filters out the Nils  now for flat map again a simple way to remember   this is that if you have an array of arrays it  flattens them into a single array let's take a  
look let array of arrays and that is going to be  up type an array of int so let's say do an array  
of arrays equals and I'll keep these shorts keep  the typing to a minimum so you see I have an array   of arrays right each array is one two three four  five six seven eight nine so what flatmap does is  
let's say let single array equals array of arrays  Dot flat map and again dollar sign zero so now if  
I print single array let's run that and you can  see it took one two three four five six seven   eight nine and put it all into one array where it  had an array of arrays so you can imagine if maybe  
you have a bunch of different groups of numbers  and you gather them all together into array and   you're like I don't care about each array I just  want to know the total there you go flat map is  
there and let's say before you flatten the array  you want it to do something to the array well you   can do that in the closure here so you can do  a map and then pass in another closure again  
we're getting into some complex examples let's  say dollar sign zero times two so I'll tell you   what this is so within the flat map I passed in a  map to where each item in the sub arrays the one  
two three the four five six the seven eight nine  I want to multiply those by two right I want to   double those and then after I double them flatten  that into a single array so now when I print  
single array instead of one two three four five  six seven eight nine you're gonna get all those   numbers in a single array but doubled so run that  should get two four six eight ten yep there you go
Array vs. Set
when you need a collection of something in Swift  You instinctively reach for an array don't you  
stop it stop and think would a set work here  because if it does you get some serious benefits  
like much better performance and some really  powerful methods to help you compare different   sets today you're going to learn the differences  between sets and arrays and when you should use  
each which is a very common interview question by  the way as well as some superpowers of sets that  
you probably didn't know about let's compare  sets versus arrays both are collections but   here are the key differences an array can have  duplicate items in it for example if you had a  
list of first names in a class you could have the  same first name more than once an array is always   in the same order that example of students in a  class again this array you see here that order  
is not going to change unless you do something  to change it of course every time you access   the students array that order is going to be the  same that's why arrays are less performant than  
sets is because it keeps that order anytime  you want to look up an item in the array or   do any manipulation on the array it has to check  every item in that array so the time complexity  
is O of n which basically means as the array goes  larger and larger and larger the longer it will  
take to do the these lookups or mutations the  key differences for a set are that it can have   no duplicates so like that student's example  where we had multiple first names well the set  
nope you can only have one of each item sets are  also unordered so anytime I access this student  
set that order is not guaranteed I'm going to  get a different order every time probably now   you may be thinking well having duplicates  and having everything always be in the same  
order those are really desirable attributes of an  array but again remember the trade-off that makes   arrays less performant whereas a set when it's  unordered everything is unique and everything  
in a set has to conform to hashable and this  allows for constant time lookup so remember the   array if you wanted to look something up or or  map over the array the time that takes will be  
proportionate to how large the array is whereas  a set whether the set has 10 items in it or 10   000 items in it that look up time will be the  same will be constant time so if you're dealing  
with small data you know there's only 10 to 20  items in an array it's probably irrelevant but   if you start dealing with really large arrays  this is something you must know these are the  
key differences you need to know between a set  and array but sets also have some really cool   methods I'm going to show you so not only do you  get better performance with a set you get these  
really powerful methods that help you compare  and pull out data from various sets let me show   you some examples in code here in my playground  I have four different sets as you can see I have  
one called Swifty wide devs Swift devs kotlin  devs and experienced devs and you can see some   of the names overlap so imagine we have lists of  various developers that have these qualifications  
and we want to compare these sets to pull out you  know common items or make sure one group is not  
in another group now of course these examples are  real simple there's only two to five names in it   but as I'm doing these examples imagine you had  a set with a thousand names in it first up let's  
see where two sets overlap for example I want to  see experience devs and Swift UI devs now you can  
probably tell just by looking at it right now that  Sean is the only one that overlaps but let me show   you the code to pull that out again imagine  you had a list of a thousand names you know  
you wouldn't be able to just look at it so we want  to say let experienced Swift UI have equal Swift  
UI devs that's this set here on line three we can  say dot enter section of you can see you pass in  
another set experience devs so what this is going  to do is it's going to see where the overlap is  
between an experienced devs and Swift UI devs and  it's going to put it out into its own set here so  
if I run this you can see over on the right the  only one is going to be in there is Sean because   that is the only one that is in Swift UI does and  experience devs so like I said if you got a list  
of a thousand names you wanted to see which names  are on both lists simple little one-liner to pull  
out all those names again this is the the power of  sets and I have a bunch more examples to show you   of the cool stuff you can do next up is kind of  the opposite of intersect is subtract so let's say  
I wanted a swift developer that wasn't experienced  maybe I wanted a junior developer specifically so  
that's what I want to check for they want to be  in the Swift Dev set but not in the experience   Dev set so that's what we're going to check out  so we can say let junior swim shift Dev equal  
Swift devs dot subtracting experience devs so now  when I run it you'll see the only name I believe  
it's just just James I believe James is my only  Junior developer here yep there it is James so if   you look at the experience devs you've got Sean  Ava Olivia Leo Maya and you see Olivia Maya Leo  
they're all in there Shawn's in there the only one  that's not an experienced Dev is James so you see   you can subtract the differences between two very  large lists and just to show you that let me take  
out Maya from The Experience devs real quick and  run it again and then now you'll see James and   Maya because Maya is no longer in the experienced  steps another cool one here is disjoint so we can  
check to see if there there's any overlap between  two sets and this returns a Boolean so I'll say  
Swift UI devs.is disjoint with kotlin devs if  there's not an overlap it will return true if  
there is an overlap it will return false you can  see the Swift UI devs or Sean and James and the   kotlin devs Olivia Elijah Leo Maya Dan there's  no overlap so that returns true now if I change  
kotlin Dev to Swift devs there is going to be an  overlap so is disjoint returns false so again if  
you had a huge list and you want to make sure  there's no overlap between the lists there you   go disjoint is for you now Union is a way to  combine two sets so for example Swift UI devs  
and Swift devs Ah that's fairly similar let's just  combine that into one list but you know in a set   you can only have one name so if I were combining  two arrays I would end up with two Sean's and two  
James in this combined array but because I want  uniqueness in this set when I do this Union it  
will compare these two sets and combine them but  it will actually turn into the the Swift devs   array because you know Sean and James already  in there but that's what it will do it will do  
Swift UI devs.union with Swift devs and if I  go down here and run it you will see over here  
Sean James Olivia Maya Leo and again that is the  Sean James Olivia my Leo because we just combined  
these two we unioned them now let's say we want  to compare the two lists of names and we want   to see who only belongs to one list right let's  take Swift as and kotlin devs say we don't want  
someone who's like cross-platform developer kind  of knows a little bit of both we want Specialists   we want someone who only focuses on Swift Dev or  only focuses on kotlin dev so again we can see  
if they're exclusive only to one of them so I can  say Swift devs dot it's a symmetrical difference  
of kotlin devs now here this will give me whoops  I got to call to something let Specialists right  
I gotta this will spit out another set here so  run that and you'll see who are the Specialists   Elijah Sean James and Dan and you can compare  the Swift devs and the kotlin devs and you can  
see Elijah's only a kotlin Dev Sean is only  a swift Dev so you can see they're the unique   ones to the two lists so like I keep saying if  you had two super large lists of names and you  
want to do all these comparisons sets are just a  lifesaver these little one-liners spit out so much  
good stuff and I save the simple ones for last  so subset if you know what the word subset means   pre-self explained story so it returns a Boolean  so you can say Swift UI devs. is subset of Swift  
devs this is going to return true right because  you can see Sean and James in Swift devs are in   Swift UI Dev so Swift UI devs is a subset this is  a quick again little one-liner check if you want  
to see if something is a subset that should return  true and then let's change Swift devs to kotlin   devs and then that should return false because  Swift UI devs is not a subset of that superset is  
basically the reverse so you see Swift devs dot  is superset so that means if it's a superset of  
the subset of Swift UI devs this should return  to True again because Swift UI devs being the  
superset contains Swift UI devs run it just to  check true again so subset superset checks pretty  
simple and then insert delete and find say Swift  devs dot insert new member we'll say Joe goes into  
Swift devs now remember the order doesn't matter  on an array you append it to the end you're just   inserting it here and then the order jumbled up  but there you go you can insert Joe or I can do  
Swift devs dot remove it's remove Sean and I can  do Swift devs dot contains Maya and then here I  
will print Swift devs down here so now when I run  this you can see I've inserted uh Joe I've removed  
Sean so Swift devs does contain Maya is true and  now the new Swift devs set that has added Joe and  
remove Sean there you go there's Joe and there's  no more Sean so again insert remove contains those   are the constant times super performant things  on a set again if you have a super large data set
Unwrapping Optionals
I'm teaching you about optionals I'm going to show  you four different ways to unwrap them we're going   to talk about optional chaining and then I'm  going to show you some examples of how these  
are used in a real code base an optional in Swift  is something that can either have a value or be  
nil for example our app could have a user object  where the age is optional and that's because in  
our app we don't require the user to enter their  age but they can if they want so our code needs to   be able to handle both situations hey is the age  actually going to have a value or is it going to  
be nil and that's what this question mark denotes  a good analogy is to think of this age property  
that has a question mark as a box that's closed  you don't know if that box is going to contain   a nil or you don't know if that box is going to  actually contain the integer value of 41. and the  
way we handle that in our code is by unwrapping  the optional so here's our user object that I   mentioned before let's create a user real quick  let user equal a user will initialize that with  
a name of Sean in the age is nil so the first way  we're going to learn to unwrap is with the if let  
and I'll tell you about pros and cons of each of  these methods as we go so for the if let we can do   if let age equal user dot age and you see user.h  is the optional you see that question mark down  
there so what this means I'm going to run through  this so when we say if let age we're creating a   new property to store the value in if user.h has  a value we're going to store it in this variable  
called age if it's nil it goes into the else block  because age could be you know 41 or it could be no  
so if we have the value here we can say print  users age is and then we'll print out the H  
because it has a value so it'll go into the else  block if user.age is nil so we can now print user  
did not enter and age so if I run this we're going  to go into the else block because look Shawn's  
age is nil this user that we created on line nine  that's the user we're using right here so if I run   it you see user did not enter in age so now if I  change on line 9 my age to 41 and I run it you're  
going to see it's going to go into line 14. user's  age is 41. so This Is Us unwrapping the optional  
like I said we don't know if it has a value or  not so we have to handle both situations if it   has a value cool and we just did a print statement  but you can imagine there being like a whole 50  
lines of code doing whatever you need to do down  here right we just did a simple print statement   and then else if it's nil maybe you want to show  an error do something here in the else block now  
a downside to using IF flat again I'm going to  talk about the pros and cons is you have to use   age within this scope so what it means if you have  some logic right like say you want to do like if  
age greater than 40 you know do something now you  can see we're starting to get pretty nested here  
I'm going to delete this to clean that up uh with  our code and it can be very hard to read so if  
let's if they get out of control can lead to this  Pyramid of Doom that you see here so that is one  
of the downsides now of course if you just have a  simple you know one line of code in here and it's   not super nested great go for it but a way to  prevent that Pyramid of Doom is to use guardlet  
and that'll be the next example so regardless you  need to use a function because one of the features   of guard is an early exit from the function so  let's create a function called check age and that  
takes in an INT and we're basically just going to  do an age check like if they're over a certain age   we can do something in our app whatever that is  but we don't know if age has a value so we want  
to unwrap that optional so we want to do guard let  age equal age else return so I'll say print age is  
nil so guard like I said is good for the early  exit from the function because let's say we're   doing a bunch of code down here like again like if  age is greater than 40 you know do something but  
because this logic relies on there actually being  an age we basically say hey if age is nil just   return don't even do all this code below I like  to refer to this as like the Line in the Sand the  
guard statement if the guard statement fails it's  just going to return and none of the code below it   will execute so again it provides that early exit  which is nice and it avoids the Pyramid of Doom  
because once you have your age variable here now  you can use that within the entire scope of the   function whereas if flat remember you had to use  it within this scope right here just the top part  
of the if statement and then that could get super  nested but with the guard statement you can use   it and you know in the whole scope of the function  now something that's new in Swift 5.7 I believe is  
this boilerplate of garlic age equals age you've  seen you know everywhere if you've been coding   for a little bit now you can just do guard let  age if the naming works out for example up here  
the naming doesn't work out I can't just do if let  age because we're using user.age that has a little  
extra thing but in the very common boilerplate  example we have to do like if let age equals  
age or guard let age equals age you no longer  have to have that same name it'll just use this  
variable name that you use there so let's run this  function here check age and we'll pass in user dot  
age because that is the right now it's 41 so it  does have a value let me actually add a print   statement and here you are old let me comment out  these print statements so we don't get confused in  
the console so we'll run it because because  there is an age right it should go past the   guard statement right because it's it is not nil  so it should say you are old right it went in ages  
greater than 40. you are old now if I go up to  line 9 again here make my age nil it's not going  
to make it past the guard statement so run it so  basically if age is nil it's going to go into this   ages no as you can see here and then it's going  to exit from the function so this code never even  
runs in that situation which of course for us  is just one simple little line but I mean there   could be like Network calls there could be a whole  bunch of code that relies on you having a property  
here so you can definitely save running all that  code if you don't need to okay moving on to nil   coalescing so no coalescing is great to provide an  easy default value so I can say let age equal user  
dot age double question mark or zero so what I'm  saying here is hey check user.h which remember up  
here right now it is no I'm going to comment out  all this if let stuff to stop all the errors and  
stuff so right now my age is nil so if I say let  age equals user.h that is nil so what it does it  
provides a default value it says hey if this is  nil here give it this default value and put that   into age so if I were to print age down here and  let me get rid of of these print statements again  
so we're not confused run it now age is zero gives  me the default value because it's nil now if I go  
up and change Sean's age to 41 and run it now age  is 41 down there now I want to go back to what  
I said a easy default value and this is a case  where it might not make sense because providing a  
default value of 0 for the age could mess up some  calculations or things you're doing in your app so   a place where it may make sense is if you say let  name equal well let me actually go back up to the  
user Let's Pretend the user.name now is optional  so see how you can make something optional real   quick just add a question mark to the end of it so  now if I do user.name and you can see when I type  
in name it shows that it's optional right here and  then if the user's name is nil then I can provide   something like not given so you can see how if  you're providing a list of usernames in your app  
showing not given when it's nil is a good default  value to have versus maybe passing in 0 for a  
default age might not work out so well so again  no coalescing a simple default value or works best  
okay now let's talk about Force unwrapping which  can be a controversial topic let me show it to   you and then talk about it for a second so I can  say let age equal user dot age you can see that is  
optional and I can just say bang exclamation point  what this means is let me comment that out to not  
be confusing here what this means is basically  it's it's forcing the unwrap even if it's nil   act like it has a value and this will lead to  crashes so let me do print age and let me make  
age nil up here so age is nil and I basically said  let age equals user.h if it has a value hey smooth  
sale and it'll work if it is nil your app's going  to crash so let's run this and you should see the   crash and if you've been coding you've probably  seen this a ton fatal error unexpectedly found  
nil while unwrapping an optional value that means  you're forcing wrapping somewhere and it's biting   you in the ass you don't want to do that now many  developers will say never ever ever Force unwrap  
and to be honest with you if you're a beginner  just learning that is probably will be the safest   way to go never Force unwrap however as you get  more experienced it does become a little more  
nuanced and I believe 95 of the time never Force  unwrap but there are certain situations which I'll  
show you in my code base where it's fine to force  and rap at least in my opinion but again there are   many people that will say to never Force unwrap so  you'll hear that a lot okay let's comment this out  
so we can stop the crashes and let's talk about  optional chaining to finish this off so this is   when the entire object is optional so let's say  my name in the age are not optional but the user  
itself is optional so let's dive into that here so  we'll say VAR optional user is of type user but I  
put the question mark after that so the whole user  is optional maybe the user of our app doesn't even   have to create a profile with a name or an age  so if I want to say let name equal optionaluser  
dot name you see it fills in the question mark  right here so that means the whole user itself  
is optional and not the name so what will happen  is if optional use user is nil the name will be  
nil this automatically makes this property here on  line 53 called name and optional so this is called   optional chaining because you're really after the  name but the whole object isn't optional and then  
of course you can unwrap this in the typical  ways right we can do some no coalescing you're   not given that'll work so name will be not  given if optional user is nil you know or you  
can say if let new name equal optionaluser dot  name say print new name so this just shows you  
what chaining is again once you understand the  chain you can unwrap it however you want using   no coalescing Force unwrapping guard lead all the  stuff that we've just did but just so you know if  
the object itself is optional then to get to the  properties on them you're going to see optional   chaining now let me show you examples of these in  a real code base to give you a little more context  
so here's an example of if flat where I'm checking  the cache so on this screen the Avatar the channel  
name and the number of subscribers up top here  I am caching that information because what was   happening every time I went to the screen it was  fetching the data and the UI would flash like as  
the new data fetched so I didn't want that so  I wanted to show the older cached information  
because the Avatar and the channel name don't  really change and the subscriber number might   change every once in a while so basically what I  do is I cache the old information and then show  
the new one once the network call has completed to  get the new channel info so that is a great thing   for if let because if I look in my cache and the  cache is nil then I just move on and run all the  
network calls and all that stuff if I have an  item in the cache then I set my channel info to  
that cache Channel info and update the UI that  you see here and the reason this is good for if   LED and I'm not using a guard is because I don't  really care if it's nil or not right whether it's  
nil or not I still want to execute the rest of  the code whereas if I used a guard I would have   to have an early exit I would have to return out  of the function and I don't want to return out  
of the function so you want to use guard when  having something be new makes the rest of the   function irrelevant here's an example of using  guard lit on this screen where I can drag and  
drop calendar items around and when I drop them I  want to make sure the day has enough room for it   because I limit the number of events in a day and  the date on those objects is optional so you can  
see if the date is nil then I don't even want to  do all this other code so that's a great use for  
the guard lead you see guardlet date equals date  and again I just haven't updated my old code in   Swift 5.7 I don't need this boilerplate I can just  do guardlet date but basically there is no date  
just return false and the function don't even run  that stuff so again that's a great use of guard   when you want that early exit here's an example  of no coalescing again in this UI back to that  
channel header with the Avatar channel name and  subscribers like if the channel info is no it's   another example of chaining then I want to provide  a default value of just n a for the channel name  
you can see I use it down here as well if Channel  info dot abbreviated Subs that's the subscriber  
count in the upper right hand corner if that  is nil I'm sorry if Channel info is no right   because I get channel info from a network call  so it's nil until I get actual proper data then  
I want to show an N A if that comes back wrong  for any reason and then finally an example of   force unwrapping like I said 95 of the time you  should not do it but here's an example of where  
I think it's okay and to be clear there will be  developers that disagree with me and and that   is fine but here this is date math so this is  all Apple system stuff right you're getting the  
year component for today's date and then you're  calling dot start here I am Force unwrapping this   data interval so this is all Apple system stuff  none of this is my code none of this is anything  
calculation wise this is all straight up Apple's  stuff I'm sure there may be some crazy crazy Edge  
case where you know this could be no but here's  the pros and cons of force unwrapping if you do  
unwrap your optionals as you saw in the previous  code you add the iflet the garlic no coalescing   you start to get a lot of extra code and you can  see here I'm doing a ton of date math in this app  
which is mostly using all of Apple's built-in  system stuff so I would be forcing wrapping it  
everywhere and make my code hard to read I'm not  saying that's a reason to force unwrap what I'm   saying is this to me is one of the examples of  a nuanced reason when Force unwrapping is okay
Unit Tests
this video is meant to be your very first step  into unit testing so we're going to talk about  
what even is unit testing and why is it important  I'm going to show you a real example in code and  
then we'll talk about should you even bother  writing these unit tests a unit test is where  
we test a small piece of code to ensure it gives  us the expected outcome think of a basic function  
that takes in two numbers and adds them together  and in my head I like to think of functions like  
little factories right in this case it takes in  two inputs right two numbers and then it does   something to them it's adding them together  and then it spits out a result in this case  
it'll spit out the sum of the numbers so what a  unit test does is it makes sure that that factory   is working as expected and it's doing what it's  supposed to be doing because let's say six months  
down the road a new developer comes into this  code base and maybe they change the plus sign   to a minus sign well when we write unit tests  we're testing to make sure that that function  
is adding numbers together so if a developer comes  in and changes that our unit test will catch that  
because that test will fail and we'll dive into  a more detailed example later in the video but   that's an introduction to what a unit test is and  what it does and I want to stress the word unit  
because that's the whole point ideally you want  to test the smallest piece of code possible now  
the example I just showed you adding two numbers  together you can't get much simpler than that but   you can imagine if you had a function that was  40 50 lines of code long which you shouldn't  
really have anyway but the idea is if you have  a really long involved function that is going   to be a nightmare to test so if you want to write  good testable code you want to break it down into  
the smallest chunks possible which you should  probably be doing anyway so why is unit testing   important and what are the benefits well first  and foremost it can prevent errors or regressions  
what's a regression you ask well I think we've all  been there you ever had a piece of code that was   working and then later on you came in maybe you  tried to add a little functionality to it or you  
did a little refactoring or maybe you deleted a  line of code you thought wasn't doing anything and   then bam everything breaks well that's called  a regression because things were working now  
they're not working so you went backwards and a  lot of times regressions are are sneaky right you   can change something in one area of the code but  then it breaks something in another area because  
everything's interconnected and that's why having  great unit tests written right when you're testing   that the factory is doing what it's supposed to  be doing you can catch those regressions when  
you run the tests and fix them right then and  there so as you can see having good unit tests   gives the developer a level of confidence right  a level of safety that you can maneuver in the  
code base change things refactor things and you  know your tests are going to catch any errors   you may introduce so this allows a developer or  developer team to work a lot faster due to that  
safety and confidence and this is really really  important when you're working on a large team of   developers now this is a good time to point out  that your tests are only as good as you make them  
what I mean by that is if you don't think of all  the edge cases or all the ways that your code can  
break and write a test to cover that well then  your tests aren't really going to save you and   learning how to write recognize these edge cases  and write tests for them does just come with time  
experience and practice right you're not going to  finish watching this video and be a testing expert   it's going to come with time okay let's dive into  a code example here I am in xcode with a basic tip  
calculator app for example the user types in you  know 500 they can drag the slider to see the tip  
and then what the bill total would be so I'm not  going to go over all the Swift UI code because   we're really focused on this tip calculation code  because that's what we're going to test but if you  
do want to follow along I'll scroll back up to the  top pause the video there's the code scroll down a  
little bit pause the video there's the rest of the  code but again we're focused on testing so down   here into our calculation struct which by the way  I just put in the same file just for ease of use  
on the video a lot of times you'll see your models  or anything like this in a separate file let's   walk through what's going on with this function  you can see I'm calculating the tip I'm taking  
in the entered amount which is a double and then  the tip which is a double so where am I getting   the entered amount and the tip so the entered  amount here on the on the slider the on change is  
this text field now the entered amount here is a  string because it is in a text field so I do have  
to convert that to a double so essentially you  know that will return a nail if they entered like   some emojis or maybe multiple decimal places or if  they entered a string that can't be converted into  
a double this will return nil and I'm just doing  I'm just printing invalid entry this is where you   would show them an error and then cool once I know  I have a good amount it's a proper double then I  
am calculating the tip by calling calculation dot  calculate tip of amount with tip slider and then  
as you can guess tip slider is coming from the  slider here where I pull out you know zero to  
100 you can tip zero percent or 100 and then I  pass in the tip slider amount there and then I  
calculate the tip in the total amount so this is  the small piece of code the unit that we want to  
write tests for so the first thing we need to do  is add a test Target to our project now if you're  
creating a brand new project from scratch you'll  see this pop-up check that little box and you'll   get what we're about to do you know for free out  of the box but if you have an existing project  
that you haven't written tests for we need to  add a testing Target and that's what we're going   to do so I'll go to file new Target here you can  type in test you can see there's UI test or unit  
testing bundle which is a unit testing bundle UI  test is a completely separate topic now you can   see you'll get tip calculator tests that's fine  for now all this should be good hit finish and  
there you go now you have new tip calculator tests  over here and this gives you basically boilerplate  
of how tests works or you get set up tear down  Test example we're going to dive into this later   but what I want to point out is if you just kept  it default tip calculator test tip calculator is  
the name of the app by the way that's like a test  for your whole app and as you can imagine a big  
app that file is going to get a little unruly so  what you want to probably do is and this gets into  
project organization which is subjective but this  is just my recommendation is create new files for  
every section of your app now of course our app is  only a tip calculator but you can imagine if you  
had 10 screens and you know a bunch of different  functionality you'd want a different file for each   little section of functionality just to keep  things organized so I'm going to do that right  
click new file say unit test case class hit next  we're going to call this calculation tests because  
my struct is called calculations I'll show you  that in a second so hit next yep make sure your   target is on the tip calculator test Target not  just the app Target hit create cool so you see  
I basically got the same thing the only thing  that changed was uh the name but again I wanted   to point that out because you know you're probably  gonna have a lot of these files testing different  
areas of your code so the reason I call this  calculation test is back to my content view is   because I have this struct called calculation now  this simple example only has one function but you  
can imagine if I had something called calculation  maybe I have 10 functions that are calculating a   bunch of different stuff so that is why I named  it that now we're going to delete all this because  
we're going to write our own here now back to the  content view I'm actually going to pull it up side   by side we're going to get rid of the preview so I  can see the code here cool so I got my calculation  
code here and then my tests over here so the first  thing I like to do is test what we call again the   happy path like if this code works properly what  should I expect so when you write a test you want  
to call it funk and then test it always needs to  start with test and then whatever you're testing  
so I'll say successful tip calculation the basic  structure of a test is you want to basically set  
up your variables do something and then assert  what the result should be so oftentimes you'll  
see given when then you'll also see this called  arrange act assert I kind of like the arrange  
act assert better you'll see why once we do this  so the first thing we need to do is arrange our  
data essentially so for calculate tip we want  to give an entered amount and a tip amount and  
here's where we're setting up the scenario that  we want to test and because we're testing you  
know the the happy path what's supposed to happen  we're not going to give it anything crazy so we'll   say let entered amount equal 100.00 100 dollars  and it will say let tip slider equal 25.0 and I'm  
adding 0.0 so it can be a double and it doesn't  assume it's an inch so like I said we're setting   up our parameter setting up the scenario that we  want to test so that's us arranging or those are  
the Givens so now we act or when you know when  this happens or we act so now we want to say let  
tip equal calculation okay so I don't have access  to this calculation struct and this is something  
you're probably gonna have to do most of the time  so you can do at testable and then import your app  
name so tip calculator what this does is this  gives your testing file here access to all the  
objects in your app so now I will have access to  this calculation struct so we're actually going  
to create that up here we'll say let calculation  equal we'll initialize uh brand new calculation  
struct so let's tip equal calculation dot  calculate tip of entered amount with tip slider  
and I'm going to put this onto two lines so we can  make that neater okay so I am calculating the tip  
it's basically running this function with these  parameters being passed in so that is the act that  
is what is happening so now I want to assert  I basically want to give it the answer so we   use XC assert and you can see there's a bunch of  these here a certain nil true false equal not nil  
so whatever testing situation you're in whatever  you want to test use the proper assert most of the  
time you're going to be using these top ones right  true false equal maybe nil you'll see us use no in   a second so we're going to use equal so we want  to make sure our tip which is what we calculated  
here on line 20 equals 25 and that is because you  want to make sure a 25 tip on 100 equals 25. so  
you are manually giving it the answer because you  want to test to make sure that this this Factory  
this function is doing the the proper thing so now  if I click this little Diamond I can run this test  
and you can see tests succeeded get the green  check marks because it is working as expected  
now you may be thinking well if I'm giving it the  parameters and giving it the answer like what's it   testing because let's say on this entered amount  Plus or times tip percentage uh let's say we you  
know just did a minus instead of a multiple sign  you know another developer came in there changed   it maybe by mistake or maybe thought they were  doing something well now when I run my tests  
because I've set up these parameters that hey  this should equal 25 well now it's going to fail   because you know 99.75 is not equal to the 25 as  expected so you can see how now if someone goes in  
and changes the code later the factory still has  to do what it's supposed to do and that's what the   test is checking for so let's change this back  to the multiple sign right entered amount times  
tip percentage and then let's run our test again  to make sure they're working green cool good to  
go test succeeded so that is the happy path that  is as expected but again your tests are only as   good as you make them you want to cover the edge  cases and the various ways this can fail so the  
next thing I want to test is if I close out my  assistant editor go back to my content view to   get my preview up just to show you this well we're  relying on the user to enter a bill amount so sure  
when they enter hey my bill was 100 bucks things  will work but we want to cover you know when the  
user does something silly right what if the user  says my bill was negative forty five hundred   dollars well a bill is not going to be negative so  you don't want to calculate a tip on a negative so  
we want to account for the case where they enter  a negative and if you look at our calculation we   are accounting for this Right Guard entered amount  greater than zero so if I go back to my tests here  
so now I'm going to copy and paste this test down  here and we're going to call this instead of test  
successful tip calculation we're going to call  this test negative entered amount tip calculation  
and it's fine if you're testing names are really  long and descriptive so entered them out let's   test negative 100. so if we look at our code what  should happen when we pass in a negative well you  
can see guard entered amount make sure it's  greater than zero if not we're returning nil   and real quick the reason I'm returning nil is  because that's where I'm going to show the error  
I'll move this over real quick so we can see  if tip comes back nil we're just printing bill   amount or tip cannot be negative that's where we  would maybe show like an error to the user again  
just a contrived example for educational purposes  but that is why I'm returning nil so I also wanted  
to show you how to assert nil and test this so  now we're testing the negative amount entered   so what should happen when we calculate the tip  with negative 100 again enter an amount will be  
less than zero so we're returning nil so down  here in our assert this is the only thing that   changes really is instead of assert equal let's  do XC assert nil and what is nil tip should be nil  
that's what this calculate tip returns so we're  saying hey when we get a negative amount it should   be nil so if we run our test this should pass  again because our code has change we're writing  
the test to make sure if it does change we'll  catch it so for example let's say some developer   comes in here and I don't know they they decide  to take out this guard statement on line 78 I'll  
just comment it out well the code will still work  right because if a user just only enters positive  
numbers we'll never even see this bug we'll only  see this bug if the user enters a negative number   so now when we run our test and by the way you  can do command U to run all of your tests or you  
can just hit the little triangle there but you see  this one failed because this line of code is gone   someone thought it wasn't useful but now we caught  it with our tests and I'm going to stop here with  
the code examples but you know we could test a  negative tip amount would be very similar to that   and again you want to think of all the edge cases  all the way this function can break and then write  
a test case for it that way if someone ever does  come in and change the code like you just saw the   test will catch it and you'll know right away okay  let me put this line of code back do a command U  
to make sure my tests are all passing cool test  or pass we're good to go now you may be thinking   like okay we did all this code all these checks  for a very simple small chunk of code and I only  
did two examples there's more to be had here  you might be thinking like man in a in a real  
app with tons of code I'm going to be writing  tons of tests that's a lot of time effort and  
work like is that worth it okay there's no doubt  that writing good tests takes a lot of work time  
and effort there's also no doubt that there's a  lot of benefit from that work and effort so the  
magic question to ask yourself is all that work  and effort worth it and as always in programming  
it depends there's no concrete right answer for  everyone because here's the deal like here's what  
I want you to think about whether you're an indie  developer a small startup or a huge company one  
of the most if not the most valuable resources you  have is your developer time and effort like where  
you focus your developers that is so valuable to a  technology company so as you can imagine if you're   a small startup and maybe you have one developer  two developers and you're still trying to figure  
out the product right you're still iterating it's  changing a lot maybe you don't have a lot of users   well it makes sense that the best use of that  developer's time is to focus on the product build  
something users actually want to get users if that  developer is spending half their time writing unit  
tests for features that are going to change in a  month well you can imagine that startup in that   product is probably not going to move fast enough  to succeed now of course that's an extreme example  
but let's go to The Other Extreme say your YouTube  you have a billion users and you have a team of a  
hundred developers well now unit tests are a very  important part of your workflow and absolutely  
critical to allowing that team to effectively  work on that insanely large code base and make  
sure things don't break for your billions of users  so those are the two opposite ends of the spectrum   on like should you write unit tests so where you  fall on that Spectrum you know depends on again  
how many users you have how large your team is  what's the maturity of your product you know is   it constantly changing still because you're still  trying to figure it out so that's why the answer  
to should you write unit tests for your project is  it depends and hopefully that example of those two   extremes will help you to navigate that a little  bit and it's not all or nothing either right it's  
not like either I write zero unit tests or I go  for 100 code coverage which you probably shouldn't   do anyway right even if you are that Indie Dev  or small startup if you have a critical piece  
of code something you know is not going to change  yeah go and write unit tests just for that little   bit again you can write unit tests for whatever  chunk of code you want so that's why the answer of  
should you write tests how much should you write  it's different for every app project team Etc
Singletons
never use a Singleton you hear that a lot but are  they always bad Singletons come up a lot and iOS  
Developer interviews so today you'll learn what is  a Singleton the pros and cons of a Singleton and  
when and where to use them what is a Singleton  a Singleton is an instance of a class that can  
only be created once and is globally accessible  throughout your code base let's take a look at an   example of a Singleton that Apple itself uses user  defaults user defaults is how we persist data onto  
the device for example if I wanted to show this  onboarding screen only the first time my app is   ever used I would store Boolean like is first used  into user defaults so that the screen only shows  
Once here's the key question to ask yourself  before creating a Singleton is it vital that  
there is only a single instance of this class  if a second instance were to be created would  
that mess things up and user defaults is a great  example of this because we want that persisted  
data to be consistent imagine if every time we  wanted to fetch from user default or write new  
data to user defaults we created a new instance  of it so now this example of is first use well  
in some user defaults it would be true sometimes  it would be false right you can see I would be   very inconsistent so you see why it's vital for  there to only be one user defaults so anything  
we store in there is going to be the same when  we go to fetch it by the way that dot standard   after user defaults is the shared instance of user  defaults which makes it a Singleton I'll tell you  
about that later in the video when I break down  the anatomy of a Singleton now for the pros and   cons of a Singleton the first pro is that there  can only be one it's Unique so if uniqueness is  
what you need like we did in that user defaults  example there you go Singletons are good for   that the second Pro is also a con which we'll  talk about in a little bit but it's convenient  
remember your code base has Global access to that  Singleton so in the example of user defaults no  
matter where I am in my app no matter what file I  can call user defaults.standard in either fetch or  
write new data to it doesn't matter where I am but  I want to be clear if the only reason you chose a   Singleton is because it's convenient you're doing  it wrong that is not the way to go the main reason  
you choose a Singleton is because you need that  uniqueness you need there to only be one instance   of this class creating a second one would mess  things up the convenience is just a bonus now for  
the cons of a Singleton and we'll start off with  that Global accessibility that convenience that   I just talked about because you can imagine if  you have a big code base you see all these files  
and all of these files can access that shared  resource you know that Singleton where you can   imagine you know this file might be updating the  Singleton which could cause a bug in another file  
so you can see how it can quickly turn into this  spiderweb if you know hundreds of files can all   access and make changes to this Singleton it can  lead to some very tricky bugs so you got to be  
careful with that and because all those files are  accessing the Singleton directly from their file   that makes testing pretty tricky because you  know the the functions in that file may rely  
on data from the Singleton but it's coming from  an external Source it's not all self-contained in   that function so testing gets tricky along those  lines the whole set operation of concerns that's  
good for programming that gets real muddy because  again all these files down here are accessing the   same resource however a common way to fix this  issue is to use dependency injection to inject  
your Singleton into these files rather than  accessing the Singleton directly from the files   dependency injection is a topic for another video  that's coming soon how do you create a Singleton  
how do you guarantee that only one of them can  be created well here I have a simple example and   I kept it simple because really there's only two  steps the first step in the class of my Singleton  
is the static let shared equals my Singleton so  here I'm creating a property called shared and  
I'm initializing an instance of my Singleton the  class now the second line is what guarantees the  
uniqueness this private init so the initializer  is private I can't initialize an instance of  
my Singleton from outside of this class so if I  can only initialize the class my Singleton from  
within the class that's exactly what the static  let shared equals my Singleton is doing I'm   initializing that instance and then now anytime  I want to use my Singleton for example you see  
the function down there do something that's on my  Singleton I call my singleton.shared do something  
so how you use your Singleton is that dot share  and that's exactly what we were doing in user   defaults when we did user defaults.standard or  you may see file manager file manager.default  
or URL session URL session.shared to be clear  that dot shared.default dot standard that's  
just the name typically you see dot shared in  Singletons but they're all doing the same thing   they just chose to name it default and standard  or shared it's the same thing so our Singleton's  
the worst design pattern in iOS no Singletons  are a tool just like a hammer a hammer can be  
used wonderfully to make beautiful things  a hammer can also be used to do some pretty   bad things Singletons have a bad reputation  because they are easily abused and a lot of  
developers have used them so use them sparingly  don't overuse them and you'll be all right
Dependency Injection
dependency injection is when you give an object  what it needs rather than that object creating  
or finding it itself and it can be intimidating  because the name is all fancy and there's a few   different variations on it right initializer  injection property injection method injection  
should you use protocols or even property  wrappers there's a lot going on this video   teaches you the core concept on how to use it  and what the benefits are for our example we're  
going to use initializer injection which you  may also hear Constructor injection because   why not right dependency injection is not  intimidating enough as it is let's call the  
different variations multiple names too like I  don't know anyway initializer injection let's  
use the Chipotle app to demonstrate that here's  our parent view right the list of things you can   get you know burritos bowls quesadillas when  you tap on an item like a burrito it goes to  
the child view which shows a list of ingredients  for that burrito so what our child view needs is   access to our network manager which has our API  calls because it needs to pull down that list  
of ingredients and it needs access to our bag  which is our order so when we're adding these   ingredients we can add it to our order so with  dependency injection instead of the child view  
which is the ingredients list creating its own  network manager creating its own bag object we   have our parent view give the child view the  dependencies right the network manager and the  
bag object and we do that through the initializer  let's take a look at that in code here we have a  
very basic version of a network manager you  can imagine this is what holds you know all   your API calls again super simple version for  the example just the function that says fetch  
ingredients here's our bag right this has an  array of items because we're building that order   and then we have a function called place order  again in real life these two dependencies are  
objects the network manager or the bag will be  much more involved much more complex but again   keeping it simple for the example this is what  it looks like when our burrito ingredients view  
model here again this is the child view the list  of ingredients for the burrito it is creating its   own network manager it's creating its own bag  so this is without dependency injection and  
then you can see it uses the network manager to  fetch the ingredients and then it uses the bag   to place order with dependency injection we  don't want to create these within the child  
do we want the parent view to pass them in  and like I said we're going to do that through   the initializer so instead of these properties  creating new objects itself we're going to make  
them of type network manager get rid of the equal  sign put a colon get rid of the parentheses for   the initializer put a colon there so now we just  have properties called network manager that are of  
type network manager and bag that is up type bag  and now we're going to build an initializer to  
accept values for those objects passed in so we'll  do a knit and you can see we get the autocomplete   here network manager takes in a type of network  manager and a bag takes in the type bag and then  
you see self.network manager equals the network  manager in the bag that we passed in so now   anytime we create a burrito ingredients view model  part of the initializer it's going to require hey  
give me a network manager give me a bag that  is US injecting the dependencies the dependency  
injection and then you can see we're still using  it network manager fetch ingredients and then bag   place order now here's again a quick pseudo code  example I'll paste it in here here's the meal  
category view as you can see this would be the  parent view that has the burritos the quesadillas   Etc you can see the network manager and bag get  created in the parent view and then again more  
kind of pseudo code here because if you're using  Swift UI maybe this would be a navigation link to   present the child ingredients view or for your  UI kit maybe you're you know a destination view  
controller so this is not exact code just to  be clear because it's going to be different in   Swifty wire UI kit they want to confuse you I just  wanted to make it super simple see you understood  
that however you're navigating to that child view  again the list of ingredients for burrito this is   where you would create the view model for it right  burrito ingredients you model and then you pass in  
the network manager you created in the bag you  were created at the parent view so again this is   us injecting the dependencies into the child view  rather than the child view creating them it sells
now you may be noticing your potential downside  of this initializer injection now whether it's   property injection initializer injection method  injection they all have their pros and cons and  
use cases that's above the scope of this you  know core concept video but potential downside   of this initializer injection you see we have two  dependencies and the initializer is not that bad  
but imagine if you had four five six seven  dependencies okay now this initializer gets   a little unruly so again there's pros and cons  to each way now you may be looking at this child  
view and say well that's a very minor difference  and hey we even added more code so isn't this a  
little more complex why are we doing this what are  the benefits of dependency injection so that's the   second part of the interview question if you get  asked this right they're going to ask what is it  
and then why would you do it so the first reason  you might do it is to simplify the flow of data   so in this example where the parent view the list  of meal items right the burritos of quesadilla is  
passing in all the information the child needs  right that's one flow very easy whereas before  
where the child view the ingredients list it  had to create its own network manager it had   to create its own bag you can see the flow of data  is getting a little more messy and this is a super  
simple example imagine if you had a giant app with  tons of views turns into a giant spider web so to  
help ease the understanding of how data is Flowing  you know dependency injection makes it very linear   the next two benefits kind of go hand in hand  so the first we'll talk about the separation of  
concerns with dependency injection we're removing  the responsibility of the child to create its own   dependency they still need to know how to work  with those dependencies right they still need  
to know what to do with the network manager but  it's not their responsibility to create it that   simplifies and caramelizes things which also  makes it easier to swap out components right  
if you make a completely new networking layer you  just inject in the new networking layer which goes   hand in hand with improving tests that's a big  thing for a dependency injection because when you  
try to test the child view instead of it having to  create the network manager create the bag and all   that stuff you can just inject in a mock version  of the network manager and then run your test so  
the ability to inject either a mock Network layer  or the real Network layer and your child knows how   to handle it regardless that allows you to test  the child object way easier understanding the  
concept that dependency injection is giving the  child object its dependencies or what it needs   versus the child object creating it itself  that is the key and then the other key to  
answering the interview question is to list  off a few of those benefits I just told you
Delegates & Protocols (UIKit)
the delegate and protocol pattern is a one-to-one  communication pattern in Swift it allows one view  
to communicate with another view for example  The View controller in our bottom sheet is   communicating with the main view controller  it's communicating that when the iPhone button  
is tapped okay main view controller go ahead  and update your UI with all the iPhone stuff   again it's a one-to-one communication set up with  delegates and protocols delegates and protocols  
can be confusing so I do have a starter project  to keep the video as focused as possible on the   topic I will review it here in 30 seconds it's  mostly UI code you can see the screen I have set  
up with an image view a UI label and a button at  the bottom so you see here product image view name   label product button and then most of the code  on the screen this setup UI is just all UI code  
right where I'm configuring the image configuring  the label configuring the button and then setting   up constraints you can see the image there  and then the other piece of code is actually  
presenting the other view controller the bottom  sheet right so when I tap choose product we get   this bottom sheet and that's what's happening  right here in this present product selection  
VC you can see we're setting up the sheet with the  detents medium that's how it goes halfway up we're   showing the Grabber and the view controller I'm  showing is the product selection VC let's go to  
the product selection view controller let's get  the simulator back up again just three buttons   iPhone button iPad button MacBook Pro button all  this code here it looks like a lot of code I know  
it's just setting up the UI I'm configuring three  buttons and then setting the constraints on those   three buttons and I do have actions for those  three buttons right when the iPhone button is  
tapped right now we're just dismissing it tapping  on the MacBook we're just dismissing it that's the   overview of the starter project as you can see  I've done nothing with delegates and protocols  
it's just purely UI setup but let's start talking  about those delegates and protocols as I mentioned  
in the intro we need to communicate between these  two view controllers our product selection view   controller and our main view controller right the  product selection one is one with the buttons the  
main view controller is in the back so that is a  perfect scenario for a one-to-one communication   which again delegates and protocols let me back  up and explain the the concept of delegates  
because this was a light bulb moment for me to  understand the concept of a delegate basically   delegate is sitting back waiting to be told when  and what to do you don't call delegate methods  
themselves they get called automatically when  they're told what to do that's the big picture   context to keep in mind as we build this it'll  make a lot more sense once we you know code it up  
okay so if the delegate is sitting around waiting  to be told when and what to do something has to   give it that order something has to give it those  instructions and I like to use a boss in an intern  
analogy so in our case the product selection  VC this card right here is going to be telling  
the main view controller what to do the product  selection view controller the half sheet has all   the information it knows what was capped it knows  the iPhone was tapped it knows the iPad is tapped  
and it has to pass that message along to the main  view controller so it will update its view here I  
don't have the code set up so it's not updating  but this image will change to an iPhone or a Mac   whatever so in our case the product selection  VC is the boss the main view controller is the  
intern the main view controller is just sitting  around hey tell me what to do and I'll do it right   it's just waiting to be told so to set that up in  our product selection VC which is going to be the  
boss in this case we need to create a protocol  so protocol and we'll call it product selection  
delegate and what a protocol is is essentially to  keep it super simple is a list of commands think  
of it like the job description right if you're  going to be my intern here are the tasks that   you need to know how to do so for us we're going  to create a function called did select product and  
we're going to pass in the name of the product  which is a string and also the image name so we  
know what image to update and by the way my image  names in my assets I have these built into the   project which you can download I have a link to in  the description to a Dropbox file to download the  
project but you can see at the iPhone iMac super  small but those are my assets the images are in   there and you can see their names iPad iPhone Mac  so I pull in my simulator so you can see here we  
need to pass in the name of the product so we can  update the label it won't say Apple product line   it'll say iPhone or whatever and then we need to  pass the image name so it knows what image to show  
here now in our simple example we're only having  one Command right this is like the job description   this is what the enter needs to know how to do  you could have did action two Funk did action  
three and these are just kind of placeholders  for other things that could potentially be done   on your screen I just want to point out that  a protocol can have many commands right it's  
a list of instructions a list of commands our  simple example is only going to have one but   again I want to make it clear you can't have more  than one now that we have our our job description  
essentially right telling the intern what you need  to know how to do we need to actually have a quote  
unquote intern on our product selection screen  so for that we have a variable called delegate  
and that is of type product selection delegate  that's what we just created up here and that is  
going to be an optional because we're gonna have  to tell this view controller what the delegate   is in our case it's going to be the main view  controller we'll come back to that in a second  
but I want to set up our product selection view  controller which in this case is our boss and I   know I'm repeating myself but I think repetition  is the key to really learn this stuff so like I  
said job description in the protocol here is  the actual job position if you want to use that   analogy so now our boss is set up we have the  job description we have the position now let's  
go to our view controller and essentially apply  for the job so to do that we need to conform to  
the product selection delegate so in order to  do that you do comma product selection delegate   up here in your class definition of the view  controller now xcode's going to yell at me do  
a command beep it says type view controller does  not conform to protocol selection delegate because   in order to conform a product selection delegate  we have to have these functions in place this did  
select product the tasks of the job so back to  view controller xcode will fill these stubs in  
now this may look familiar if you've ever built  a table View and UI kit you have to implement the   table view delegate methods if you've ever done  like location manager there's a location update  
delegate method and again those methods are just  sitting back waiting to be told what to do and   they fire off automatically and you'll see that  you'll notice I'm not actually going to call did  
select product in the view controller we're going  to call it from somewhere else and then that will   fire off automatically so actually don't like  the position of this my variable is up top and  
then my functions so we'll put it down below  view to load so now that I have signed up for   the job I need to do something when I get told  what to do this job so in our case we're going  
to set the product image View and pull up the  simulator again right the product image view is   the image of Apple products and then the product  name label is where it says Apple product line so  
I want to do product name label dot text equals  name and you'll see we're going to pass in this  
information and I want to do product imageview dot  image equals UI image named image name right we're  
passing in this information we haven't done that  yet you'll see that in a second but our intern   right our intern has signed up for the job I'm  conforming to the delegate and I know what to  
do when I'm told hey do your job like I said I  don't call this did select product from The View  
controller The View controller is a delegate it's  sitting back waiting to be told what to do once   it gets that order it's going to go ahead and do  this job so that's the premise of the delegate so  
there's two more steps we need to do if I go back  to my product selection VC to continue with this   analogy I have my job description I have the job  opening well back in my view controller I say hey  
I'm applying for the job and I know how to do the  job so let me get hired so to speak so here where  
I'm presenting present product selection VC right  I'm creating it I'm initializing a brand new one   and then I'm doing all the modal presentation to  make it a half sheet that's what all that code is  
and then I present it well now that I have this  destination VC I can set the delegate here so I   can say destinationvc.delegate equals self now  self in this case is the view controller I am  
signing up for this job remember the destination  VC is a product selection VC so if I VC short  
review controller if you haven't picked that  up yet so now that's this variable right here   that I am setting when I create a brand new  product selection VC I'm also initializing  
it with a delegate that I have set here equal  to self the view controller is saying hi sign  
me up I want to be your delegate I want to be  your intern so now that this is connected the   main view controller right that has our product  images is ready to do the job the final piece  
of the puzzle in our product selection VC or  in this case our boss is to actually give the   order give the command to do the job now when do  we want to do that again pulling up the simulator  
we want to do that when the iPhone button is  tapped when the iPad button is tapped when   the MacBook Pro is tapped we're going to give the  order hey update your UI with the iPad update your  
UI with the Macbook so to give those orders we do  that in our iPhone button tab now this is just my  
educational example with the buttons this could  be anything going on in this screen maybe it's   on a countdown timer maybe it's when they push a  button six times like whatever triggers this right  
in our case it's a button tap but this can be any  trigger where you call this line of code where you   say Okay delegate now you say did select product  and because we tapped the iPhone right we're in  
the iPhone button tapped the product name I want  to pass in is iPhone 14 and then the image name is  
just iPhone so you're telling the delegate okay  do your job delegate and here's the information   you need to do your job and if I go back to the  view controller this did select product is going  
to get fired off and whatever name and image name  I pass in on my main view controller I'm going to   set my product name label to that name and the  product image view to the image let's run this  
and see it in action and then we'll set up the  other two so I'm choosing product tap iPhone now   my delegate the main view controller knows hey  I'm going to update my label to iPhone 14 and  
I'm going to update my image to the iPhone so  let's go back and do the other ones so back to   product selection VC I'm going to copy and paste  this command here so copy that put it in the iPad  
button tap put it in the MacBook button tab so  instead of iPhone 14 we're going to say iPad Air  
and then that image is just iPad and then instead  of iPhone 14 for the MacBook we're gonna say mac  
book and then the image is Mac so now when I  run it no matter what button I tap it should  
update accordingly so choose product hit the iPad  bam there's the iPad Air choose product hit the  
MacBook Pro there's the MacBook I guess I could  have called that MacBook Pro on the label that's   neither here nor there but now you can see there's  two views communicating in a one-to-one pattern
View Lifecycle (UIKit)
in today's video we're talking about the UI view  controller life cycle methods you know viewed load   view will appear view did disappear all that  stuff I'm going to talk about when each one is  
called you know what you should be doing in each  one and I'm also going to share a common example   of the difference between view to load and view  will appear because that's a very common situation  
new developers get themselves into they're also  going to dabble into the whole view will layout   sub views and view did layout sub views before  we dive into the details of each one let's talk  
about when these methods are called because I  think that's a source of confusion for people   just starting out right you may see a method and  then you're expecting a very explicit method call  
to actually call that method well these ones get  called automatically by the system so you're not   going to see you know view to load get explicitly  called now when they're called that's what we're  
going to dive into with the specifics of each one  but just know they're called automatically now   when you create your own view controllers you're  subclassing a UI view controller and when you  
subclass the UI view controller you're inheriting  all these view lifecycle methods so when you're   using viewed load in your view controller that's  why you're calling super.view to load because you  
want to get all the magic that Apple built  on The View controller and then the code you   enter in view to load is your own custom code  for this specific subclass of view controller  
now I just use view to load as the example but  that applies for all these lifecycle methods   so if you're wondering why you're calling super in  these that's why first up view did load now if you  
did load gets called when the view controller's  content view gets created in memory or loaded   from the storyboard what's the content view let's  pull up a storyboard to show you this real quick  
so here on the left we have the view hierarchy of  a view controller if you've ever noticed when you   create a view controller on storyboard you get  this view right here by default this is the view  
controller's content view so when that view first  gets created in memory view did load gets called   this has nothing to do with what's displaying on  the screen this is when it gets created in memory  
or loaded from the storyboard now because it's  loaded from the storyboard if I go to a screen   here that is why all your Outlets will have a  guaranteed value in view did load right that's  
why your Outlets can be implicitly unwrapped  out optionals you may have wondered like why   am I force unwrapping these Outlets well again  in view to load your Outlets are guaranteed to  
have a value that's why we can do this now let's  move on to view will appear and then we'll do   the example and the difference between view to  load and view will appear now view will appear  
it gets called just before the content view is  added to the actual app's view hierarchy so just   before it actually shows up on the screen so  let me talk about the word appear real quick  
because being added to the app's view hierarchy  means it's in the view hierarchy however it may   not appear on your screen and that could be  for a reason maybe your view is you know my  
view.hidden but it's still in the view hierarchy  or maybe there's another view on top of that view   so just because it's not actually showing up  on the screen view will appear still happens  
because it's actually in the view hierarchy so I  wanted to clear up that confusion you know view  
will appear doesn't necessarily mean it's actually  showing on the screen again because you could have   dot is hidden or if you could be on top of it  but it's still there now let's get into a very  
common example on when to use view to load and  view will appear right this happens all the time   in apps so let me pull up the simulator here so  here in this app here so this search VC view to  
load is called bam this is there now let me go  to the next screen this is the GitHub followers   course by the way so now uh this is the search  VC this is the follower list VC right now when I  
go back right view did load is not going to get  called but view will appear gets called because  
on a navigation controller you're just putting  a new view controller onto the stack but this   search VC is still there so therefore view  to load only gets called that first time but  
every time I come back to the screen view will  appear gets called now here's how we're using   this in this app right so here on the search  VC we're using it to reset the username text  
field to blank so every time we come back to the  screen we want that text field to be blank if we   didn't have this line of code that salen0400  would always still be there but now let's move  
setting the navigation controller uh to false  into view did load up here so this will prove   that view to load only gets called once right  because of the very first time we run it we're  
going to set that navigation bar hidden equal to  true right okay look no navbar and then we go to   the next screen hit get followers now there's a  nav bar right we're showing the nav bar on this  
screen but when we go back to the the search VC we  don't want to show the nav bar it's just a styling   choice but when we go back because viewed load  only got called that first time now we have a  
nav bar here with this search thing right because  this navigation set navigation bar hidden to True   is not getting called so that's why we call this  in view will appear right so remember that view  
did load only gets called that once however  view will appear is going to get called every   time the view comes on screen so now that we have  that back in view will appear every time the view  
comes on the screen we're making sure we hide that  navigation bar so this is just one common example  
of using you know view will appear overview did  load a lot of beginning developers get caught   up on that they're not sure why the behavior is  happening and they don't understand that viewed  
load only gets called that first time and then if  you want to change stuff every time a screen you   know shows up you got to do it and view will  appear all right let's move on to view did  
appear so right we just did view will appear so  that happens before the view appears so you can   change it and then now you have view did appear  so this is what gets called after the view is in  
the apps view hierarchy and could potentially be  showing up on your screen so you want to do stuff   here like maybe animations right because if you  start an animation in view to load or view will  
appear it may start a little bit too soon right  you want a visual animation to start once the  
screen you know is showing up now moving on to  view will disappear right so this is very similar   to view will appear except instead of getting  called before the view is added to the apps  
view hierarchy this gets called just before it's  removed from the apps view hierarchy so you'd want   to do stuff in here like committing save changes  right uh so let's say you're you're have a form on  
your app up and before you dismiss the form you  want to make sure you save everything like even   if the user dismisses you know prematurely maybe  you want to save it for some reason so you would  
do that and view will disappear because you want  to make sure you do that before the view is gone   and then you have view did disappear so this is  something you'd want to do after the view has been  
removed from the views hierarchy now let's wrap  this up by talking about the less common ones and   that is if you will lay out sub views and view did  layout sub views now if you will layout sub-use is  
called when your views bounds change and it's  before all the sub use have been laid out very  
common example of the View's balance changing  is when you rotate from portrait to landscape   on your phone right you can see the View's bounds  changing kind of in real time in the animation so  
view will layout sub use gets called after the  views bounds change but before it relays out all  
the sub views that you know are on the screen  and by default like view will layout sub views   and view did layout sub views like there's no  default implementation they're just there to  
give you the programmer access to this point  in time so you can make changes if you need   to so if you will layout sub views gives you that  chance you know again in the example after you  
rotate your device before it lays out all the sub  views on the screen you have the chance to to do   any customization and then view did layout so I've  used again gives you that chance after the sub use  
have been laid out if you need to do anything  like maybe an animation or something like that
Concurrency & Threading
now this is a huge topic that I could do hours  and hours of videos on however we're going to   keep this video at a high level because the  entire point of this video is for you to be  
able to answer an interview question now during an  interview they're asking you a lot of questions so   they're not going to expect you to be an expert  and deep dive into this topic they're just going  
to want to know that you have a very basic General  understanding of what's actually going on with   concurrency and threading and with that being said  we're going to talk about the different thread  
types the main thread the background thread we're  going to talk about cues a little bit serial cues   concurrent cues and then we're also going to talk  about how Grand Central Dispatch kind of ties it  
all together and you can move things around from  different threads and cues all right let's dive   in so let's start with the big picture and what  is concurrency basically concurrency is doing  
multiple tasks at the same time now what allows us  to do this is Apple's multi-core processors here  
I have picture just an example of the latest  A10 processor which is a quad core processor   in the iPhone 7. so the more cores you have the  more tasks you can do at the same time now all  
these tasks are being executed on what are called  threads imagine threads is kind of like this major   highway each lane in the highway is a thread in  each car in that lane is a task being executed on  
that thread now you notice here pictured I have  a lane here on the left the express lane that's   real clean and Speedy and that is called our  main thread and the reason we want to keep our  
main thread you know speedy and clean is because  that is what our UI is done on so for example if  
you clog up this main thread with a very you  know time intensive task your UI is going to   freeze and your user is going to think your app  is locked up so that's why we do all those time  
heavy tasks on the background threads keep the  main thread clear so the UI is still responsive   now all this management of the main thread and all  the background threads you can have because you  
can have you know a lot of background threads can  get really hard and tricky however luckily Apple  
has built something for us called Grand Central  Dispatch and NS operation cues which is basically   just an API built on top of this threading to make  our lives as developers easier and essentially it  
just handles all the heavy lifting of creating and  managing threads for us as developers we just work  
with a QR pass give that to Grand Central Dispatch  and it just handles all the thread management   stuff for us it's pretty nice so by now you're  probably asking what's a cue imagine a queue  
like people lining up for Star Wars and I don't  know what kind of crazy people do this certainly   not me definitely definitely not me I lined up  for Star Wars and I loved every second of it but  
anyway it's a line so the first person in the line  is the first person to go into the movie theater  
it's called First in first out and that's really  all a cue is you just line up tasks and then the  
task that went in first is the first one to get  executed the second one is the second one to get   executed let's take a look so here you see all  our tasks come in task one is the first one to  
go it gets executed first then tax two will get  executed then three and so on and so on there's  
your basic cue now there's two types of cues we  have a Serial cue and a concurrent queue we're  
going to talk about the differences there we kind  of just saw the serial queue so we'll run through   it again real quick but the serial cue the tasks  come in in order and then task two doesn't start  
until task one is 100 complete test three doesn't  start until test two is 100 complete so everything  
happens one at a time in order now let's take  a look at a concurrent cue so in a concurrent  
queue everything still starts in the same order  so the tasks are going to start one two three   four however task two does not have to wait for  Task 1 to complete to start so therefore things  
will happen quicker but as you can see it's going  to be unpredictable on how things finish so you  
can see things start in order one two three four  however certain tasks are quicker than other tasks
let's take a look at that one more time now  imagine task 2 being something like downloading   a high-res image whereas task 4 is you know just  downloading some text so test two certainly starts  
first however task 4 happens much quicker so yes  concurrent stuff you're doing stuff at the same  
time so it ends quicker however the order of  completion is very unpredictable so this leads   us into the pros and cons of each when should you  use a Serial cue when should you use a concurrent  
cue let's talk about the serial queue first so in  a Serial queue it's a predictable execution order  
so everything happens in order one two three  four two doesn't even start until one is done   so this prevents race conditions which we'll  talk about in a second it's very predictable  
let's take a look so again the tasks come in task  one gets completed task two gets completed test  
three test four Etc everything's in order one at a  time pretty clean however as you can imagine this  
is slower because everything is happening one at a  time task two doesn't even start until task one is   complete so concurrent cues are faster because yes  they still start an order but everything is kind  
of happening concurrently or at the same time  however this results in an unpredictable order   and what I mentioned earlier in race conditions so  we're going to look at our example again here in a  
second but I want you to imagine something first  imagine task 3 and task 4 are related and your   code has some conditional logic that is relying  on task 3 to be complete before task four however  
you put it on a concurrent queue so you can't  guarantee the order of completion now sometimes   task 3 will be done before task four you can't  really predict that it all depends on how the  
system is managing the threads and the resources  and again that's why it's called a race condition   because you can never be certain which task is  going to finish before the other task and again  
that's why it has an unpredictable order again  remember the concurrent queue is a much faster   a way to execute a group of tasks however you just  have to not care about the order they get executed  
in so for example let's say you're saving a bunch  of user preferences you don't care what order they   get saved in you just want to be saved as quick as  possible so that's when you would use a concurrent  
cue and vice versa when the order of execution is  absolutely imperative then you would want to use   a Serial queue Now by default every app gets one  serial cue which is the main queue and then four  
concurrent cues which are your background cues  of various priorities now you can create your   own custom cues but for the most part this main  queue that you get in the four concurrent cues  
in the background that's usually more than enough  for what you need um if you want to create your   own custom ones that's probably more a little  more advanced but just know that you can do  
that so how do we switch back and forth between  these cues now you've probably seen this little   bit of code before this dispatchq.maine.async and  then you do some code in there a very common case  
when you would use this is what I have shown now  let's say you downloaded some Json data from the  
internet you're populating a table view once all  that stuff is done downloading you want to reload   your table view to show your data well all that  downloading stuff is happening on a background  
thread now you want to shift to a main thread to  update your UI remember the main thread is kind of   like the UI thread so here what this code is doing  it is dispatching off the background thread to  
the main thread and then here we are reloading our  table view data this is a very common little chunk   of code and updating your UI on the main thread is  something you'll do all the time as a developer so  
you'll see this a lot now you can move stuff  to a background queue manually here using   dispatchq.global and the qos stands for quality of  service and in this case we want it to be on the  
background and then you just run whatever code you  run run in this block now to be honest with you I  
have almost never used this code to manually send  something to a background queue I'm not saying   you're never going to use it but the previous  example of moving something to the main queue in  
the main thread is much more common than manually  sending something to the background thread but I  
did just want to show you this so you know it is  possible but again Far and Away the most common   way you're going to use Grand Central Dispatch is  moving stuff from a background queue to the main  
queue using this dispatchq.maine.async and then  doing something like reloading your table View
ARC & Retain Cycles (UIKit)
first I'm going to start off with a brief  description of what automatic reference   counting is and then we're going to dive into  some code to go over some examples all right  
automatic reference counting now this is Apple's  way of handling memory management of objects for   you now what it's doing is for each object it's  keeping account of how many strong references  
are pointing to that object for example let's say  I have a person class Sean there's also a camera  
class a phone class and a Macbook class now these  classes can all have a strong reference pointing  
back to Sean so automatic reference counting  is going to say that the count is four so if   I even if I made Sean equal to nil to try to  get rid of Sean from memory automatic reference  
counting won't allow it Sean will not be released  from memory because there's three other objects   pointing back to it how do we fix that we need  to make those strong references a weak reference  
so let's dive into some code and take a look at a  real life example okay let's do this first let me   walk you through the basic setup if you remember  in the introduction I talked about a person class  
a camera class a phone class and a Macbook class  in order to simplify this coding example we're   just going to deal with two of the classes  the person and the MacBook but it will still  
illustrate the point perfectly so let me walk  you through this person class let you know what's   going going on here a person gets initialized with  a name and a Macbook the MacBook is optional you  
may not have a Macbook maybe like Windows I  don't know and on lines 13 through 15 we have   our dnit call now this only gets called when the  object is actually released from memory so this  
is going to let us know when our object is clear  from memory and we don't have a retain cycle or   if it doesn't get called we do have a retain cycle  so you'll see this in action here in a little bit  
and then the MacBook class is very similar  uh the MacBook has a name the MacBook has   an owner which is a person object up here  this class up here on 24 through 27 it gets  
initialized with a name and an owner which is  the person object and again that's optional as   well just like the MacBook here for the person  and then same thing the D init this gets called  
when the MacBook is released from memory okay  let's dive into some code so the first thing   we need to do on the left here is create our  variables so let's go ahead and create Sean  
and Sean is of type person and it's optional  and then VAR uh we're going to call our MacBook  
Matilda I have no reason why just what I want to  call it and that's optional as well so we have  
our variables created I'm just going to break this  up into functions this obviously isn't a real app   but I'm going to break it into functions just  to separate the information and hopefully that  
makes it easier to learn so let's go ahead  and create a function called create objects
and in here we're going to go ahead and  initialize Sean and Matilda so Sean equals person  
and see our initializer method lets this  autocomplete so the name name is going to be   Sean and the MacBook right now is going to be no I  haven't gotten to the store yet to go buy it so I  
don't have a Macbook yet let's go ahead and create  Matilda she's sitting in the store waiting for me   to buy her so she's up type MacBook and again the  initializer method lets us go ahead and give her  
the name and the owner is no haven't bought her  yet so there you go so here's what we've created  
now so just by creating these objects as you can  see in the image here we have one strong reference   Sean has a reference to itself and Matilda has  a reference to herself you notice MacBook and  
owner still nil there's no references to each  other there so all good starting out let's go   ahead and call this here just so when I run it uh  stuff actually happens and just to prove that we  
only have one reference and we can dnit each other  so let's go ahead and just set Sean equal to nil  
and Matilda equal to no go ahead and run it  so as you can see down here in the console  
our dnit methods got called for both the MacBook  and the person so Sean is being de-initialized and   Matilda is being de-initialized so everything's  working fine no routine Cycles here okay let's  
go back up to create objects and get rid  of us uh kneeling out uh Sean and Matilda   let's create another function  called assign properties
and what this is going to do is now we're  going to create the strong references that   are going to cause trouble this is going  to cause the retain cycle so let's go ahead  
and fit Sean dot MacBook I went to the  store about my MacBook and it is Matilda  
and then Matilda now has an owner and it's me  Sean so there you go so as you can see in this  
image now we have strong references from Sean and  Matilda pointing back and forth to each other and   this is the bad thing this is the retain cycle  so Sean has a strong reference to itself strong  
refers to Matilda but Matilda is actually  pointing back to Sean now too with a strong   reference so back here in assigned properties  let's go ahead and make Sean equal to nil  
now let's go and make sure we call assign  properties here at the top now if you remember  
what I said in the intro because there's an  outside object pointing to Sean in this case   matilda.owner is pointing to Sean Sean will not  be removed from memory and the reason is is you  
only get removed from memory when the automatic  reference count equals zero so even though I got   rid of Sean's strong reference to itself there's  still Matilda pointing to Sean so there's still  
one left so it's not going to be de-initialized  so let's go ahead and run it to prove that okay so   it's running uh you're just gonna have to trust me  on that my simulator's on another screen nothing  
got printed out so there's no way for you to know  but trust me it's running in our dnit method over   here in lines 13 and 14 of our person class is  not getting called and again the reason is because  
there's still a strong reference pointing from  Matilda to Sean so Sean cannot be de-initialized   now as I mentioned in the intro the fix for this  is to make one of the variables weak over here in  
our classes now this depends on how your data is  structured for this example let's say the MacBook  
is the Lesser important object so we're going to  go ahead and make the MacBook the weak variable  
so as you see here on line 22 I made the owner  variable which is a person weak so now if you   look at this updated image you see Sean still  has a strong reference to itself it still has  
the strong reference to Matilda but now there's no  longer a strong reference pointing from Matilda to   Sean so now when I make Sean Nill he's able to be  released from memory because Matilda's not holding  
on to him from the outside anymore so let's go  ahead and test that go and run it and as you can   see in the console now our dnit method for Sean  is getting called and Sean is being de-initialized  
so now let's double check something let's test  out let's go ahead and print Matilda dot owner  
right Sean's no longer memory Matilda should no  longer have an owner let's go and run that so as   you can see in the console again Sean is being  de-initialized so Sean's gone he's away from  
memory and now Matilda's owner is no Matilda no  longer has an owner because Sean is gone so we've   cleared our retain cycle and just for good measure  we can go ahead and set Matilda equal to nil as  
well now now that the Sean strong references don't  exist go ahead and run that just to double check  
so as you can see bolsha and Matilda can now be  removed from memory whereas before when they have   their strong references pointed back to each  other neither one of their strong reference  
counts would have ever gotten to zero so they  could have never been deallocated for memory   if you have a lot of these throughout your code  it really affects the performance of your app

----------

-----
--07--

-----
Date: 2023.05.17
Link: [# 15-Year-Old App Goes All Swift | Caffeine Refactored | @SwiftBird](https://www.youtube.com/watch?v=fehxCCKWpZA)
Note:
### Summary of the Content

This video by Yakov from The Swift Bird blog shares the journey of rewriting the Caffeine app for Mac in Swift. Yakov discusses the motivations behind the switch from Objective-C to Swift, the challenges encountered during the process, and the improvements made to the app.

### Advantages of Switching to Swift

- **Language Efficiency**: Swift's modern features allowed for more streamlined and robust code.
- **Enhanced User Experience**: The transition aimed to maintain the simplicity and functionality that Caffeine users have come to expect, without altering the app's familiar interface.

### Challenges in Transition

- **Integration Hurdles**: Mixing Swift with Objective-C presented significant challenges, such as import loops and the need for extensive forward declarations.
- **AppKit API Limitations**: Updates to macOS and AppKit's APIs necessitated workarounds, especially for the app's menu bar icon functionality.

### Key Takeaways and Tips

- **Step-by-Step Approach**: Yakov recommends a phased approach to transitioning languages within a project—starting with a literal translation before moving on to refactoring.
- **Swift's Enums for Clarity**: Utilizing Swift's enumeration capabilities can significantly reduce the reliance on "magic numbers" and improve code readability.

### Technical Insights

- Yakov provides a detailed account of converting Objective-C code to Swift, addressing the specific changes made to the time presets and the menu-bar icon.
- The video highlights the limitations posed by deprecated AppKit APIs and describes the creative solutions employed to maintain the app's one-click activation feature.

### Accomplishments and Reflections

- **Successful Rewrite**: The project successfully updated Caffeine for modern macOS versions, leveraging Swift's strengths to enhance the app's codebase.
- **Continuous Learning**: Yakov views Caffeine as a learning project, expressing satisfaction with the rewrite and curiosity about exploring SwiftUI for future developments.

### Interesting Quotes

- "Even though Swift is advertised as a more safe and reliable programming language—and it is, undoubtedly—using it in the mixed environment takes some compromise."
- "Caffeine, just as all of my side projects, is first and foremost a playground where I can learn and practice with new technologies."

### Conclusion

Yakov concludes by sharing his contentment with the rewrite and his plans to delve into SwiftUI, emphasizing the joy of learning new technologies through software development. He encourages viewers to support the channel and teases upcoming content.

### Engagement Encouragement

Yakov invites viewers to like, subscribe, and consider supporting The Swift Bird for more tech and software development content, promising more insightful videos in the future.

Transcription:

Intro
Hey! I’m Yakov, and this is The Swift  Bird, a blog about tech, software,  
and birds. From time to time, I cover  some of my own projects on this channel,  
and in this video, I’ll tell you about  how I rewrote the Caffeine app in Swift.
If you find this video helpful or at least  entertaining, please give it a like and  
subscribe to the channel. You can also support  me with a small donation at the links below.
Now, let’s get started!
About Caffeine
Caffeine is a small Mac utility which prevents the  computer from going to sleep. It was originally  
published back in the mid-2000s and last  updated over ten years ago. Since then,  
the company behind Caffeine has  gone out of business, but luckily,  
it open-sourced the code. Ever since I learned  about Caffeine, I used it nearly every day for  
reading long documents, exporting videos,  and doing other tasks. But as macOS evolved,  
Caffeine’s degraded to the point where the Mac  refused to even launch the app—just because it  
wasn’t signed with a valid certificate. And at  that point, I decided to do something about it.
In my previous video on Caffeine, I explained  what I found in the open-source repo and what  
I did to modernize the app. I reused  the original Objective-C codebase,  
and the result was good enough to put  the app on the App Store. But if you’re  
Why Switch to Swift
familiar with both Objective-C  and Swift, you know how much you  
can improve and optimize by switching to the  new language. And that’s exactly what I did.
I wanted to preserve the look and feel that users  expected from Caffeine, and because of that,  
I didn’t feel comfortable to just scrap the old  code and write new one from scratch. Instead,  
I followed the step-by-step approach:  literally translating the code first,  
and then refactoring it  with Swift-native solutions.
Translating the Code Literally (What Could Go Wrong?)
When you introduce the first batch of Swift  components, Xcode provides a Swift header. You  
import it in existing Objective-C files to make  Swift symbols visible. Normally, you don’t see the  
header file in the project structure ’cause it’s  generated on the fly. However, you can influence  
what goes into the file by annotating your Swift  components with the @objc attribute: in the end,  
only the symbols which have this attribute  become available to the Objective-C runtime.
The Swift header has a counterpart—the bridging  header. The latter is used for interacting with  
Objective-C code in Swift. But unlike the Swift  header, the bridging one requires more manual  
work—just as everything else in Objective-C.  You get an actual file in the project folder,  
and inside the file, you list the components  which should be available in Swift.
I started with importing only the  precompiled header, or PCH. In the  
Objective-C part of Caffeine’s codebase, this file  was responsible for importing the Cocoa framework  
and global constants—that way I didn’t have to  manually import them in each individual file.
Up to that point, everything was going fine. But  as soon as I imported an actual component of the  
app, something nasty appeared—an import loop. You  see, Swift’s module-based system is pretty smart  
about resolving dependencies between components:  all the symbols that sit inside the same module  
can see and interact with each other. The most  common case where this gets handy is when you  
define a delegate protocol. The component itself  keeps a reference to the delegate declaration,  
but delegate methods often use the component’s  type in their signatures. With Swift being smart  
enough to figure out the relationship  between the component and its delegate,  
you don’t need to do anything extra: they  just know about each other’s existence.
But the languages which use headers require  you to think in advance. You cannot import  
the delegate’s header in the component,  and then import the component’s header in  
the delegate, because that would result in  a cycle—sort of a chicken-or-egg problem:  
the compiler just doesn’t know where to  start resolving imports and dependencies.
This problem is usually solved with forward  declarations: you put one in a file,  
and by doing so, you’re just saying,  “I won’t import the actual header,  
but I can guarantee that this component exists.”  If you’ve been making software for a while,  
you know that just trusting the developer is  never a good idea. But on the brighter side,  
you can go piece-by-piece and forward-declare  each component only when it’s needed:  
it’s possible to do so because each component has  a separate header, so you sacrifice only a little.
However, when one of the components comes from  Swift, things become less convenient and safe.  
That’s exactly because you have just one Swift  header for the entire module. You lose that  
sort of granularity. At that point, the number of  forward declarations in Caffeine’s codebase grew  
dramatically, despite my attempts to start the  refactoring with the most isolated components. So  
even though Swift is advertised as a more safe  and reliable programming language—and it is,  
undoubtedly—using it in the mixed  environment takes some compromise. I’d  
say mixing Swift and Objective-C within a single  module puts it in a pretty unstable state:  
ideally, you should separate the  languages at module boundaries.
With some degree of pain, I did finish translating  Objective-C into Swift. I’m not showing you a lot  
of code here because there wasn’t much to look  at: it was literally a line-by-line translation.  
And thankfully, I was able to remove everything  Objective-C-related at the end of the process,  
so the bridging header and the forward  declarations were no longer needed.
And here comes the more interesting part,  where Caffeine gained an actual Swift flavor.
Adding Some Swift Flavor
The thing I was concerned about the most was  time presets. If you used Caffeine—and if not,  
you’ll find the link in the description—you  know that it lets you specify for how long  
the app should be preventing the computer  from going to sleep. Once the timer’s fired,  
the normal behavior is restored. In the original  version I cloned from GitHub, this was achieved  
through a combination of integer literals and  “magic numbers.” For example, positive numbers  
denoted the timeout in minutes, -1 meant that the  app should not disable automatically, and so on.
You probably know that “magic numbers” are a  code smell. They are literally an open gate  
for bugs and confusion. Luckily, Swift provides  a much better tool—enumerations, or enums. Just  
to be clear, enums exist in Objective-C as well,  but in Swift they’re much more powerful. If I’d  
started refactoring the magic numbers before the  code was rewritten in Swift, I would’ve needed  
two entities: one for specifying whether Caffeine  should autostop at all, and another for specifying  
the timeout. Swift let me encapsulate these  features in a single enum with associated values.
Updating the Menu-Bar Icon (Did Apple Break AppKit’s APIs?)
One more thing that’s gotten a major  overhaul was the icon displayed in  
the menu bar. It benefited from Swift as  well, though to a lesser extent. Changes  
in the AppKit framework played a bigger  role in the update, after all. Plus,  
I had to fix a problem that didn’t exist before.  And, frankly, I’m not really happy with the fix.
Here’s a quick overview of how the icon worked  before the change. In older macOS versions,  
icons in the menu bar used to be just regular  views: you could display anything and handle  
user interaction any way you wanted. A few  releases ago, however, Apple began restricting  
the capabilities and deprecating the old APIs.  In El Capitan, the properties and methods used  
for working with custom views got deprecated. You  were given the button property instead and were  
supposed to do only two things: set an image  or title that displays in the menu bar, and  
specify the menu which opens on click. Not some  arbitrary action but a concrete NSMenu instance.
I assume Apple did so for two reasons. On the  one hand, it wanted to make manipulating the  
menu bar easier, and on the other, Apple’s  goal was achieving better consistency across  
all apps and all environments: Light and  Dark Modes, different menu-bar heights,  
you name it. I suppose these new APIs  work pretty well for most of the apps,  
because who wants to mess around with  drawing views in frames, like it’s 2008.
However, Caffeine required a bit more flexibility.  You see, the app appeals to many users because  
of its simplicity: when you want to disable the  computer’s sleep, you don’t have to open a menu  
and select something from the list—instead you  just click the icon; but at the same time, more  
advanced options are just one click away—except  now you click with the other mouse button.
AppKit’s out-of-the-box behavior didn’t support  that, so I had to find a workaround. Initially I  
wanted to continue using the deprecated view  property and only convert it to Auto Layout.  
But macOS Ventura didn’t want to give up that  easily. Eventually, I gave up and switched to  
the new button property, so a separate component  for the menu-bar icon was no longer needed.
However, dropping the one-click activation was  absolutely not an option because as a user,  
I would hate this sudden  complication. As a result,  
I came up with a somewhat dubious solution:  tracking button events target-action style  
and handling them manually: you know,  when one of the mouse buttons is pressed,  
Caffeine activates immediately, and when  the other is unpressed, the menu opens.
And yeah, I said “unpressed;” it wasn’t a mistake.  Just as the solution was around the corner,  
I suddenly found another quirk in the menu-bar  logic. Apparently, if the menu opened as the  
button was pressed down, it didn’t unpress  automatically. I researched other icons but  
didn’t get any conclusive findings: some of them  showed a menu with either button pressed down,  
others only responded to the left one, and  a couple apps didn’t do anything until the  
button was released. These results had gotten  me stumped, so I decided to just leave it as  
is. Maybe I’ll revisit this thing down  the roadmap. Speaking of the roadmap…
Conclusion + What’s Next
Caffeine, just as all of my side projects, is  first and foremost a playground where I can learn  
and practice with new technologies. Strictly  speaking, the entire Swift transition wasn’t  
really needed—the app worked pretty fine without  it. But I wanted to challenge myself at how much  
smaller and more elegant I can make Caffeine’s  code. I’d say I’m satisfied with the results,  
and that little icon quirk will be the  subject of my next caffeine-inspired research.
But a much bigger research subject will  be SwiftUI. I’m still skeptical about it,  
especially when it comes to Mac apps. I can’t  say for sure that Caffeine will transition  
to this framework—in part because doing so  would require dropping older macOS versions.
But again, Caffeine is a  play-and-learn project to me,  
and that’s what I enjoy about software  development: it lets you learn every day.
Outro
That’s it for today’s video. If you found it  helpful or entertaining, please hit the like  
button and subscribe to The Swift Bird. You also  help me maintain this channel when you sponsor  
it at the links below. I’ll see you later—next  week probably—and until then, have a great time!

----------

-----

--06--

-----
Date: 2023.11.01
Link: [# All You Need to Know About Swift Macros | Swift Macros Deep Dive (Part 1) | @SwiftBird](https://www.youtube.com/watch?v=LrY9f5kOQ_4)

Notes:
### Summary of the Content

This video is the first part of a two-part series focusing on Swift macros. The presenter, Yakov from The Swift Bird channel, dives into the concept, implementation, and potential benefits of using macros in Swift programming. The goal is to provide a comprehensive understanding of Swift macros, starting from their inception and rationale to a detailed examination of their operation and applications. The second part, promised to follow shortly, will include hands-on examples of writing, debugging, and testing macros.

### Advantages

- **Swift Evolution**: Macros represent a significant advancement in Swift, allowing for more compile-time checks and reducing runtime errors.
- **Reduced Boilerplate**: Macros can significantly reduce repetitive code, making development faster and more enjoyable.
- **Increased Safety**: By shifting more checks to compile-time, macros contribute to writing safer and more reliable code.

### Drawbacks

- **Complexity and Risks**: Integrating macros adds complexity to the development process and comes with its own set of risks, particularly if the macro expansion introduces errors or unexpected behavior.
- **Limited Access**: Macros operate in a sandboxed environment without access to the surrounding code, which may limit their applicability in certain scenarios.

### Tips and Advice

- **Understand the Basics**: Before diving into macro writing, have a solid grasp of Swift's compilation process and the role of macros within it.
- **Debugging Macros**: Leverage Swift's ability to detail the macro transformation process for effective debugging.
- **Stay Informed**: Keep an eye on the ongoing development of Swift macros, as their capabilities and limitations are subject to change.

### Main Challenges

- Learning Curve: Grasping the concept and syntax of macros, especially for developers new to compile-time code transformation.
- Debugging: Identifying and resolving issues that arise from macro expansions can be challenging without a thorough understanding of their workings.

### The Importance and Usefulness of the Topic

Swift macros are poised to revolutionize Swift development by making code more concise, type-safe, and error-proof. This series aims to equip Swift developers with the knowledge to leverage macros effectively, enhancing both the development process and the quality of the resulting software.

### Accomplishments

- **Comprehensive Overview**: Provides a thorough introduction to Swift macros, including their rationale, types, and operational details.
- **Practical Insights**: Promises hands-on examples in the upcoming part 2, aiming to bridge theory with practical application.

### Interesting Quotes or Insightful Sentences

- "Macros are another step in this direction. By using them, you can implement even more safety checks at build time."
- "Macros are kept separate from everything else. This ensures predictable results—which is a huge plus."

### Lecture Content: Technical Insights

- Detailed exploration of the Swift compilation process and how macros fit into it.
- Discussion of attached and freestanding macros, including their distinct characteristics and use cases.

### Conclusion

The video sets the stage for a deep dive into Swift macros, highlighting their potential to streamline Swift development through compile-time code transformation. With the promise of hands-on demonstrations in the upcoming second part, viewers are encouraged to familiarize themselves with the foundational concepts presented here to fully benefit from the practical applications to be covered.

Transcription: 

Intro
Hey! Welcome to the Swift Bird! I’m Yakov.
Now that Apple has released all  of this year’s major OS updates,  
it’s time to have a deeper look at  what they can offer to us, developers.
Recently, I published a video about the  latest Swift update, version 5.9. One of  
the biggest features this time was macros, and  in my video, I give a brief overview of what  
they are about. I’ll post a link to that video  somewhere here, in case you need a refresher.
It may come in handy, because today, I’m going  on a big journey to learn everything there is  
to know about Swift macros. I’ll have a  look at the vision behind them and some  
implementation details. And of course,  I’ll be writing a few macros of my own.
Well, kinda. I initially filmed this as a single  video, but the result turned out so loaded  
with details, I decided to make it a two-parter  instead. So in this video I’ll be having a look  
at macros in general: how they emerged, how they  work, and how they fit into the big picture. And  
in part 2, which you’ll see in a few days, I’ll  be writing, debugging, and testing my own macros.  
Again, this only came up in post, so the following  narrative doesn’t reflect this change of plan.
If you’re only interested in the tutorial part,  you can skip to that section in the video. But I  
hope you’ll join me on each stop. Knowing how to  use a tool is very helpful for practical tasks,  
but understanding why it was designed this  way makes you a much better engineer. Besides,  
while I was doing the research and  experimenting with my own macros,  
I found several caveats which you’ll  understand better if you don’t skip anything.
If that sounds good, give this video a  thumbs-up, subscribe to The Swift Bird,  
and prepare for the ride. And if you wanna  see more of such content in the future,  
consider supporting this little  channel at the links below.
Ready? Now hold your breath,  because we’re taking a deep dive.
Macros—a Logical Step in the Evolution of Swift
My first stop on this journey is gonna be  discovering the reason why macros were added,  
in the first place. I mean, didn’t  Swift already offer us all the tools  
we need to create great software and,  in the meantime, enjoy the process?
There’s actually a pull request in  the Swift Evolution repo on GitHub.  
The document in this PR answers  many questions about how macros  
came to be. I’ll post a link in this video’s  description, so you can have a look later.
But instead of just going through this document,  
I’d like to draw your attention to one  global trend in the Swift evolution.  
If you look at its history from the very  beginning, and especially if you compare  
Swift to Objective-C, you’ll definitely see  one idea that comes up over and over again.
Take a look at this code. It’s just  one class method calling another one,  
right? Notice anything strange?
Well, this code compiles and  launches normally. But that  
doesn’t mean it works the way I  wanted. It’s quite the opposite,  
actually. The first method has a typo,  so the second one will never be called.
But Objective-C isn’t really concerned.  Because of its dynamic nature,  
it just assumes that some symbol  will match the call at runtime.  
There’s quite a few techniques for  supplying implementations indirectly:  
swizzling is one of them. This behavior  doesn’t make Objective-C a badly designed  
language. But its paradigms sometimes make it  pretty hard to write, maintain, and debug code.
So here is the same code in Swift. As soon as you  try to call a method that doesn’t exist, you get  
a compiler error. You’ll notice something’s wrong  way before you even have a chance to run the app.
Okay, you may say comparing  Swift and Objective-C isn’t fair.
I kinda agree. They were created in very  different eras of technological history.
Then here’s another example.
That is how you decode JSON in Swift 3.
And that’s how you do it in Swift 4.
The Decodable protocol not only  made the code more compact,  
but it also made it impossible to  mess up property names. Once again,  
the responsibility for checking everything  shifted from the runtime to the compiler.
KeyPaths are another example. But I  won’t go into detail. You get the idea.
Swift is becoming more static-oriented.  In other words, more aspects are checked  
while you’re writing the code, and  fewer—when the code is running.
The benefits are clear. The  feedback loop becomes shorter;  
you spend less time debugging, and can more  often write the correct code on the first try.
Macros are another step in  this direction. By using them,  
you can implement even more safety checks  at build time. Besides, macros can reduce  
the amount of boilerplate—the code for common  tasks, which you write over and over again.
Hopefully, by the end of this video,  
you’ll see how macros can make your  work faster and more enjoyable.
Macros Behind the Scenes (+ Compilation-Process Overview)
Now, let’s talk about how  macros work behind the scenes,  
and what they can and cannot do with your code.
At this point, it may be helpful to  understand what happens with your code  
after you click the Build button. I’m not  going too deep into compiler design today,  
but I’ll give you a simplified explanation  tailored to this video’s topic. By the way,  
let me know in the comments if you want an  in-depth video about the Swift compiler.
So, there are three steps we’ll have a  look at today. There’s more in total,  
but the others aren’t really important for macros.
The first one is parsing. Even though Swift code  is not an article or poem, it’s still just plain  
text. It doesn’t have a defined structure. While  it stays like that, the computer cannot do much  
with it. To fix this, the code is tokenized and  transformed into an abstract syntax tree, or AST.
The tokenizer goes through your code while  paying attention to keywords, such as func,  
if, or return. These words declare operations  which help construct the tree and define the  
relationships between its nodes. Here’s  what an AST may look like in the end.
Once the tree is constructed, the compiler  can understand and reason about it. If your  
code doesn’t contain lexical errors, such as  typos, missing returns, or unknown symbols,  
it can be compiled into machine code, a bunch of  ones and zeroes which the processor can execute.
It’s not really machine code at this point.  Because the Swift compiler is based on LLVM,  
it uses the intermediate representation—sort  
of a universal language. The IR acts as a  bridge between the language of your choice,  
be it Swift, Rust, C, or something else,  and the processor architecture: ARM, x86,  
PowerPC, and many more. This is somewhat  similar to the Java Virtual Machine,  
but in contrast it allows the program to run at  the native speed, without any runtime translation.
I won’t go any deeper, but I decided  to highlight this mechanism because I  
believe it’s such a cool feature. I’ll  leave a few links in the description,  
and I encourage you to have a  look at them when you have time.
Once the compiler’s done its job, the linker  comes into play. It looks for any outstanding  
references to external libraries, and makes  sure those calls are handled correctly.
How (and When) Macros Work
There’s a few stages after that, but  we’re interested in the three steps  
I described. To be precise, in the gap  between parsing and compilation. It’s at  
this point that macros are enacted. And, after  compilation, it’s as if they don’t even exist,  
so remaining build phases occur just as always.
Macros are basically separate programs.  They’re built independently of your app’s  
code and run before the main compilation stage.
Once the app code is transformed into an  abstract syntax tree—but before it’s turned  
into machine code—Swift macros get their chance  to shine. They receive the part of the syntax  
tree belonging to the macro, and they transform  it into a new structure. Besides the syntax tree,  
the macro implementation also receives  any input you provided explicitly.
Macros can add new code which is then fed to  the Swift compiler along with your original  
code. However, macros cannot modify or  delete any existing code of your app.
Moreover, they don’t even have access  to it. That’s because macros run in a  
sandboxed environment with no access to your  source file, any other files on the disk,  
or the internet. Just like I said, macros are  kept separate from everything else. This ensures  
predictable results—which is a huge plus. But  it also means that the macro cannot see any  
code which comes before and after the call. So  the macro’s logic cannot take it into account.
The macro code, as well as its input and  output, are checked just like any Swift  
sources. If something’s wrong, the macro build  fails, which in turn triggers your entire build  
to fail. So by integrating macros, you assume  additional responsibilities and risks. However,  
you can ask Swift to show the transformation  process in detail. Thanks to that, macros are  
not some black box to you. I’ll get back  to macro debugging later in this video.
Four Steps of Macro Expansion
Let’s now have a closer look at how macros work.  
This process has four steps, and  they are pretty straightforward.
First, the compiler reads your app code  and creates an in-memory representation  
of the syntax. It’s the very same  parsing step we discussed earlier.
After that, the part of your code’s  AST relevant to the macro call is  
sent to the implementation. The  implementation processes this AST  
and returns the updated structure.  This process is called expansion.
Next, the code returned from the macro  is put back where the macro was called.  
The compiler basically replaces the  macro call with its expanded form.
Finally, the compiler takes the updated code  and continues with the normal compilation.
At this point, you can see how  Swift compilation works in general,  
and how it integrates macros into  the process. Before I start writing  
Attached and Freestanding Macros
and calling macros, there’s just a  few more things I want to highlight.
As you probably know, Swift  offers two kinds of macros:  
attached and freestanding. They’re  similar in how they work at a high level,  
but they differ in where you can use them and  what you can actually achieve by doing so.
Attached macros modify the declarations  they’re used with, such as classes, properties,  
or methods. Without a declaration, attached  macros don’t make much sense and cannot be used.
They can add new capabilities  to the declaration. For example,  
they can define a new method or  declare conformance to a protocol.
Freestanding macros, in contrast, can be used  all by themselves, without being attached to  
some symbol. But there’s more than one flavor  of freestanding macros—there’s actually two.
Declaration macros introduce new symbols,  such as classes. And expression macros produce  
values or perform actions. An example  of an action is compiler diagnostics,  
such as warnings or errors—expression  macros can trigger them based on some  
logic. The difference between declaration  and expression macros is pretty significant,  
and it determines how you  declare and implement the macros.
To Be Continued…
Which finally brings us to the part where I  actually write, use, and debug some macros.
And… you’ll see all of that in part 2 of  this video. It should be out in a few days,  
but my main goal here is to make it  as clear and detailed as possible,  
so I’m not rushing it, I’ll be honest. In the  meantime, let me know if you have any questions  
so I can answer them in the second part. Don’t  forget to subscribe, and stay tuned for more.

----------

-----
--05--

-----
Date: 2024.02.12
Link: [# SwiftUI Navigation Made Easy: Harnessing the Magic of Enums](https://www.youtube.com/watch?v=do4uZBXP6bc)

Notes:
### Summary of the Content

The tutorial introduces an efficient and elegant way of handling navigation in SwiftUI, focusing on decoupling navigation from views using enums and navigation link values. It starts with a basic Xcode project setup and demonstrates how to create enums for navigation stack destinations. The tutorial also introduces a method for using these enums with navigation links in SwiftUI views, including the application of dependency injection for navigation destinations. Furthermore, the video mentions mentoring services for iOS development and hints at future topics like integrating sheets into SwiftUI navigation.

### Advantages

- **Decouples Navigation from Views:** Enhances code modularity and readability.
- **Uses Enums for Navigation Destinations:** Provides a clear and organized way to manage navigation paths.
- **Supports Dependency Injection:** Facilitates passing data between views seamlessly.

### Drawbacks

- **Complexity for Beginners:** The concepts and implementation might be challenging for SwiftUI beginners.
- **Specific to SwiftUI Navigation:** The methods discussed are tailored to SwiftUI, limiting applicability to other frameworks or UI toolkits.

### Tips and Advice

- **Subscribe and Like the Video:** To support the series and receive updates on future tutorials.
- **Consider One-on-One Mentoring:** For personalized guidance and advanced learning in iOS development.

### Lecture Content

- Efficient navigation in SwiftUI using enums and navigation link values.
- Decoupling navigation logic from views.
- Implementing navigation destinations with dependency injection.

### Main Challenges

- Understanding and applying the concept of decoupling navigation from views.
- Implementing enum-based navigation stack destinations effectively.

### Importance and Usefulness of the Topic

Navigating efficiently in SwiftUI is crucial for developing intuitive and maintainable iOS applications. The techniques discussed improve code organization, facilitate data passing between views, and enhance the overall development process.

### Accomplishments

- Demonstrated a method to simplify navigation in SwiftUI.
- Introduced a practical application of enums and navigation link values in navigation.
- Provided a foundation for integrating more complex navigation patterns, like sheets.

### Interesting Quotes or Insightful Sentences

- "Navigation in SwiftUI is confusing, to say the least. Let's fix it."
- "Decoupling all of that from the views is the easiest way of doing that through creating some sort of a coordinator router / enum."
- "As a passionate iOS developer aiming to advance your skills, partnering with me as a mentor could significantly impact your career trajectory."

### Where to Go Next

- The tutorial promises to cover the integration of sheets into SwiftUI navigation in the next episode, indicating a continuation of advanced navigation techniques in SwiftUI.
- Encourages viewers to subscribe and check out one-on-one mentoring sessions for deeper learning and personalized guidance in iOS development.

Transcription:

INTRODUCTION
Navigation in Swift UI is confusing to say the least. There's Navigation Stack and Sheets and  
Navigation Link and values. It is a mess. So let's fix it. In this tutorial series I'm going to  
cover the most efficient and elegant way of using  Navigation in SwiftUI. From Links to Sheets from  
values to navigation destinations, we are going to  cover it all. So let's jump right in. And if you'd  
STARTER XCODE PROJECT
like to hire me on a one-on-one session go ahead  and check out rebeloper.com/mentoring. Now today  
is the first of a series where we are going  to digest and make navigation super fun and easy  
in SwiftUI. So for that I have just started a  an Xcode project with some files already added  
in here. As you can see we have our content view.  It has a tab view, it has root 1 view root 2 view  
here is the root 1 view and root 2 view with some notes here what I have to  
do today and then we have destination 1 view  and destination 2 view. Today we are going to  
talk about how you can make your navigation  decoupled from the view with the help of enums.  
And we are going to continue on that so make  sure that you SUBSCRIBE to the channel and  
maybe LIKE this video also if you do enjoy it  because there is more to come. This is the first  
in a series. So what do we want to do? Well we are not going to use the default navigation stack  
ENUM NAVIGATION PLAN
either with a puff or without a puff with the  navigation link, we want to decouple  
all of that from the views. And the easiest way  of doing that is through creating some sort of  
a coordinator router / enum because that is  what we are going to use as our building block.  
So let's create a new file and I added the  tab view so you can see that we have to create all  
of these enums for the different navigation stack destinations so called but you will see  
why this project is starting as it is. So let's click on the file art over here let's click on  
NAVIGATION LINK VALUES
next and what we are going to do right over here  is specify some values. Most probably you already 
seen some navigation stack tutorials where we have some values. Well this is where we are going to set them up.
So I'm going to name this appropriately. So it will be root 1. So it's the navigation stack for  
our root 1 tab view and navigation link values.  Navigation link values because all of these  
destinations will be added onto a navigation link, okay. So that's our file and let's import SwiftUI  
we are going to need that and let's create our  enum and that will be our root one navigation  
link values and because we are going to use this  inside the navigation destination this has to  
be hashable. So there you go and then because we  want to set all of our destination views right  
over here inside the enum this will be a view. It's really, really interesting right? So let's have  
two cases in this enum. So case destination 1  and then case destination 2 and for  
destination 2 we are going to use dependency injection. So you rest assure that you know how  
to do that. Currently I'm just going to add add in  the title and that is of type string but of course  
you can add in any hashable right over here, any  hashable model that you might want to push through  
the destination 2, okay. So those are the two  cases now it's time to add our actual views.  
It's as simple as that. As a passionate iOS developer  aiming to advance your skills partnering with  
MENTORING
me as a mentor through rebeloper.com/mentoring  could significantly impact your career trajectory.  
Art with extensive industry experience and a  profound comprehension of iOS development, I offer  
invaluable perspectives hands-on expertise and  effective strategies to navigate the complexities  
of app creation. Prioritizing practical abilities,  current industry insights and streamlined coding  
methodologies. I am dedicated to equipping you  with the knowledge and proficiency essential  
for success in the dynamic realm of iOS  development. Come join me at rebeloper.com/mentoring
and together let's elevate your journey in iOS development. So as you can see we are not conforming
ADD A VIEW INTO AN ENUM
to the view protocol just yet, what we need to do is add our body. And here it is our body and now we need to switch through  
all of our cases. So let just go switch self and  I'm going to use Xcode autocompletion right over here  
so it's helping me out really nicely. We have  destination 1 and 2 and right over here  
we are going to add destination 1 view and then  right over here destination 2 view and I'm moving  
the title forward so into the destination 2 view.  And that's it. It's really as simple as it gets.  
Now let's move forward and let's see how are would  we actually use this root one navigation link  
these values. So let's go to our root 1 view and  here we would just add a navigation link to the  
ADD A NAVIGATION LINK
destination 1 view. So let's just add it. So let's just see navigation link and we are going  
to use the one with the value and label. You could just use the title key and value but yeah whatever  
you see it fit. Make sure that you are using  the one with the value. So the value, here comes  
the really, really fun part it will be root 1,  what's it called, 'roort', let's let's rename  
that because I see that I made a  typo right over here. Refactor, rename. It has to  
be a root instead of 'roort', oh really nice, okay. So let's go back to our root 1 view command that  
back in and then root 1 destination, well well  it's not autocompleting, I'm just going to  
well actually not destination, navigation link. So root 1 navigation link values dot and where do  
I want to navigate over here? Well to destination 1 and then the label, let's have a text right  
over here of destination 1 view. I'm just going to copy and paste it right over there.
So that's one and now I also want to show you  how you can move the actual title, well you know  
dependency injection. We are going to set the  navigation link on the destination 1 view to  
move to the destination 1 view. Right over here  let's just have again the value and label and  
that will be root one navigation link values dot  and now we just choose the destination to view  
and the title let's just say it's Ada and then  the label again a simple text to show where  
we are actually going to go, okay. This is how we move. This is how we navigate. It's really, really  
straightforward. Now we do have to set all of this  up because you know this isn't set up inside a  
SET UP NAVIGATION DESTINATIONS
navigation stack at all, just yet. So let's do that. Let's go to the content view. As you can  
see we have root 1 view and the tab item. What we want to do is add this into a navigation stack
of course as usual and then on the navigation stack  we want to set up our navigation destinations.  
And of course if you are a little bit familiar  with navigation stack you want to add it  
onto the root of the navigation stack. So you just say navigation destination and we are going to use  
the one for and destination. So the for that is  our root 1 navigation link values dot self  
and usually what you would do as the next step  you would just hit Return and that would just  
make this hashable available and  according to the value. You would just navigate  
away somewhere, but remember we don't have to  do that in this case because we have our  
body. So we just add in these two brackets  and then dollar sign zero. So it will use itself.  
So the value is a hashable which is fine. It will use itself. Why I mean by itself? Well because it's  
a view. According to the case it will just use itself. It's really, really straightforward, okay.  
So now let's build and run and let's see if we  made everything set up correctly and if we do we  
TESTING THE IMPLEMENTATION
are going to have also a view extension which  will make this a little bit easier. So here we  
have tab 1, tab view that's nice. Destination 1 view, it's working. Destination 2 view.
It's moved Ada into that view. We can just go back over  there which is really, really nice, okay. So that's  
fine but what if I want to add  this also to the root view controller. So I create  
CREATING A VIEW EXTENSION
another root to navigation link values then put  it in the navigation stacks. Set the navigation  
destination and this is kind of encryptic  you know not many developers know about this.  
So let's just create a view extension on this.  So I'm going to create a new file right over  
here call it view+, so it's  an extension on the view. We do need to import  
SwiftUI right over here and it's an extension on  the view, there we go. And I'm just going to add in  
here our navigation link values. So that function  will be called navigation link values and we are  
going to add in some type of data. You will see  in just a second. I'm going to name this   
of type D and then a data and that will be D dot type, there we go and we are going to  
return some view and here we need to specify  what this 'D' is. So where D is hashable and view.
Basically that's it. Now I can just go to our  
content view and try to replicate all of this stuff. So first of all we need a Navigation Stack  
and inside the Navigation Stack we are going to  use self because this view modifier will be added  
to a certain view. We're going to use self dot and  then navigation destination for, what's the hashable  
well that's the data and the destination well  that will be again $zero. it's really,  
really nice. Now we can go back and on the content view we can just replace all of this mumbo jumbo  
so let me just comment this out, so you will be  able to see it later on. I'm just going to use root 1 view
and then navigation link values, there we go. Navigation link values and just provide that  
protocol. So root navigation link values dot self, much nicer if I do say so myself, okay. This is as easy  
as it gets now we have decoupled navigation but we  did not cover Sheets. So if you want to know  
WHERE TO GO NEXT
how we are going to add sheets to this make sure that  you SUBSCRIBE to the channel hit that notification bell
to get notified and we are going to cover  sheets and some more in the next episode and if  
you'd like to meet me on a one-on-one Zoom call  go ahead and check out rebeloper.com/mentoring.

Ponowne odtwarzanie czatu jest wyłączone podczas tej

----------

-----
--04--

-----
Date: 2024.01.15
Link: [2023 LLVM Dev Mtg - Compact Value Witnesses in Swift](https://www.youtube.com/watch?v=hjgDwdGJIhI)

Notes:
### Notes from Dario Rexen's Talk on Compact Value Witnesses in Swift

#### Advantages:

- **Compact Value Witnesses** reduce overall code size by up to 10% and improve application startup time by 5 to 10%.
- They allow for runtime instantiation, eliminating indirection in generic types.
- Compatible with existing value witnesses, ensuring a smooth transition and interoperability.

#### Drawbacks:

- Interpretation of layout strings at runtime can lead to a performance hit, approximately 15% in tight loops for simple structs.
- Complexity increases with enums and generic types, requiring more elaborate handling and runtime functions.

#### Tips and Advice:

- For high-performance critical sections, profiling might be useful to decide whether to use compact value witnesses.
- Future improvements could include an attribute to exclude specific types from compact value witnesses optimization.

#### Lecture Content:

- The talk introduced **compact value witnesses** as a method to represent object layouts compactly in Swift, explaining their role in managing object lifecycles in Swift's generic type system.
- Dario outlined the design and implementation of compact value witnesses, including encoding object layouts and runtime interpretation.

#### Main Challenges:

- Balancing the reduction in code size and startup time with the potential performance hit from runtime interpretation.
- Handling the complexity of enums and generic types, which require special considerations and runtime handling.

#### The Importance and Usefulness of the Topic:

- Understanding compact value witnesses is crucial for Swift developers focusing on optimizing performance and reducing binary sizes.
- The approach demonstrates Swift's commitment to efficiency and performance, particularly in generic programming.

#### Accomplishments:

- Successfully introduced a new system for managing value witnesses in Swift that conserves space and potentially improves performance in many scenarios.
- Demonstrated a thoughtful approach to backward compatibility and future evolution of the feature.

#### Summary of the Content:

- Dario Rexen's talk focused on the implementation and benefits of compact value witnesses in Swift, a feature designed to make value witnesses more space-efficient and faster to instantiate at runtime. He covered the technical aspects, including encoding, runtime interpretation, compatibility, and performance impact.

#### Interesting Quotes or Insightful Sentences:

- "Instead of executable code, we emit a compact representation of the object layout, which we call a layout string."
- "For our simple struct, we're looking at an approximately 15% performance hit...in real-world experiments, we have found that compact value witnesses reduced the overall code size by up to 10% while improving application startup time by 5 to 10%."

#### Conclusion

Dario Rexen's presentation on compact value witnesses in Swift highlighted a significant advancement in the Swift compiler's efficiency and performance optimization capabilities. By focusing on compactness, runtime instantiation, and compatibility, this feature presents a promising avenue for future improvements in Swift's handling of generic types and value management.


Transcription:

Introduction
hello everyone my name is Dario rexen
and I'm working on the Swift compiler at
Apple I'm here today to talk about
compact value Witnesses in
Swift now before I get into details
about how to make comp value Witnesses
more compact I'd like to talk a bit
about what value Witnesses
are Swift has a very powerful generic
type system there are different ways to
implement generic types in programming
language
some languages do it by creating uh all
objects on the Heap and then raising the
actual type so at runtime there are only
opaque
references so generic function like this
would com compile down to
this
sorry other languages use a technique
called monomorph isation which means
creating specialized versions of all
generic functions
uh with a particular types
applied so if somewhere in a program a
function gets called with an integer the
compiler creates a copy of the function
with the type fixed to
integer since Swift uh supports and
encourages the use of value types type
eraser was not an
option another big focus of Swift is AI
stability while still allowing types to
evolve if
necessary that means that monomorph
ization is also not feasible because it
would require a stable type layout this
is where value Witnesses come into
play there are a handful of value
witnesses that the compiler generates
for each type those functions are
responsible for copying moving and
destroying objects witness functions are
stored in a value witness table together
with other information about the types
like its size stride and
Alignment as in this case a generic
function does not receive ownership of
of its arguments it does not have to
call any witnesses to manage its
lifetime unless it pass passes that
object to a function that takes
ownership of it in this case the object
needs to be copied
first the compiler will generate the
necessary code for us I'm showing the
code here in C++ instead of ir for
readability the compiler added in an
additional parameter to the function
that contains the metadata of T through
this meta metadata object we gain access
to its value witness
table we ask the witness table for the
size of the object create a stack
allocation of the given size and copy
the object into the newly allocated
memory by calling the initialized with
copy witness function before we pass it
on to the next
function to take ownership of an object
we Mark the parameter as consuming if a
function owns an object unless it
transfers the ownership again it has to
eventually destroy
it again the compiler generates the
necessary code at the end of its
lifetime we clean it up by calling its
destroy witness
function so we know how value Witnesses
get used now but what do they look
like take this Str struct as an example
it has two stored properties an integer
and a reference to an instance of a
swift
class the destroy value witness for this
type looks as
follows since integer is a trivial type
it does not have to be destroyed so the
only thing this witness function needs
to do is to increment decrement the
reference count on the reference stored
in
y the initialize with copy witness does
a bit more it copies both properties
from The Source into the destination and
then increments the reference count of
y a sign with copy is basically a
combination of the destroy and
initialize with copy an assignment
implies that the destination has
previously been initialized so we need
to destroy the value it contains
first just like in the destroy witness
function we do that by decrementing the
reference count of Y then both
properties are copied into the
destination and the reference count of
the new y gets
incremented for generic types the
compiler has no way of knowing the full
layout at uh of the object when
generating the
just like in the generic function
example it has to call through the value
Witnesses of the applied types at
runtime so in the case of a sign with
copy since X is still known to be an
integer it can be copied the same way as
before but for why we have to call T A
sign with copy witness the metadata of
the type parameters of a generic type
can be retrieved from its
Impact on code size
metadata now that we have a bit of an
idea what value Witnesses are let's look
at their impact on code
size bringing back a non- generic struct
this is the generated arm 64 assembly
code for the witness
functions they take up 208 bytes in the
binary and this is a very simple
type let's add another type that
contains an optional value of the first
one and another reference to a class
instance the value witness for the new
type are 328 bytes at size and that is
in addition to the 28 bytes of the first
type so in total we're now at 536
bytes and these Witnesses get generated
for every non-trivial
type and this is the reason we started
looking into making value Witnesses more
compact our requirements for compact
value Witnesses were they obviously had
to be more
compact we wanted them to be run runtime
instantiable to eliminate the Direction
in generic
types they had to be
fast and they had to be compatible with
the existing value
Witnesses instead of executable code we
emit a compact representation of the
object layout which we call a layout
string that will be interpreted by a set
of runtime
functions a layout string starts with a
header consisting of flags and the size
of the operations in bites followed by
the
operations layout strings pack to make
them smaller but also easier to parse
and
insentience in Swift There Are For
example references to Native objects
which can be strong unknowned or weak on
Darwin we also have Objective C
references which can be references to
regular Objective C objects blocks or
objective c objects that are bridged
into Swift
types and we have unknown references
which can be either native Swift or
objective c references at runtime
looking back at the example type from
earlier the only information required to
implement the six value witness
functions we're looking at is the type
of the reference and the offset to the
reference relative to the previous
reference or the beginning of the object
for the first
reference in this case we have a strong
native reference represented by the op
code
0x02 at a one-word offset from the start
of the object we're currently encoding
this in a single 4 bit value where the
most significant bite is used to the for
the reference kind and the rest for the
offset there's still potential for
improvement here instead of using a
64-bit value we could encode the offset
as a variable sized integer by storing
the offset in a single bite instead and
using one bit as a marker for additional
data in the following bite so for this
particular case we would reduce the size
of the offset to a single bite and we
expect that for most offsets it will fit
into one or at most two
bytes in addition to the reference and
its offset we also need to store the
amount of bytes for any remaining data
after the last reference this is encoded
as the op code
0x00 which also acts as a Terminator for
the layout string followed by the number
of remaining bytes so in this case it
would just be zero but if we had any
additional plane values after the
reference it would be the combined size
of those
values
and then there's the head I mentioned
enums
before so using this compact
representation instead of 208 bytes for
the witness functions we're looking at
only 32 bytes now with the potential to
reduce it even further to just 20
bytes enums are a little more
complicated in structs we have a number
of different kinds of
enums they're enams with no cases at all
enams with only non- payload cases
basically your C style
enums enom with only a single case and
that case has a
payload enums with a single payload and
one to many non- payload cases and enums
with M multiple payloads and zero to
many non- payload
cases empty and no payload enums are
always trivial so we don't generate
layout strings for them the same is true
for any enums that don't contain any
references in their
payload the memory layer of a single
enom is identical to that of its payload
so the layout string will be the same as
well there's one more special case enums
with a single payload case that contain
a single reference as a payload and have
a single non- payload case for example
an optional in an optional of a
reference type is layout identical to
and the only way to express nullable
references in Swift so we treat them as
such which leads us with single and
multi payload enums that contain
references in their
payload for enums we're also looking at
two additional value witness functions
get enom Tech which retrieves the tech
associated with the enum case and
destructive inject enum Tech which
stores the
tech the reason we need these Witnesses
in
Swift uh is that Swift whenever possible
utilizes uninhabited values and unused
bits to store the tag in the payload of
an enum to avoid allocating additional
memory for example on 64-bit do
platforms the first three two bits of
the address space are unused so empty
cases in single payload enums are
represented using those uninhabited
values while any valid value in this
position means we have a
payload if more space than the number of
available uninhabited values is is
required to represent all TXS of an enum
extra memory will be allocated after the
payload because of the added complexity
even this fairly simple looking enum
single payload
comes in at a whopping 480 bytes for the
eight value witness functions we're
looking
at to handle a simple single payload
enum in a layout string we need to know
at which offset the member storing the
extra inhabitants is and how many bites
are used we also need to know if there
are any extra Tech
bites we use at most eight bytes for the
extra inhabitants and at most four bytes
for the extra Tech Bytes so we can
encode those two values in the most
significant bite and use the rest for
the
offset we also need to know the size of
the payload in this case there there
extra tag bites to read which are
appended after the
payload because the extra inhabitants
don't always start at zero we also store
the the value of the first non- payload
case and the number of non-p payload
cases so we can identify the particular
case we're looking
at we also store the number of bytes
used for the payload operations and the
skip value these are required to skip
forward in case of the non- payload
case and at the end we store the
operations for the
runtime
payload as you can see layout strings
for enums are a bit bigger but we're
still reducing the size from 480 to just
88
bytes now we know what comp compact
value Witnesses look like uh but how do
they get interpreted at
runtime as I mentioned earlier we have a
of runtime functions corresponding to
the generated value witness functions
that interpret the layout strings
conceptually uh conceptually they all
work the same way we start by reading an
OP code at its in its
offset a non-zero offset means that uh
means there is Trivial data between the
previous and the current reference so we
have to copy that
data next or if there was no offset the
offset was Zero we interpret the op code
for each type of witness there is a
separate dispatch table that contains
pointers to the respective functions for
each op code for example if we're
executing the destroy witness the entry
for a native strong Swift reference
would point to a function that called
Swift release at the current
offset if the op code is zero we are
done otherwise we continue with the next
one most of the op code functions are
very simple for references it's just
copying and incrementing or decrementing
reference counts enums are more compx at
let's look at the single payload enum
case first reread the enum layout
information if it has extra tech tech
btes we read them and check if they are
non
zero if they are this is a non-p payload
case so we skip the payload and they're
done if they are zero we check if there
are extra
inhabitants if there are no extra
inhabitants this is the payload case so
we interpret the layout string for the
pay payload and are
done if they're extra inhabitants reread
them and check if they have a
payload if we do we handle it otherwise
we
skip if we don't have extra TCH bites
and there are no extra inhabitants this
layout string is
invalid if there are extra inhabitants
we handle them as
instantiation
before as I said earlier one of the
goals of compact value Witnesses was to
remove the indirection of recursively
calling through the witness functions of
generic properties this is done by
instantiating compact value Witnesses
for generic types at runtime we already
instantiate the metadata of generic
types when they are first requested in
runtime so we we utilizing this mechan
the same mechanism for compact value
witnesses as
well to instantiate a layout string we
iterate over all properties of an object
and get that type
metadata if the type is Trivial we don't
have to handle it directly so we add it
size to the current offset into the
object and move on to the next
property if it is a reference we add the
op code for the respective reference
kind to the layout string and continue
with the next
property if the type has a layout string
we copy it into the current layout
string which results in a flattening of
the combined layout strings thus
eliminating the previously required
indirection we also have to be able to
work with types that are not compiled
with layout strings enabled so if none
of the other conditions Supply we fall
back to calling through the witness
table for that we emit a special op code
together with a pointer to the metad
type metadata of the property the
runtime function will then read the
metadata pointer and call the
appropriate witness
function there are a few more special
cases that are left out to keep it
simple for example there are some
situations where we store relative
pointers in the layout string and they
have to be resolved at insentient
compatibility
time another important factor is
compatibility and by that I mean both
compatibility with the existing value
witness infrastructure since that is
part of the AI but also ensuring that we
can still evolve this feature and adjust
the format of the layout strings if
necessary for compatibility with regular
value Witnesses we're using the same
value witness tables for types that are
not using compact value Witnesses the
entries in the witness table point to
the generated witness functions and for
types with compact value Witnesses they
point to the shared runtime functions
but we need to access the layout string
from within the runtime
function we're already passing the type
metadata into the witness functions so
it's seem reasonable to store it there
the metadata has a header that contains
a pointer to the value witness
table the metadata pointers that we
access at runtime point to the be
beginning of the actual metadata so the
header sits in front of the actual
object so without breaking any existing
assumptions we can add the pointer of
the layout string in front of the
witness table pointer because type
metadata that was generated with older
compilers do not have this extra pointer
we also had to add a flag that will only
be set when a type has a layout string
the flag is guaranteed to not be set for
all existing type
metadata for statically generated type
layout strings the solution is to keep
the existing runtime functions and add
new ones for any incompatible changes so
the witness table generated for an older
compiler may look like this one
generated by a newer comp uh compiler
like this
but they can coexist in the same
application we also need to be able to
instantiate layout strings from
different versions looking back at the
instantiation diagram we have two
options we could check if the versions
are compatible and call through the
witness table if an incompatible version
is
encountered like we do for the types
without layout strings that is not ideal
because it adds indirection but it would
be a simple working
solution another option would be to
translate the layout string to the newer
version which would add some overhead to
the instantiation but benefit runtime
runtime performance
performance lastly I want to talk about
impact on runtime
performance since we are replacing
natively executable code with an
interpretive version some performance
hit is expected for our simple struct
for example from earlier we're looking
at an approximately 15% performance hit
and that is when executing the Witnesses
in a tight Loop since we're
instantiating layout strings at runtime
for generic types performance should be
identical to non-generic types of the
same shape for this particular case
we're seeing a runtime performance
Improvement by about 10% compared to
regular value
Witnesses in real world experiments we
have found that compact value Witnesses
reduced the overall code size by up to
10% while improving application startup
Time by 5 to
10% with no perceivable impact on
performance
QA
ments before I end my talk I would like
to especially thank Gwen M trer who
created the initial draft for this
feature as well as my colleagues for
providing their help and
feedback and uh I don't have a timer so
I don't know if we have time for
question we do okay good any
[Applause]
questions
do you imagine that any sort of
profiling be useful
to not enforce the Val witness on like
very
MH um I'm just going to repeat the
question uh for the recording so the
question was uh if it would be useful to
use um profiling to determine very hot
um types so so types where the value
Witnesses are called very often um and
to avoid creating uh compact value
Witnesses for these cases yeah for like
select very specific very high yeah I
mean I I think it always depends on on
the use case right um I mean you can't
really say upfront what performance will
look like so um would always be best to
measure performance and um you can
certainly uh compile specific types
without this feature enabled
um it would maybe be interesting to add
some kind of um attribute or whatever to
say hey please don't do this for for
this type uh we don't have that today
but it would certainly Poss be possible
yeah all right if there are no more
questions let's give Dario a big round
of applause

----------

-----

--03--

-----
Date: 2022.04.05
Link: [# iOS Interview Questions and Answers with Sample Code](https://www.youtube.com/watch?v=gmyEHW7zDYc)

Notes:
### Notes from the Video Transcription

#### Advantages:

- Understanding iOS developer interview questions can significantly boost preparation and confidence.
- Deep diving into reasoning behind answers enriches knowledge beyond just solving problems.
- Mock interviews help simulate the real interview experience, making it less daunting.
- Learning about the lifecycle of view controllers and differences between structs and classes in Swift offers foundational iOS development knowledge.

#### Drawbacks:

- The video does not cover SwiftUI or Combine, which are relevant and modern topics in iOS development.
- Some concepts, like the difference between `weak` and `unowned` or `@escaping` closures, can be complex for beginners without additional context or examples.

#### Tips and Advice:

- For interview preparation, focus on fundamental concepts since they are commonly asked.
- Use sample apps and code to understand complex concepts like the view controller lifecycle.
- Consider breaking down complex code into smaller parts or using code folding in Xcode for better understanding.
- Always refer to official documentation for the most accurate and up-to-date information.

#### Lecture Content:

- The video covers top iOS developer interview questions, including MVC architecture, protocol-oriented programming, `defer` statement, Grand Central Dispatch, and the difference between `frame` and `bounds`.

#### Main Challenges:

- Understanding and remembering the nuances of iOS development concepts can be challenging.
- Writing clean and efficient code under interview pressure.

#### The Importance and Usefulness of the Topic:

- Mastery of these topics is crucial for passing iOS developer interviews and for practical iOS application development.

#### Accomplishments:

- Comprehensive overview and solutions to common iOS developer interview questions.
- Demonstrated how to apply theoretical knowledge through practical examples and code.

#### Summary of the Content:

- The video provides an in-depth look at common iOS interview questions, offering solutions and explaining the rationale behind them. Topics covered include the view controller lifecycle, the difference between structs and classes, MVC architecture, protocol-oriented programming, and the use of `weak`, `unowned`, and `lazy` keywords, among others.

#### Interesting Quotes or Insightful Sentences:

- "Understanding iOS developer interview questions can significantly boost preparation and confidence."
- "For interview preparation, focus on fundamental concepts since they are commonly asked."
- "The best way to learn about the view controller lifecycle is basically to open the project and go through each of those steps."
- "Classes are reference types, and structs are value types, but don't make assumptions about what's going on under the hood."

### Conclusion

The video serves as a comprehensive guide for iOS developer interview preparation, highlighting key concepts, common pitfalls, and effective strategies for understanding and applying iOS development principles.

### Anki Flashcards for iOS Developer Interview Preparation

#### Card 1

- **Q:** What is the view controller lifecycle?
- **A:** It's a series of events that occur from the creation to the destruction of a view controller, including `viewDidLoad`, `viewWillAppear`, `viewDidAppear`, `viewWillDisappear`, `viewDidDisappear`, and `deinit`.

#### Card 2

- **Q:** Difference between structs and classes in Swift?
- **A:** Structs are value types, and classes are reference types. Structs are copied on assignment, while classes are passed by reference.

#### Card 3

- **Q:** What are SwiftUI and Combine?
- **A:** SwiftUI is a modern way to declare user interfaces for any Apple device in Swift. Combine is a framework that provides a declarative Swift API for processing values over time.

#### Card 4

- **Q:** Why are fundamental iOS interview questions important?
- **A:** They cover basic concepts and patterns essential for iOS development that companies commonly ask during interviews.

#### Card 5

- **Q:** What does the `defer` statement do?
- **A:** Executes a set of statements just before the current scope exits.

#### Card 6

- **Q:** What is Grand Central Dispatch (GCD)?
- **A:** It's a low-level API for managing concurrent operations in iOS and macOS applications.

#### Card 7

- **Q:** Difference between `frame` and `bounds` in UIView?
- **A:** `Frame` refers to a view's position and size in its superview's coordinate system, while `bounds` refers to the view's own coordinate system used by its content.

#### Card 8

- **Q:** What is Protocol Oriented Programming?
- **A:** A programming paradigm in Swift that emphasizes the use of protocols and protocol extensions to achieve polymorphism and reusability.

#### Card 9

- **Q:** When to use `weak` and `unowned` references?
- **A:** Use `weak` to avoid strong reference cycles when the referenced object might become `nil`. Use `unowned` when the referenced object will not become `nil` during its lifetime.

#### Card 10

- **Q:** What is the MVC architecture?
- **A:** Model-View-Controller (MVC) is a software design pattern that separates objects into three distinct types: models for data, views for the interface, and controllers for logic.

#### Card 11

- **Q:** What does the `lazy` keyword do?
- **A:** It delays the object's initialization until it is actually used, which can improve performance and resource utilization.

#### Card 12

- **Q:** Difference between `@escaping` and `non-escaping` closures?
- **A:** An `@escaping` closure can be called after the function it’s passed to returns, allowing it to escape the current scope. A `non-escaping` closure can only be called within the function it’s passed to.

#### Card 13

- **Q:** What is an `@autoclosure`?
- **A:** It's an attribute that automatically creates a closure around an expression when passing it as an argument to a function, simplifying syntax for functions that take closures as arguments.

#### Card 14

- **Q:** How to handle memory leaks in iOS?
- **A:** Use weak or unowned references to break strong reference cycles, and utilize Instruments to detect and analyze memory leaks in applications.

#### Card 15

- **Q:** What is the importance of understanding memory management in iOS development?
- **A:** Proper memory management prevents memory leaks and ensures that your application uses resources efficiently, leading to better performance and stability.

These flashcards cover a range of fundamental topics and best practices for iOS development, aiming to aid in interview preparation and reinforce key concepts.

Transcription:
Overview
interviews can be daunting but it don't have to be if you're well prepared in this video i'm gonna go through the top
10 ios developer interview questions and not only go through them and solve but actually uh we'll dive deep into the
reasoning behind the answers and probably look into some documentation as well let's look at some sample apps and
sample code and to assist me to make it look like a real mock interview my
Daniel, the interviewer
friend daniel will be helping he's on the other side of the call and dan say hi
hey what's up everyone so yeah the first question will be to you actually and uh
could you tell me more about yourself
yeah so hey everyone my name is daniel and i'm a web product developer working
mostly with react and i did ios like five years ago
for a little bit so i am a bit familiar with the questions so i can assist richard with the
interview so you'll be my intro now uh yeah basically so you've seen the uh question
list what do you think of them so far um yeah it's like nothing has changed
much i'm just wondering why you didn't add any swift ui or combined questions
yeah i think um it's a good idea i think swift ui and combined and such are new topics and uh they really worth a
separate video on that on the topic so probably will make a separate one and not to miss it just
make sure to subscribe to my channel and uh if you want to combine and swipe ui
a separate video just let me know in the comments below i'll make one just on that topic
uh yeah but why i started with those questions
Why these questions?
basically they are very fundamental and all the companies right now are asking some sort of them
uh when interviewing for an ios developer role and this is really interesting because uh if
you watch this video till the end there are about 10 questions uh it's
very likely that you'll get one or two of them in your next interview so
i think that's a very good uh training and exercise for for preparation for interview
all right yeah so let's get started yeah let's go ready
View Controller Life Cycle
yeah so the first question is can you explain me what is the view control life cycle and
what are the most important events uh yeah i think this is basically the classic ios interview question is being
asked for 10 years at least so uh to actually see what is the view
controller lifecycle is i just created this um
basic app which is printing out uh each method so that we can see what's
going on in the view controller while we show it or hide it so i used the storyboard
and created a very very simple app which will show just the uh model view
controller basically presenting a sheet from the bottom and we'll see what events we'll be printing
out let's run this app and see for ourselves and uh
what are lifecycle events and what are uh what are
uh the most important ones so open lifecycle press button and we start with a view controller
so as you can see the first one to be called is initial coder which is basically an initializer and
in that case it might be called a different one in some cases because for example if you're uh initializing
your uh view controller programmatically an input frame will be called or this one
init with nib name or nail so one of those basically the initializers are always going the first
the next one is load view which is a
method when asking for a view to be loaded and the view that load follows it
immediately basically once the view is loaded you get the view that load event
uh i don't understand why load view if needed is called after that probably some sort of legacy
uh artifact because it does make a lot of sense maybe it's just to ensure that the view is loaded
but and at this stage it does nothing and then we have the so-called uh
appearance and layout events so you will appear it's called before the view appears on
screen and the view will layout subviews is called uh before the layout pass and
then after the layout has been completed we have the view dead layout subviews
all of those are available to be overwritten and um yeah and once the view is about
to appear once you already appear you have the view that appear and once i drag it down we have them in
the reverse so we have the view will disappear and view the disappear and the d init
is called last uh in case you don't see d in it for some reason in your view control that
means that you have a memory leak and it's still in the memory so you have to work with the memory profiler
and one more important thing is that if we clear the console
that this view will appear and you did appear as well as you did disappear might be called multiple times so if i
try to dismiss the view for example and then i'll decide to pull it back
i have the view will disappear but i never see the view did disappear
because it's still on the screen and we are going back you will appear and view did appear so
apple actually has a very nice a very nice sample
for that has a very nice chart i'll link it i'll link it in the description for sure and
um understanding this chart is really crucial to understanding the view control life cycle
so uh you basically have four states uh appeared and disappeared and
transitioned between them into multiple directions so uh and what's important
you can move to appearing state you and immediately move to disappearing state or vice versa
this is usually emitted by all of the candidates and they just think it's one
time event and this is a big mistake so
these events might be called multiple times in the life cycle of the view controller as we've seen
and of course the one when rotation is happening is that you will
transition to uh size with coordinator and the same as
uh called when uh for example you're in an ipad and trying to resize the
uh resize the view control on a multitasking screen so i think that's it regarding the uh
view control events so hopefully you're satisfied with this question what do you think
yeah i mean i didn't know that there are that many methods around the
like the view control life cycle so it's also new to me
but what do you think what are the most important ones to remember because there are quite many and yeah which ones
yeah to summarize summarize really it's uh it's all about
grouping them into categories the first one is the initializer
that's the main one that's the first one the initializer is the first and then the initializer is the last
then you have the view loading related callbacks load view if needed load you and view
the load those are the next step and they are uh what ones are the most important like
which ones are i think i think i think i think the load view and viewed it load so view that low is probably the most
used one i think if you create a template right now it will be there it will be included there
yeah and what's the difference between load view and view did load
um load so basically load view is uh so they're going in a very specific
order right so you have the load view first and then view that load after that it's pretty clear and load view is the
one to override if you want to use a custom view for example if you want to have view equals ui table view let's see how
it works like i'll i'll make just this change and let's see if uh i will have a
different view there i mean i should uh life cycle
button that looks like like is it a table if you actually know because probably i'm
using the storyboard that's why it won't really uh it won't really plug it in so i don't
know but uh
if i were to use uh if i were to use um where is this dimming you drop shadow i
can't see anyway life cycle you i actually you're a table you see us here
pretty cool oh yes yeah so it's there so yeah loadview is what you use to uh
connect your custom view uh and overwrite the default but if you
don't do anything it basically adds a ui view here like that and you just can't ignore it
you really don't need it and view that load is when the view is loaded and you can do some
customizations for example adding in sub-view or something else too that's why i kind of prefer to group
them by the purpose instead of like selecting the most important ones
and then we have this appearance callbacks you will appear you did appear
uh and view will disappear you did disappear so regarding the presentation appearance disappearance and we can uh
add a third class which is to layout related layout transitioning to sizes
and so forth so yeah initializer d initializer view loading
presentation and [Music] layout and i didn't even go into details
like for example things like um did receive memory warning that's not
the one or will add uh or sorry
add child view controller did add will move to parent view controller so there are a lot of
callbacks to you think about like apart from those but basically view controller is a very important class obviously
there are a lot of uh connection points to work with so
those i've listed are the main and of course this project is available on github so
make sure to play with it and i think the best way to learn about the view control life cycle is basically open the project and
go through each of those steps in the event you understand how how it behaves and
instead of like just reading the documentation
yeah so hopefully we can move to next one yeah i'll do this next one so
i think this is the most common one which one what's the difference between a struct and a class
The difference between a struct and a class
yeah it's a very common one though so um
well let me try to answer it yeah yeah go ahead go ahead
at least i remember something about it so i think the class is referenced
it's reference based and struct is value-based value-based what does it
mean in practice like in practice like when you
create an instance you get like i guess a pointer to it if it's a
class and if you create an instance of a struct then you
get a like the value instead so
yeah but what if you try to modify uh the same class like will it modify at the other
sides which holding that reference or not if it's with class and what do you mean if there's gonna be
another like for example if you pass class to multiple objects and then you modify
something like a value at that class for example let's say point uh of the player
will it be reflected for each objects who own that class or
uh will they act like independently yeah i think it's going to be like a singleton yeah well the e8 will be
reflected for all yeah that's that's that's the means called reference uh beast but yeah a lot of but but a lot of people
are going into details like for example
uh saying that uh extract is always copied when you pass
it or saying that you like something details like uh oh you cannot uh you cannot
extend the struct you can't subclass track but you can subclass a class right
but those are uh the problem with those answers that they are not very uh
they don't always hold true for example you can uh you cannot subclass a final class
right and uh you can uh extend their structure using a protocol
and uh the most important thing which usually all the people are uh not aware of is that
this truck might be passed by reference to and for example all of the
uh collections in the standard library like dictionary arrays and so forth
strings sets they use the optimizations to reduce uh the cost of coping so
if you try to to pass the array it will be actually under the hood passed by reference
and only when you modify it will actually duplicate the whole array which is an interesting
idea to know like for ios developer when profiling for performance problems
and if you look at the ios or actual swift um array code
you'll see that there is like a buffer which is uh used like internal storage
for an array and when you try to copy that a lot of uh functions actually
all the functions are actually passed to um
they are passed to uh to this buffer and uh there are a lot of
optimizations for example like mutations uh for coping and so forth
um simply because uh because it has to be faster
uh for those optimizations and this is doing the job of making run fast and uh
from from the developer's perspective it appears if the array is copied immediately but in fact
it's doing this copying right on the hood so because swift is such an optimized language and a lot of complexity is hidden from the
developer so yeah my answer would be that
classes appear to be passed by reference have the reference semantics and
uh structs are appearing like they are passed by value so basically copied but
they just appear like that those are only semantics do not make assumptions of what's going
on under the hood and i'll link those nice articles from apple which describe
uh difference more like in practice it's important to understand those uh
those uh differences but basically yeah the main one is the value versus uh like
having an independent instance or uh in case of uh struct or having the
same instance shared shared memory in case of a class and yeah of course you can have the identity
um hey richard do you have like an analogy how did you compare the class
and the structure yeah yeah i think yeah i think the class is more like a bank account so whenever you deposit
something to it and withdrawal uh it refers back to the same bank account so
let's say i put a thousand there i have a thousand i withdraw a thousand i have zero right
but uh a struct would be like more like a bank statement uh so
i have the bank statement for from today which shows thousand i can get the same from tomorrow which will be zero
and uh i can copy i can remove it i can pass it to someone else there will
be no uh it will be like a different copy basically so independent of my bank
account independent of everything so i think that would be the best analogy okay
so so so uh that's sort of the benefit why using structs might be a good idea because
uh you can pass them between threads because basically it's copied so you are not afraid of any sort of race
conditions mutations because uh once you pass it to a different thread
it this truck lives on its own and the class will still have that reference and that's sort of the notion why they
wanted to get rid of classes uh as much as possible in move into structs and move the spherical random
programming thing i think that was the idea
cool should we move to the next one yeah let's go so what's the difference between
The difference between "frame" and "bounds" properties of an UIView
frame and bonds property of you uh i think it's important to figure out
what what they are similar i have again a sample app here that will help us to figure out what they are and what they
are not so um first of all uh let's go to check uh the ui view
class we can just take a look at it and we have the frame here
and we have actually both frame and balance this you can see they are both of type c direct which means they're
essentially the same uh type and you can set one for another so
that really makes them similar uh but what's different is their
semantic and the way they apply to the way they used to and this is the most important thing
uh the most important difference and uh in short it boils down to
uh if i launch the app i'll just launch the app so uh the frame
is about the they both if we zoom in here like if we go into the uh c direct they both have
the origin which is the starting point and the size which is basically the size of the rectangle so
uh they uh they uh the difference is that
in case of frame the origin points to the uh position in its super view so if the
view is not added to a super view there is no concept of frame right and the size is well it's clear it's the
size which it occupies in the super view this is one of the important thing we all get back soon
uh and with the rect with a with the bounce it's slightly different concept so uh the origin is relates to the
content that the view is showing so what piece of the content the view is showing
in its frame and the size is basically the size of that viewport let's call it like that
so to sum it up uh the frame is about position of the view
so size and origin in relation to its super view and the bounds
it's the uh what portion of the content the view is showing
and uh i'll have few examples to demonstrate this a bit further so uh first one is the scroll view
the white one is the scroll view and we have two views there which are sort of showing how the view scrolls itself and
i'll try to drag it now a bit so see how the bounds and the frame are
changing so as you can see there is a frame and
bounce and i'll try to drag it to different directions as you can see if you can take close attention uh pay
close attention to the frame uh the frame is actually always the same here
uh it never changes so whenever i drag it no matter it doesn't matter
uh but the bounds of the scroll are actually changing all the time in both directions so
uh the size stays the same 350 and 241 is the same here and here because the scroll size doesn't change
and the content size doesn't change right but the origin is changing
so that's how the scroll view scrolls and decides what piece of content to display
and one more thing of course we have the case when the size of the scroll
bounds also changes and that's when you have uh for example page to zoom gesture
then you will have your size increasing and scroll you will
basically zoom on to something and then there is another demo which i've prepared is more
interesting probably it's rotation so the red rectangle is showing the frame and the purple is showing the
bounds now rotate it a bit as you can see the area which occupy which this purple
rectangle is occupying in its parts superview it has to be rectangular
it's growing once i rotate it but the content stays the same basically right and if we
take a look what's going on under the hood is we'll get the same answer
so the bounds always stay the same it's 100 100 here
but it's the frame that changes and as you can see the numbers are very very
complex here and yeah because we're just rotating
and if we go to the official documentation we see that the if the transform property is not the identity transform
the value of this property is undefined of the frame property so it to be ignored but in this case it
actually makes sense i think because you can see the frame of this view is larger right
so uh it occupies a larger part of the part view so yeah i'll briefly show the
code which i brought here uh it's nothing fancy just a regular
regular view controller and when rotation is being detected i'll just rotate it on the same
level as the uh as the actual
as the actual uh paint gesture rotate gesture
all right that was a pretty deep answer yeah i mean i mean yeah it's not like an
interview question after it's more like a bit more explanation so yeah
uh to sum up the the frame the frame of the view it's what it
occupies in relation to its parent view to its super view no superview no frame
and bounce is how it positions its content in its own let's say canvas so that's to
be the summary so the bonds are always larger than the
frame the bounds are always larger than the frame i actually don't know i mean
could be that the balance will be smaller than the frame
let's see
well maybe actually no there is a thing called clips to bounce you know right
so if you uh you can you can clip to bounce probably some of the
sub views might extend to the bounds right uh and they will still be drawn but if
you set clip to bounce property to true then will limit to this balance so again
the bounds uh the bounds can be uh so the content might extend slightly
further uh than the bounce yeah okay
all right let's go to the next one so what is what is protocol oriented programming
Protocol Oriented Programming
uh yeah so protocol random programming is the new or not so new paradigm which was introduced to swift
and the main idea was to differentiate from object oriented programming and to
uh solve those problems that were introduced with object-oriented programming and i have actually a keynote a
presentation uh about the type system of swift actually i'll link the video as well
and in short if uh the swift has a very strong very strong protocol system so
you can have the classes structs and enamels conform to protocols and the problems can have the inheritance
between them so there's a very very flexible way to define relationship
and if i compare the objective c the object-oriented language with swift the way this relationship
power can be expressed with protocols in objective c you have the uh for example
ns number uh the ns number subclassing uh is a subclass
of ns value and which in turn is objects so for example there is such particular peculiar
peculiar so there are such issues that you could compare the view
controller with uh an s number for example if this number is equal to the view controller
which does make a lot of sense and um uh because they are the
uh the descendants of the same class and in swift they fixed it by using a protocol
basically protocol that can ensure that um
that the compared values are of the same time so the protocol-oriented programming is the idea that you can
detach the relationships of between of the objects from the objects
themselves and if an object satisfies some sort of constraints some sort of rules
uh then you can embed this whole object into a relationship without writing too much
code and like repeating it yourself over and over again for each uh different kind of object
and basically that's a the idea of particle range programming is separating the uh hierarchy of relationship of
inter-relationship and hierarchy of objects of methods uh and that's a pretty powerful construct for example
you have a lot of power in in the thing called retroactive modeling like you have for example the equatable
protocol and the way uh the equal sign is defined the equality operator
and the inequality operator is defined as the uh the opposite of uh
of a quality operator so pretty cool and you can compose the protocol so you can work on a very very high level
without touching the concrete types and develop software in a much much more
modular and flexible way and yeah so let's focus on the types and
relationship between them and if you have a new type created you can quickly embed it into an existing
relationship between them and basically
use all the power that you've already developed uh to have new types supported
immediately and i think the biggest analogy for me is um using some sort of algorithm to capture
the list of uh to capture the photos of the tallest buildings by using the map of the city and the
list of those buildings so you have to have a map and you have to have a list to go
through each of those buildings and take a picture the only thing that you have to care about is that your uh map and your list
are of the same city then you'll get the proper pictures right so the protocol
protocol expresses this whole algorithm without naming the city once you have a
new york for example here you can make the same for barcelona or you can make the same for let's say los angeles
and you can have the same uh set of photos taken simply by having these two
um objects and i guess that's the idea of it
what do you think okay yeah i mean
i see protocols are like kind of like interfaces
so i don't really remember that much of it
but your answer was pretty good yeah yeah i mean the the the most important difference because we have the
interfaces in objective c uh the most the most important difference uh in swift is that you can
actually uh work only with particles you can combine them you can
express more more flexible relationship more concrete
relationship and between objects and that will give you
let's say more compiler support in while you develop so you don't have to type cast as much
uh because protocol already constrains that thing that type to a specific
subtype and you know that it will be of that specific type and so forth so you are getting a lot of
type safety uh and but but at the same time you have a lot of flexibility
which in the object-oriented languages like objective-c was uh
what was implemented with the dynamic dispatch dynamism and so forth that's why you could compare like a ui view
controller with a number or whatever of course it will return a false but
you still can do that and in swift it will just throw an error
all right it will not even compile i mean
all right okay but let's move on so yep
"defer" statement coding question
grand central dispatch yeah so deeper question yeah let's try to open the
playground yeah nice one
yeah i like this question quite a lot so uh i guess the task is to figure out what
will be printed out in all of those questions let's start with the first one right do you want to try
to solve it i mean when i look at that code it's like
who who writes this kind of yeah by the way by the way before me write this girl for sure it's not
written this code half an hour ago but before we start with that i i highly recommend watching
this protocol oriented programming talk by apple uh in 2015. without dc and i'll
link it of course so um it's more entertaining probably than this video but
it definitely takes a longer time to understand so uh yeah let's get back to this
question uh so uh yeah i think the first thing to say
in an interview in my opinion when you see this is that this code should not really be written
and if you have if you see this code the best thing is to go back to the drawing board
figure out what should it do and uh and uh then
uh write it from scratch by understanding the requirements but uh that's the first thing any for example
if you were to be interviewed by me you'd get definitely some bonus points for that
and yeah but what do you think what do you think
the answer is here
um so defer does things
as the last stuff and
um so the print f is going to execute first
this one yeah yeah let's try
and [Music] yeah so
yeah so i think i think the the next one is going to be the
print e because i think the difference goes in the reverse order yeah
this is very important thing to remember they go in the reverse order so uh if this defer is called first it will
be executed last and the first station for those who don't know this it's
basically a a way to work with a legacy api for example if you have some some
resource acquisition happening here and you want to clean it up immediately instead of remembering to clean up and
all those if cases you have in the code you basically write as soon as you lock onto something you write a deferred
statement immediately and you'll sure that the moment the function is closed that resource will be
close to basically yeah so uh
then this one is obviously to be the next one which one is the next after e
yeah so it's going to be the one above it so that where the prince b
is yeah and in my opinion just do this so um whenever whenever we have
something complex just hide it here with the um
with the uh code folding and then you can unfold those ribbons so you
see the f help make xcode help you then you unfold this one which is the next one right
makes it really clear e then we unfold this one right yeah because we go one level up
and uh what is the order here so it's gonna print b the first one b
because it's the yeah the b or running the b here yeah then that's gonna go to
the print d because the first statement is default right we just hide it yeah it's gonna be
excuse or fast then d and then we have c because uh we are
exiting this whole close right yeah and this is the last one
oh yeah let's check this out i think i agree with you
f e b d c a f e b d c a looks like we are correct
cool yeah cool let's let's let's tackle the next one which is a bit more complex
and again the idea is that this code should not go into the real system into the real
application so uh it's better to refactor it than trying to decipher and understand
GCD / DispatchQueue coding question
so what would be your approach so actually how would you reach factor
code like that yeah well well it's a synthetic code so
the like i don't know the purpose i'll go back and look at the look at the
look what this code is doing and then try to restructure it but yeah we can actually this is a good
help um and the preferences you can actually set up the code
uh in a text anything you have the code folded ribbon here which will add you
this ability to fold the code and this is really convenient to solve this
kind of tasks that did actually ask quite a lot in the interview for some reason
uh so yeah just fold the ribbons and you can focus on uh want to be executed first so yeah how
would you tackle this question yeah so dispatch queue let's go
so the first one that's kind of printed is the a a because it's the first in the
uh yeah first line of code then this dispatch queue line gets executed so it like
creates a new queue yep it doesn't create a new queue it just
dispatches to a different queue right oh yeah well yeah yeah
lower level stuff yeah well yeah sure but uh it's it's an async it's an async
cue right so uh oh yeah yeah yeah that's true it's in the sync one
so okay well yes it's it's a sync it's gonna like i guess
go through this function first so it's gonna the whole thing print
so yeah correct we can just hide it because it's the essence writes a separate queue we just hide it
yeah so yeah the i is going to be next correct and what else so we now need to look
here right yeah so then it's gonna check out the
the syncqueue and it's gonna print the b all right pretty clear
i don't think i have any concerns regarding that okay and then there's the syncq so it's
gonna like skip this well put it on another cue yes so we are
hiding this for now yes so it's going to go to the d
d right yeah and then
uh okay so there's a sink not async but yeah
synchronous yeah and so
they are in the same queue right they're the main cue yeah yeah so
so first of all what what is the sync doing to the queue what is the purpose of the sync how it's different from this
like you have two of those uh you have the async here and you have sync what's the difference between this
i think it's gonna block the ui until the print e gets it well it won't block the ui it will it'll block the execution
so basically uh you you go the b then you go to d this is scheduled right this is sync it
just skips it then you have d and then it goes to this line and then it waits basically it schedules this
part to be executed on the main queue again but it will wait until this finishes
the while it waits uh it ha the main queue has uh there is one
more important difference uh there are serial and parallel cues right so we know that main queue is
serial queue so uh it will execute the tasks in the order that we send to it so it will not
start executing this task before it will start uh it will finish this one so the
c will be finished first and then only it will go to e right oh for read yep
because it is serial queue so it will uh take task by task so it will not
uh execute them in parallel so it will not be able to there would be no race condition between
the c and the e this is very important yeah so even though there's the sink
like method or like yeah it is it is s it is s-sync right but you see it's it's
been as sink in relation to this global queue uh but but then it sends it on the main
queue and uh and uh it is scheduled there so uh the task has been put to that
queue right now you go next to the printing d and now the sync is again with relation to
this queue basically waiting synchronously while this whole thing executes on the e
on the main queue and uh you're waiting waiting waiting but it takes the first task which is c it prints c
and then it will print e right because yeah and then it will skip
for them so uh actually i'm interested i'm i'm i'm interested yeah i think it will block
the queue right so the the h is still here so it will not reach it right so this should be yeah
so then again we're having the async thing right yeah so we're just getting so we so
we're skipping this right yeah so h is going to be next h let's see i'm not even sure myself uh
but i would agree with you it's h and now it's time to unwind the async
h i is already here so f how about g
well yeah i guess that's the only thing left i think it won't be uh printed out
for real all right yeah look at look at this look at this so we have the we have the dispatch q uh main async
so basically dispatch tasks and move on this special test can move on so
the age is here so dispatch the test can move on but then inside that task you're again
scheduling a next task to be executed synchronously right just
in front of your current task because this one i still haven't finished remember the main queue is the
synchronous queue it's oh sorry it's a serial queue it takes one task after another so until it's finished executing this
task it can't start doing this one so uh and because it never finishes this
one because it waits for this forever this is called a deadlock so basically the g will never be printed
and uh uh yeah that's my opinion let's take a look
uh this is not an easy task i'll say but let's see what will be in practice
now [Music] so a i b d
c e h c e h f and as you can see the g is not printed right
so just zoom in on this one yeah really interesting so
uh these are actually uh the questions are asked in the interviews like uh some of the variations of them you might get
a different one you can get the guard let question not necessarily defer or not necessarily
dispatch but the idea is the same it's some sort of spaghetti code i wouldn't call it something else
and um and and they're trying to trick you into
uh making a mistake with the understanding of those intricate intricacies let's say like that this is
actually very high level question also very high high complexity questions
so yeah how was that for you yeah it was quite difficult
the last one definitely is a bit more complex than the first one and i think because this test so much
uh you need to learn about the synchronous versus asynchronous scheduling you need to
uh learn about the deadlock and serial and parallel cues so there is a lot of things to to
to dissect in this question in a way even if it's it looks so simple and
and the the diff difficult part is that it's actually quite easy to
mistake the sink from asking it looks almost the same like there is one ladder difference
and you just can like make a mistake by not looking
uh well enough let's see yeah and i think it's quite important to
make the code readable also for others yeah yeah so that you know
like if the guy leaves the company the other one comes in i think i think i think this code is unreadable if we have
to spend like 10 minutes if it's asked in the interview it's definitely unreadable but it's a good thing to it's
a good thing to mention that in my opinion yeah absolutely
but okay let's go to the next one so let's go um
MVC architecture (Model, View, Controller)
could you explain what is mvc architecture and what are their main components
uh yeah so the mvc architecture is actually pretty old and the best way to learn about is to
read about the apple's document and i believe it's actually retired documents so it's not supported anymore
uh so there are plenty of materials if you um
there are plenty more heroes but the gist of it is that you have a separate classes for
uh each of your components let's call it like that you have the model which is defining the
uh data layer and the logic of the app uh you have the view which is uh
responsible for the uh presentation and for the uh
user input controls and the controller is actually linking those together for example user presses a button the
controller gets that signal gets that event and then it does something to the model uh and the model
somehow um doing some job and then it notifies the controller about the changes so
basically that's the idea of structuring the app in a way
okay and in ios of course you have the view
and the controller really really closely tied together so that the rvu controller
uh basically a very very uh let's say uh sandwiched approach and the model is
usually uh might be different because it might be a coordinated model it can be a remote
modal on the server or something else but um yeah this is usually the architecture of
the ui kit ios applications so is the controller only used for dui
or could it be used for like data fetching and stuff like that
um no not really i think if i uh the first which i remember is
actually the fetch results controller no i don't know why i'm looking at the
objective c but i think that there is a swift version of it so um of course so the fetch
results controller is basically uh having a fetch request to core data basically responsible to
preparing the data to be displayed to the table views so you have like a table view controller fetch results controller
and you combine them together and you basically got your data presenting showing up in the table view
and that's more like the idea of this small view controller approach to have the modularity
uh that you have the building blocks and you combine them together and uh you
have the ready making like really working app and
fetch results controller doesn't have any ui classes in its import declarations because it's just a
it's just a modal controller it's good like that and then there's a ui document
which is doing the same job essentially a model layer model controller layer for
reading and writing documents for the both mac and ios so
not necessarily uh ui view controller is the most known one and but uh it's not necessarily that
you have yeah you can have the combining roles like for example
uh both controller and view roles this is a view controller then there is model controller
so definitely you can have a different as you can see there is like a different controller
uh objects and there is not necessarily like a it's not necessarily controls the view
in the model it might be it the controller can connect together different pieces it can connect for
example multiple controllers like a navigation controller for example it doesn't operate on the view level
mainly appraising the controller level all right
so how about like when you have modern apps they combine a lot of different content
on a single screen how would you kind of how would you tackle that are you gonna
have like many view controllers like yeah
yeah i think i'll do that so i'll just uh instead of putting everything into one
view controller uh i will uh split the content i'll split the responsibilities among
multiple view controllers and then i'll use something similar to a child view controller approach so i'll add one
controller in a way like you add a sub view i'll add the same way a controller on top of each other and have them
handle specific responsibilities and one of the examples is like of
course there is a official guide for that uh for making a custom view controller
but uh there already is so many of those controllers like navigation controller is one of the
examples and everyone uses is using it and splits view controller is doing the same job and doing quite a lot of work
uh by adapting the interface to the ipad and iphone and split view on ipads so
without even knowing what's the interface all about it just has two controllers and coordinates between them
so i'll definitely go with this hierarchical controller approach
all right clear let's go to the next one so
"weak" and "unowned" keywords
the weak and unknown keywords so
where are they used and what are they for so uh those keywords are related to the
uh they are related to the memory management so um
if i take a look for example in the ui table view uh
if i just go to the ui table view and uh for example data source and delegate are both declared as weak
which means that it will not hold a reference to the data source basically
it will just use it it will query it but it will not hold the memory so whenever
the table view uh whenever a data source has no references
outside now if it doesn't have any anything else it will be deallocated and it's usually uh made so because the
table uses a view and that's why it has to have let's say usually the controller
provides the data and that's why it has to have the delegate weekly hell otherwise we have this reference cycle
so usually the uh when the week is used is used during the
reference to break the reference cycles and uh unknown is very similar to weak
so in the fact that it doesn't add the uh reference count but um
so it will not hold the object strongly in memory but uh the difference is that it will not be
declared as optional so you you use usually unknown cell unknown
cells when when you 100 sure that it will never be
it will never be nil and you just want to like work around the compiler to make it uh to
make it to make it a non-optional type so that you don't have
to like unwrap it all the time and so forth usually you can use that in closures for
example or yeah if you for example refer to uh if you for example refer in lazy
uh closures and laser variable or uh just an enclosure you have to use either
weak or not so not to create a reference cycle all right
usually it's used with usually it's used with a delegates like usually all of the delegates in apple platforms they are
they are connected as weak so they don't hold the the object they are referring to
strongly so are there any exceptions when delegates not held weakly yeah yeah
there are some exceptions for example um there's an serial session it's a very
interesting case uh the basic networking object on ios or
url sessions i'll just switch to the swift version of it and
session delegate the session delegate which is basically an object that receives the events from
the session uh it's a strong reference so you create a session you set a
delegate but the session will hold its delegate strongly and this is important because it might
have a memory leak uh if you don't remember this specification the task is very
simple i guess the intent was that you just instantiate um this delegate and the session basically
handles it the the only purpose of this delegate is to be held by the session
you don't really need anywhere else that's why it was designed that way probably
because if the table view if you think about table view uh the
table as table view is held by the controller and the controller usually is a delegate but in this case like the
session is the main object and delegate is just a additional behavior that you want to
customize that's why it's okay to hold strongly but this inconsistency is really
actually quite tricky and if you forget about that it's really easy to to
to make some problems in the app all right
so always refer to the documentation uh whether it's a weekly or uh strongly
held uh property got it
cool how about the lazy keyword what is that one yeah it's an interesting one uh lazy
"lazy" keyword
is basically laser initialization so that the let's let's take a look at this one uh
i'll find the view that load for example here for patient view controller i'll create something here lazy
variable um what could it be um
another view so for example you can use something to
add like a customization here so uh first of all it's really
convenient to have something customized um like instead of uh if i were to create a
lat constant let view 2 u2 it would be i have to have like that
i have to have it like that and then i have to use a muted load to configure it but here i can just add all the
configurations here
and yeah so the lazy one is used for um mainly for uh
calculating values that you might not need for example if you don't want to add
another view all of the time depending on the on some conditions so like if uh
random you um view adds a view another view so in
this case uh in some of the cases uh when this would be a false the another view will not only will be
added to the uh subview but it won't even be instantiated so that will increase the
performance of the of that a bit so that's one of the uh cases and um
another one is that you have some customization here available so that you can sort of add a tag and so forth so
it's really convenient to uh to add something that you will otherwise
have to write in the method so to keep it close here how about kindle easy keyword be used on
the collection on collections uh yeah yeah yeah it can be used on the collections too
uh so if i create an array then i have to create lazy it'll produce the laser
sequence and then when i have to when i execute a filter it will
um take it one by one basically so or map
so it will not uh it will not uh go through each of those
uh it will not execute the whole code for that but it will execute only when i need the values
to map then map something else if i do map like that to string let me just try
a string in it then map and dabble
in it and if i take the first this will only
take the first value out of this it will not map those will not touch two it will not touch three so if you have a really
really huge collection this will be quite efficient to use lazy on the collections
what if you remove that first would it still go through all what do you mean
if you remove the last method i don't know i know i probably should not go through any of those
okay i don't know the only the only way the only way is to
run i think
i'm going to check it out so probably will be
not even executed because it's just the uh because it's just like a unused
result but let's see trying to figure out what this result is
because this lazy map sequence integer doubles what is this result
lazy map sequence optional dowel and the base sequence is
three elements right so you have these three elements and one two three which are here and the
transformation like combined function which is probably a combination of everything here
and let's try to execute the first
so we're getting the double here right so it went through this
and let's print out the result again uh yeah so we have again
i'm not sure if it's actually caching but but as you can see it didn't execute
anything but it will return you whenever you ask for it whenever you ask for
something okay all right so
let's go to the closures and
"@escaping" closure attribue and non-escaping closures
i hope it's the last one yeah it is the last one so
closures there's those two keywords that always kind of
as a beginner kind of yeah made it difficult to understand
and one of them is the escaping key keyword and the non-escaping is the
other one yep maybe there's another one as well but i'm not sure but can you tell me about
what is an escape enclosure yeah sure there is a there is another one uh auto closure
auto closure but that's probably a different auto closure yeah but that's in a
different video so yeah uh i've added this this simple class here to uh look
at the escaping and no escape so uh the difference is really simple
uh if you so the first of all the escaping parameter applies not only
not really to the closure itself uh but to the closure as the parameter
of the function so um and and what it says essentially is that
you can uh it tells compilot you can store this closure in some variable
that's it because if you don't have this escaping modifier
attribute you you will have to execute it only in the scope somewhere here in
the function as the part for example all this ui view ui kit completion handlers they are
executed in the scopes and there are no escape enclosures and of course you can execute the escape
enclosure here as well there is nothing wrong with that
but if it's a no no escape enclosure you won't be able to assign it so i'll just
uncomment that and i'll get a warning assigning a non-escaping
uh parameter handler to an escape enclosure and if i try to it's implicitly known as
keeping uh at some point and so if it used to be the other way around so the default was
uh the default was escaping and you have to have this no escape attribute to
um change it but if i fix it it will basically add this keeping
and uh not sure if uh if it still has no escape
no it does not so this one is removed yeah
cool so yeah escaping is the one you can store in the variable no escape is the one you can't and there's no escape by
default as of swift five something
okay so like are there any performance benefits if
you kind of yeah i think it has to do with the
performance issues or with the performance optimizations but i don't know uh the details
all right cool but yeah those all the questions i had and
Summary and feedback
i think you you know pretty well all of them so you definitely passed the interview
that's glad to hear unless you're here yeah so
yeah great job glad to hear so yeah
uh i guess that was it thank you dan so much for assisting me and uh grilling me through this interview
uh that was tough to say the least and uh who our viewers enjoyed this as well
yeah i'll put the links i'll put the links to dan uh social media or youtube channel if you
decide to start one and uh uh i think would be good idea so
yeah hopefully that was entertaining and uh if you want to have some if you want me to make some of the
videos on any other topic like um different interview questions just ask them in the comments below i'll go
through all of them and if there is something interesting i'll definitely make a video with the
with those questions and answers so yeah uh good luck in learning ios and uh
subscribe to my channel that's where the new content is going to be soon
cool bye-bye
you

----------

-----

--02--

-----
Date:  2024.02.12
Link: [# 30 tips to be a better iOS developer](https://www.youtube.com/watch?v=HEQGm1gVtOQ)
Transcription:

paste here

----------

-----

--01--

-----
Date: 2024.01.11
Link: [What I Want to See in Swift in 2024 (But Probably Wouldn’t) | @SwiftBird](https://www.youtube.com/watch?v=TnwcB6f9tSw)

Notes:
### Swift Bird 2024: Swift's Future & Wishlist

#### Intro

- **Host**: Yakov
- **Channel**: Swift Bird
- **Topic**: The future of Swift and development tools in 2024, marking the tenth anniversary of Swift.

#### Swift Enhancements

- **Consistency Improvement**: Address language inconsistencies that have crept in over a decade.
- **Example Issue**: Misinterpretation of `private` and `fileprivate` in extensions, stemming from changes in Swift 3.

#### AI Integration in Xcode

- **Ambition**: Incorporate AI into Xcode, enhancing code suggestions and testing, inspired by tools like OpenAI's ChatGPT and GitHub's Copilot.
- **Current Limitations**: Existing AI tools offer limited support for Swift and lack integration with Swift's specific codebases and compiler insights.

#### Swift on the Server

- **Vision**: Expand Swift's presence beyond Apple platforms, specifically for server-side development.
- **Personal Goal**: Develop a fully-functional project on a serverless platform, such as Firebase Functions, using Swift.

#### Additional Thoughts

- **Cross-Platform Development**: Skepticism towards Swift for Android development and cross-platform solutions, based on personal experiences with Kotlin Multiplatform.
- **Swift as a Web Front-end Framework**: Potential but unlikely near-term progress in using Swift for web development.

#### Feedback and Future Content

- **Request for Feedback**: Yakov asks viewers for their opinions on Swift's current state and the points raised in the video.
- **Content Direction**: Consideration of diversifying the channel's content beyond tutorials to include analysis and opinion pieces.

#### Conclusion

- **Next Video Tease**: Upcoming content on a crucial aspect of the software development process that can be improved quickly.
- **Call to Action**: Encourages likes, subscriptions, and support for the Swift Bird channel to help it grow.

Transcription:
Intro
Hey! I’m Yakov, and you’re  watching the Swift Bird.
In the first video of 2024, let’s talk about the  future. This year is an important one for Swift,  
because it marks the tenth  anniversary of the language.
Yeah, I know, it’s hard to believe that.
To me, the introduction of Swift feels  like it was just a couple years ago. I  
still remember that “one more thing”  added to the very end of 2014’s WWDC.
We have a new programming language.
But this video is not about reflecting on the  past. Nor is it about predicting the future.
This time, I’d like to share a few thoughts on  what I wish to see in Swift and the dev tools  
this year. I’ll start with something  small and then go more ambitious.
But before I do, I’m asking you to subscribe  to the Swift Bird. It’s a small channel,  
so each like and subscription makes a big impact.
Swift is nice—but it could be even less confusing
First and foremost, what I want to see improved in  Swift this year is overall language consistency.
Over the ten years Swift’s been out, it’s  become a very versatile tool—something  
like a Swiss army knife. Even though  most updates were publicly discussed,  
debated, and refined before their  release, ten years is still enough  
for some inconsistency to creep in. The  Swift of today is a mix of the concepts  
implemented from the very beginning—and  the paradigms introduced along the way.
I’m not going to overdramataze and say Swift is no  longer easy for beginners. It still is—mostly. But  
at the same time, Swift now has several things  which can confuse even experienced developers.
Here’s one of them. It is something I see  fairly often in all kinds of projects:  
a bunch of symbols meant to be used within just  one class. They can be constants, utilities,  
formatters, and so on. Because they’re  not needed anywhere outside the class,  
it makes a lot of sense to mark them  private. And in many cases, instead of  
putting the keyword before each symbol, they all  are just enclosed in a single private extension.
Except the symbols inside this  extension are not private.
In fact, they’re fileprivate.
Had these symbols truly been private, I wouldn’t  have been able to references them from a different  
object, like this. Even when the object is within  the same file. That’s because the private mode  
is supposed to be stricter than fileprivate.  But in this scenario, that is not the case.
You see, many years ago Swift’s  access-control modifiers used to  
behave slightly differently. Only in version 3  they became what they are today. This redesign,  
however, had certain side effects. One  of them is this implicit transformation  
of private to fileprivate. It was a  compromise for backward compatibility.  
But this compromise remains even after  eight years since Swift 3 came out.
I don’t think every engineer must know  about every caveat of the language. I  
don’t even think knowing about them adds much  value to the engineer’s skill or experience.
Well, I mean, it does. But it really shouldn’t.
I believe the programming language—and  technology in general—is merely a tool  
for solving real-world problems. And for most  engineers, it’s the reality: we work to create  
products that deliver value to the users, not to  impress someone with our textbook-perfect code.
Unless you are writing code  snippets for textbooks, of course.
This was only one example, but you can easily  find many more. For instance, take the APIs  
of some built-in frameworks. Why do you have  functions in some cases but properties in others?
And yeah, I know these are separate frameworks  and not Swift itself. But many of them were  
updated specifically for Swift, and there’s no  reason they cannot be made to look and behave  
even more natively. Even though Swift  was made open-source many years ago,  
Apple still retains huge leverage  over the language evolution. It  
certainly can polish it a bit more and  remove those artifacts of the past.
To sum up, I believe the programming  language should be helping the engineer  
by taking any complexity and confusion  out of the process. And because of that,  
I’d love to see Swift finally say goodbye  to the legacy caveats of the past.
AI’s great, ain’t it? Why not add it to Xcode?
Now we’re moving on to the more ambitious things.
In the last couple of years, artificial  intelligence has made a real breakthrough  
in many areas. You’ve most likely  tried OpenAI’s ChatGPT, Google’s Bard,  
or Microsoft’s Copilot. And chances  are, you use them on a daily basis.  
I do it all the time, especially when  I research something for the videos.
But besides those general-purpose chatbots,  
there’s also a large number of specialized  tools. For example, Google’s NotebookLM  
managed to analyze and explain my own bachelor  thesis even better than I remember it myself.
And of course, AI tools have already made their  way into software development. Perhaps the most  
widely used one is GitHub’s Copilot. But it  has very limited capabilities when it comes to  
Swift. So is Google’s Bard, even though in my own  experience, it works slightly better with Swift.
But even the best tools available today are still  not good enough. That’s because neither of them  
is tailored to the specific Swift codebase  you’re working on. And none of them’s been  
able to marry AI assistance with input from  the actual Swift compiler. That is why you  
sometimes get the code which looks correct but  doesn’t compile when you paste it in Xcode.
And this is where Apple could do a lot.  Just imagine Xcode not only giving you an  
empty template for tests but also filling  it with complete test methods. Moreover,  
imagine how much faster you could work  if Xcode automatically amended any AI  
suggestions based on your actual module  interface and test-coverage percentage.
But sadly, at this point this feels  like only a dream. Because come on,  
right now Xcode often struggles even with  very simple tasks, such as renaming symbols.
Besides, Apple hasn’t demonstrated any sort of  advancement in artificial intelligence yet. And  
when it does, I bet it’s going to be focused  on consumers, not developers. But anyways,  
this is just something I want to see in Xcode  moving forward—it’s not a prediction in any way.
But if you do use AI tools  in you coding work today,  
let me know in the comments. I’m very curious  about your experience: how good they are.
My own use of them is mostly limited to  generating boilerplate—like writing setup  
code in tests. But even in this scenario  I often have to fix the generated code  
afterward. And more complex cases,  such as refactoring large classes,  
so far turned out not even worth my time.  Every time I tried, I ultimately ended up doing  
everything by myself—just because sorting out  the suggestions was much longer and much harder.
What about the back end?
And here comes my biggest wish for  Swift this year. But it also was my  
biggest wish last year and the year before that.
It is about Swift going beyond just  Apple platforms. First and foremost,  
I’m talking about Swift on the server.
As you perhaps know, there’s nothing that  prevents Swift from running on Windows or Linux,  
and even compiling for platforms like WebAssembly.
But just the ability to compile and run  the program is not enough to ensure any  
sort of traction for the language. Swift’s been  available on other platforms for many years,  
but its actual use outside the  Apple ecosystem is still pretty low.
Honestly, I think that’s unfair. Because  all the features that make Swift so great  
on the iPhone could also benefit back-end  developers. Using the same stack could give  
many opportunities to the people developing  client apps that interact with the back  
end—which is basically most developers—and  especially to the people developing client  
apps alongside their back end—people like me.  Right now I mostly use TypeScript and Node for  
writing server-side code in my projects,  and I cannot say I enjoy using them.
With the status quo of Swift on the back end, it’s  just not worth the hassle for most engineers. And  
to me, that feels kind of sad, because there’s  a number of great projects that make using Swift  
on the server just as easy and enjoyable  as on iOS and macOS. And more importantly,  
there’s a fantastic community behind these  projects. Last summer, I was in Apple’s  
mentorship program where I got a few great tips  on using Swift on the back end. It wasn’t the  
easiest thing to set up and use, compared to  developing client apps, so after having built  
a prototype of my own project, I switched  to something else. But anyway, it gave me  
some insight into the overall process—and  also the future plans of the community.
No matter what Apple does this year to push  the server initiatives forward—and frankly,  
I doubt it’s going to do much—my own goal  for this year is to build a fully-functional  
project that runs on a serverless  platform such as Firebase Functions.
Let me know in the comments if you’re  interested in this topic. If you are,  
I’ll be covering my progress on this channel  and probably open-source the project in the end.
In my understanding, Apple has little interest  to invest its own resources into making Swift  
more widespread on the back end. But I guess  it’s time to stop relying on Apple, after all.
A few more things
Before I wrap up, I’d like to mention a  couple things that didn’t make it to my  
wish list. I realize they could have a  huge impact on the developer community,  
and as such they’re wanted by many people.  But I’m just not invested in them personally.
The first thing is yet another aspect of using  Swift beyond just Apple platforms: it’s using the  
language to develop Android apps. A few years ago,  I got some experience with the opposite approach:  
using Kotlin to write the common business logic  for both iOS and Android. And let me tell you,  
it didn’t go well. Though Kotlin Multiplatform  is a first-party initiative of JetBrains,  
the maintainer of Kotlin, even setting up  the cross-platform workflow turned out to  
be a nightmare. My team and I focused  just on the business logic and didn’t  
touch the user interface whatsoever, but  bugs and crashes were abundant, anyways.
Granted, many things could change in  the two years since then. But so far  
cross-platform app development still seems  to mostly come down to using JavaScript  
frameworks like React Native. And in most  cases, such apps don’t feel native at all.
Swift seems an unlikely candidate to become  the cross-platform solution in the near future,  
because its maintainers are mostly  focused on just the Apple platforms.
And here comes one more thing related to  cross-platform development in Swift. It is  
using the language as a front-end framework on  the web. This is something rarely discussed—I  
guess that’s because there’s just  so little overlap between app and  
website developers. But technically,  with its excellent support for DSLs,  
Swift could really shine at building powerful  websites. In addition to easy-to-read syntax,  
it also features built-it safety checks,  so invalid code would just not compile.
But again, I doubt we’re going to see much  progress in this direction any time soon.
What do you think?
And now’s the time for a wrap-up. I explained some  of the things I want to see in the next iterations  
of Swift. I intentionally did not limit myself to  what Apple and the Swift steering board are likely  
to do. It’s more like feedback from someone  who’s been using Swift for over six years.
Of course, now I’m looking forward to  your feedback. Tell me in the comments  
what you like and dislike about today’s Swift. Do  
you agree with any of my points? Or  do you have a different perspective?
I guess it would be interesting  to go back to this topic later  
this year and see what 2024 actually  brings to Swift and its community.
If you enjoyed this video, please give it a  thumbs-up and subscribe to the Swift Bird.  
It’s something that really helps me grow  this little channel. In the description,  
you will also find the links where you can  support the Swift Bird by sponsoring it.
Also tell me what you think about this analysis  genre. I’ve had a look at my last year’s videos  
and noticed most of them were just explainers  and tutorials. While they’re good at answering  
specific questions, sometimes I feel restricted  by the format—that’s without even saying that  
researching and fact-checking every detail  takes a lot of effort. I’m thinking of making  
the channel’s content more diverse with videos  like today’s. I’d love to get your input on that.
Stay tuned for the next video
Next week, I’ll be back with a video on one  crucial piece in the software-development  
process—and how you can improve it in just a  few minutes. Stay tuned, and make your year fly!

----------
